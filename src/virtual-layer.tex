\begin{figure}[H]
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State On input (\textsc{init}, $\texttt{host}_P$, $\bar{P}$,
      \texttt{sibling}, ($\sk{\mathrm{loc}, \mathrm{virt}}$, $\pk{\mathrm{loc},
      \mathrm{virt}}$), $\pk{\mathrm{rem}, \mathrm{virt}}$, $\pk{\mathrm{sib},
      \mathrm{rem}, \mathrm{virt}}$, ($\sk{\mathrm{loc}, F}$, $\pk{\mathrm{loc},
      F}$), $\pk{\mathrm{rem}, F}$, $c_{\mathrm{guest}}$) by \texttt{guest}:
      \Indent
        \State store message contents and \texttt{guest}
        \Comment{\texttt{sibling}, $\pk{\mathrm{sib}, \bar{P}, F}$ are missing
        for edge nodes}
        \State output (\textsc{host init ok}) to \texttt{guest}
      \EndIndent
      \Statex

      \State On input (\textsc{host me}, \texttt{funder}, \texttt{fundee},
      $\bar{P}$, $\texttt{host}_P$, $c_{\mathrm{guest}}$, $\pk{A, V}$, $\pk{B,
      V}$, ($\sk{\mathrm{loc}, \mathrm{virt}}$, $\pk{\mathrm{loc},
      \mathrm{virt}}$), ($\sk{\mathrm{loc}, F}$, $\pk{\mathrm{loc}, F}$),
      $\pk{\mathrm{rem}, F}$, $\pk{\mathrm{rem}, \mathrm{virt}}$) by
      \texttt{guest}:
      \State \TODO{ensure that we can handle being virtual ourselves}
      \Indent
        \State ensure \textsc{virt.circulateKeysAndCoins}() returns (\textsc{ok})
        \State ensure \textsc{virt.circulateVirtualSigs}() returns (\textsc{ok})
        \State ensure \textsc{virt.circulateFundingSigs}() returns (\textsc{ok})
        \State ensure \textsc{virt.circulateRevocations}(\texttt{hops}) returns
        (\textsc{ok})
        \State output (\textsc{hosts ready}) to \texttt{guest}
      \EndIndent
      \Statex

      \State \textsc{circulateKeysAndCoins}(\texttt{left\_data}):
      \Indent
        \If{\texttt{left\_data} is given as argument} \Comment{we are not
        \texttt{host\_funder}}
          \If{we have a \texttt{sibling}} \Comment{we are not
          \texttt{host\_fundee}}
            \State input (\textsc{keys and coins forward}, (\texttt{left\_data},
            $(\sk{\mathrm{loc}, \mathrm{virt}}, \pk{\mathrm{loc},
            \mathrm{virt}})$, ($\sk{\mathrm{loc}, F}$, $\pk{\mathrm{loc}, F}$),
            $\pk{\mathrm{rem}, F}$, $c_P$, $c_{\bar{P}}$) to \texttt{sibling}
            \State \trustedcode{store input as \texttt{left\_data}}
            \State \trustedcode{parse \texttt{left\_data} as
            \texttt{far\_left\_data}, $(\sk{\mathrm{loc}, \mathrm{virt}},
            \pk{\mathrm{loc}, \mathrm{virt}})$, ($\sk{\mathrm{sib}, F}$,
            $\pk{\mathrm{sib}, F}$), $\pk{\mathrm{sib}, \mathrm{rem}, F}$,
            $c_{\mathrm{sib}}$, $c_{\mathrm{sib}, \mathrm{rem}}$}
            \Comment{remove parentheses as necessary}
            \State \trustedcode{call
            \textsc{virt.circulateKeysAndCoins}(\texttt{left\_data}) of
            $\bar{P}$ and assign returned value to \texttt{right\_data}}
            \State \trustedcode{parse \texttt{right\_data} as
            \texttt{far\_right\_data}, $\pk{\mathrm{rem}, \mathrm{virt}}$}
            \State \trustedcode{output (\textsc{keys and coins back},
            \texttt{right\_data}, ($\sk{\mathrm{loc}, F}$, $\pk{\mathrm{loc},
            F}$), $\pk{\mathrm{rem}, F}$, $c_P$, $c_{\bar{P}}$)}
            \State store output as \texttt{right\_data}
            \State parse \texttt{right\_data} as \texttt{far\_right\_data},
            ($\sk{\mathrm{sib}, F}$, $\pk{\mathrm{sib}, F}$), $\pk{\mathrm{sib},
            \mathrm{rem}, F}$, $c_{\mathrm{sib}}$, $c_{\mathrm{sib},
            \mathrm{rem}}$
            \State \Return (\texttt{right\_data}, $\pk{\mathrm{loc},
            \mathrm{virt}}$)
          \Else \: \Comment{we are \texttt{host\_fundee}}
            \State \TODO{there is a problem with the base-virtual channel
            semantics, as a base channel becomes virtual itself when it
            facilitates another virtual. When it's solved, we may have to
            reconsider the \texttt{fundee} below.}
            \State \TODO{may need to notify guest(s)}
            \State \Return $\pk{\mathrm{loc}, \mathrm{virt}}$
          \EndIf
        \Else \: \Comment{we are \texttt{host\_funder}}
          \State call \textsc{virt.circulateKeysAndCoins}($\pk{\mathrm{loc},
          \mathrm{virt}}$) of $\bar{P}$ and assign returned value to
          \texttt{right\_data}
          \State \Return (\textsc{ok})
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:keys}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State \textsc{getMidTXs}($c_{\mathrm{guest}}$, $c_{\mathrm{loc}}$,
      $c_{\mathrm{rem}}$, $c_{\mathrm{sib}}$, $c_{\mathrm{sibRem}}$,
      $\pk{\mathrm{left}, \mathrm{fund}}$, $\pk{\mathrm{loc}, \mathrm{fund}}$,
      $\pk{\mathrm{sib}, \mathrm{fund}}$, $\pk{\mathrm{right}, \mathrm{fund}}$,
      $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{virt}}$,
      $\pk{\mathrm{sib}, \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$,
      $\pk{\mathrm{left}, \mathrm{guest}}$, $\pk{\mathrm{right},
      \mathrm{guest}}$, $\pk{\mathrm{loc}, \mathrm{out}}$, $\{\pk{\mathrm{sec},
      i}\}_{i \in 1 \dots n}$):
      \Indent
        \State ensure $c_{\mathrm{sibRem}} \geq c_{\mathrm{guest}} \wedge
        c_{\mathrm{loc}} \geq c_{\mathrm{guest}}$
        \State $c_{\mathrm{left}} \gets c_{\mathrm{sib}} + c_{\mathrm{sibRem}}$;
        $c_{\mathrm{right}} \gets c_{\mathrm{loc}} + c_{\mathrm{rem}}$
        \State $\texttt{left\_fund} \gets 2/\{\pk{\mathrm{left}, \mathrm{fund}},
        \pk{\mathrm{loc}, \mathrm{fund}}\}$
        \State $\texttt{right\_fund} \gets 2/\{\pk{\mathrm{sib}, \mathrm{fund}},
        \pk{\mathrm{right}, \mathrm{fund}}\}$
        \State $\texttt{left\_virt} \gets 2/\{\pk{\mathrm{left}, \mathrm{virt}},
        \pk{\mathrm{loc}, \mathrm{virt}}\}$
        \State $\texttt{left\_virt\_checked} \gets 4/\{\pk{\mathrm{left},
        \mathrm{virt}}, \pk{\mathrm{loc}, \mathrm{virt}}, \pk{\mathrm{left},
        \mathrm{guest}}, \pk{\mathrm{right}, \mathrm{guest}}\}$
        \State $\texttt{right\_virt} \gets 2/\{\pk{\mathrm{sib}, \mathrm{virt}},
        \pk{\mathrm{right}, \mathrm{virt}}\}$
        \State $\texttt{right\_virt\_checked} \gets 4/\{\pk{\mathrm{sib},
        \mathrm{virt}}, \pk{\mathrm{right}, \mathrm{virt}}, \pk{\mathrm{left},
        \mathrm{guest}}, \pk{\mathrm{right}, \mathrm{guest}}\}$
        \State $\texttt{left\_out\_checked} \gets (\texttt{2} \wedge
        \texttt{left\_virt\_checked}) \vee (\texttt{3} \wedge
        \texttt{left\_virt} + t)$
        \State $\texttt{right\_out} \gets (\texttt{1} \wedge
        \texttt{right\_virt}) \vee (\texttt{3} \wedge \texttt{right\_virt} + t)$
        \State $\texttt{right\_out\_checked} \gets (\texttt{1} \wedge
        \texttt{right\_virt\_checked}) \vee (\texttt{3} \wedge
        \texttt{right\_virt} + t)$
        \State $\texttt{guest\_all} \gets \texttt{5} \wedge
        n/\{\pk{\mathrm{left}, \mathrm{guest}}, \pk{\mathrm{right},
        \mathrm{guest}}, \{\pk{\mathrm{sec}, 1 \dots n}\}\}$
        \State $\texttt{guest\_out} \gets \texttt{4} \wedge
        2/\{\pk{\mathrm{left}, \mathrm{guest}}, \pk{\mathrm{right},
        \mathrm{guest}}\}$
        \State $\texttt{guest} \gets (\texttt{guest\_out} + t) \vee
        \texttt{guest\_all}$
        \State $\mathrm{TX}_{\mathrm{none}} \gets$ TX \{inputs:
        (($c_{\mathrm{left}}$, \texttt{left\_fund}), ($c_{\mathrm{right}}$,
        \texttt{right\_fund})), outputs: (($c_{\mathrm{left}} -
        c_{\mathrm{guest}}$, \texttt{left\_out\_checked}), ($c_{\mathrm{right}}
        - c_{\mathrm{guest}}$, \texttt{right\_out\_checked}),
        ($c_{\mathrm{guest}}$, $\pk{\mathrm{loc}, \mathrm{out}}$),
        ($c_{\mathrm{guest}}$, \texttt{guest}))\}
        \State $\mathrm{TX}_{\mathrm{left}} \gets$ TX \{inputs:
        (($c_{\mathrm{left}} - c_{\mathrm{guest}}$, \texttt{1} $\wedge$
        \texttt{left\_virt\_checked}), ($c_{\mathrm{right}}$,
        \texttt{right\_fund})), outputs: (($c_{\mathrm{left}} -
        c_{\mathrm{guest}}$, \texttt{3} $\wedge$ \texttt{left\_virt}),
        ($c_{\mathrm{right}} - c_{\mathrm{guest}}$,
        \texttt{right\_out\_checked}), ($c_{\mathrm{guest}}$, $\pk{\mathrm{loc},
        \mathrm{out}}$))\}
        \State $\mathrm{TX}_{\mathrm{right}} \gets$ TX \{inputs:
        (($c_{\mathrm{left}}$, \texttt{left\_fund}), ($c_{\mathrm{right}} -
        c_{\mathrm{guest}}$, \texttt{2} $\wedge$ \texttt{right\_virt\_checked}),
        ($c_{\mathrm{guest}}$, \texttt{guest\_all})), outputs:
        (($c_{\mathrm{left}} - c_{\mathrm{guest}}$,
        \texttt{left\_out\_checked}), ($c_{\mathrm{right}} -
        c_{\mathrm{guest}}$, \texttt{3} $\wedge$ \texttt{right\_virt}),
        ($c_{\mathrm{guest}}$, $\pk{\mathrm{loc}, \mathrm{out}}$),
        ($c_{\mathrm{guest}}$, \texttt{guest}))\} \State
        $\mathrm{TX}_{\mathrm{both}} \gets$ TX \{inputs: (($c_{\mathrm{left}} -
        c_{\mathrm{guest}}$, \texttt{1} $\wedge$ \texttt{left\_virt\_checked}),
        ($c_{\mathrm{right}} - c_{\mathrm{guest}}$, \texttt{2} $\wedge$
        \texttt{right\_virt\_checked}), ($c_{\mathrm{guest}}$,
        \texttt{guest\_all})), outputs: (($c_{\mathrm{left}} -
        c_{\mathrm{guest}}$, \texttt{3} $\wedge$ \texttt{left\_virt}),
        ($c_{\mathrm{right}} - c_{\mathrm{guest}}$, \texttt{3} $\wedge$
        \texttt{right\_virt}), ($c_{\mathrm{guest}}, \pk{\mathrm{loc},
        \mathrm{out}}$)\}
        \State \Return ($\mathrm{TX}_{\mathrm{none}}$,
        $\mathrm{TX}_{\mathrm{left}}$, $\mathrm{TX}_{\mathrm{right}}$,
        $\mathrm{TX}_{\mathrm{both}}$)
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:mid-txs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State \Comment{left and right refer to the two counterparties, with left
      being the one closer to the funder. Note difference with left/right
      meaning in \textsc{virt.getMidTXs}.}
      \State \textsc{getEdgeTXs}($c_{\mathrm{guest}}$, $c_{\mathrm{left}}$,
      $c_{\mathrm{right}}$, $\pk{\mathrm{left}, \mathrm{fund}}$,
      $\pk{\mathrm{right}, \mathrm{fund}}$, $\pk{\mathrm{left}, \mathrm{virt}}$,
      $\pk{\mathrm{right}, \mathrm{virt}}$, $\pk{\mathrm{left},
      \mathrm{guest}}$, $\pk{\mathrm{right}, \mathrm{guest}}$,
      $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$, \texttt{is\_funder}):
      \Indent
        \State ensure $c_{\mathrm{left}} \geq c_{\mathrm{guest}}$
        \State $c_{\mathrm{tot}} \gets c_{\mathrm{left}} + c_{\mathrm{right}}$
        \State $\texttt{fund} \gets 2/\{\pk{\mathrm{left}, \mathrm{fund}},
        \pk{\mathrm{right}, \mathrm{fund}}\}$
        \State $\texttt{virt} \gets 2/\{\pk{\mathrm{left}, \mathrm{virt}},
        \pk{\mathrm{right}, \mathrm{virt}}\}$
        \State $\texttt{virt\_checked} \gets 4/\{\pk{\mathrm{left},
        \mathrm{virt}}, \pk{\mathrm{right}, \mathrm{virt}}, \pk{\mathrm{left},
        \mathrm{guest}}, \pk{\mathrm{right}, \mathrm{guest}}\}$
        \If{\texttt{is\_funder} = True}
          \State $\texttt{out} \gets (\texttt{1} \wedge \texttt{virt\_checked})
          \vee (\texttt{3} \wedge \texttt{virt} + t)$
        \Else \: \Comment{TXs belong to \texttt{fundee}}
          \State $\texttt{out} \gets (\texttt{2} \wedge \texttt{virt\_checked})
          \vee (\texttt{3} \wedge \texttt{virt} + t)$
        \EndIf
        \State $\texttt{guest\_all} \gets \texttt{5} \wedge
        n/\{\pk{\mathrm{left}, \mathrm{guest}}, \pk{\mathrm{right},
        \mathrm{guest}}, \{\pk{\mathrm{sec}, 1 \dots n}\}\}$
        \State $\texttt{guest\_out} \gets \texttt{4} \wedge
        2/\{\pk{\mathrm{left}, \mathrm{guest}}, \pk{\mathrm{right},
        \mathrm{guest}}\}$
        \State $\texttt{guest} \gets (\texttt{guest\_out} + t) \vee
        \texttt{guest\_all}$
        \State $\mathrm{TX}_{\mathrm{base}} \gets$ TX \{input:
        ($c_{\mathrm{tot}}$, \texttt{fund}), outputs: (($c_{\mathrm{tot}} -
        c_{\mathrm{guest}}$, \texttt{out}), ($c_{\mathrm{guest}}$,
        \texttt{guest}))\}
        \State \Return $\mathrm{TX}_{\mathrm{base}}$
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:edge-txs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.siblingSigs}()}
    \begin{algorithmic}[1]
      \State parse input as $\mathrm{sigs}_{\mathrm{byLeft}}$
      \State ($\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$,
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{left}}$, $\mathrm{TX}_{\mathrm{loc},
      \mathrm{right}}$, $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$) $\gets$
      \textsc{virt.getMidTXs}($c_{\mathrm{guest}}$, $c_P$, $c_{\bar{P}}$,
      $c_{\mathrm{sib}}$, $c_{\mathrm{sib}, \mathrm{rem}}$, $\pk{\mathrm{sib},
      \mathrm{rem}, F}$, $\pk{\mathrm{sib}, F}$, $\pk{\mathrm{loc}, F}$,
      $\pk{\mathrm{rem}, F}$, $\pk{\mathrm{sib}, \mathrm{rem}, \mathrm{virt}}$,
      $\pk{\mathrm{loc}, \mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{virt}}$,
      $\pk{\mathrm{rem}, \mathrm{virt}}$, $\pk{\mathrm{left}, \mathrm{guest}}$,
      $\pk{\mathrm{right}, \mathrm{guest}}$, $\pk{\mathrm{loc}, \mathrm{virt}}$,
      $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$)
      \State store all signatures in $\mathrm{sigs}_{\mathrm{byLeft}}$ that sign
      any of $\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$,
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{left}}$, $\mathrm{TX}_{\mathrm{loc},
      \mathrm{right}}$, $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$ and remove
      these signatures from $\mathrm{sigs}_{\mathrm{byLeft}}$
      \State ensure that the stored signatures contain one valid
      signature for $\mathrm{TX}_{\mathrm{loc}, \mathrm{right}}$ and
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$ which sign the
      \texttt{guest\_all} input by each one of the previous $j-1$ hops
      \State ensure that there are exactly $4$ more valid signatures in the
      stored signatures, which sign the $\texttt{1} \wedge
      \texttt{left\_virt\_checked}$ inputs of $\mathrm{TX}_{\mathrm{loc},
      \mathrm{left}}$ and $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$ with
      $\pk{\mathrm{sib}, \mathrm{rem}, \mathrm{virt}}$ and $\pk{\mathrm{left},
      \mathrm{guest}}$
      \State $\mathrm{sigs}_{\mathrm{toRight}} \gets
      \mathrm{sigs}_{\mathrm{byLeft}}$
      \For{each hop apart from the first, the last and ours ($i \in [2, \dots,
      n-1] \setminus \{j\}$)} \Comment{$j$ is our hop number, hop data encoded
      in \texttt{left\_data} and \texttt{right\_data}}
        \State extract data needed for \textsc{getMidTXs}() from
        \texttt{left\_data} (if $i < j$) or \texttt{right\_data} (if $i > j$)
        and assign it to $\texttt{data}_i$ and $\{\pk{\mathrm{sec}, i}\}_{i \in
        1 \dots n}$ \Comment{$P$ and \texttt{comm\_keys} are missing, that is
        OK. $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$ contains each party's
        $\pk{i, \mathrm{virt}}$}
        \State ($\mathrm{TX}_{i, \mathrm{none}}$, $\mathrm{TX}_{i,
        \mathrm{left}}$, $\mathrm{TX}_{i, \mathrm{right}}$, $\mathrm{TX}_{i,
        \mathrm{both}}$) $\gets$ \textsc{virt.getMidTXs}($\texttt{data}_i$,
        $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$)
        \State add \textsc{sign}($\mathrm{TX}_{i, \mathrm{right}}$,
        $\sk{\mathrm{loc}, \mathrm{virt}}$, \textsc{anyprevout}) and
        \textsc{sign}($\mathrm{TX}_{i, \mathrm{both}}$, $\sk{\mathrm{loc},
        \mathrm{virt}}$, \textsc{anyprevout}) to
        $\mathrm{sigs}_{\mathrm{toLeft}}$ if $i < j$, or
        $\mathrm{sigs}_{\mathrm{toRight}}$ if $i > j$ \Comment{if $i$-th hop is
        adjacent, $2$ signatures will be produced by each \textsc{sign}()
        invocation: one for the \texttt{guest\_all} and one for the $\texttt{2}
        \wedge \texttt{right\_virt\_checked}$ input}
        \If{$i - j = 1$} \Comment{hop is our next}
          \State add \textsc{sign}($\mathrm{TX}_{i, \mathrm{left}}$,
          $\sk{\mathrm{loc}, \mathrm{virt}}$, \textsc{anyprevout}) to
          $\mathrm{sigs}_{\mathrm{toRight}}$
        \ElsIf{$j - i = 1$} \Comment{hop is our previous}
          \State add \textsc{sign}($\mathrm{TX}_{i, \mathrm{left}}$,
          $\sk{\mathrm{loc}, \mathrm{virt}}$, \textsc{anyprevout}) to
          $\mathrm{sigs}_{\mathrm{toLeft}}$
        \EndIf
      \EndFor
      \If{\texttt{right\_data} does not contain data from a second-next hop}
      \Comment{next hop is \texttt{host\_fundee}}
        \State $\mathrm{TX}_{\mathrm{next}, \mathrm{none}}$ $\gets$
        \textsc{virt.getEdgeTXs}($c_{\mathrm{guest}}$, $c_P$, $c_{\bar{P}}$,
        $\pk{\mathrm{loc}, F}$, $\pk{\mathrm{rem}, F}$, $\pk{\mathrm{loc},
        \mathrm{virt}}$, $\pk{\mathrm{rem}, \mathrm{virt}}$, $\pk{\mathrm{left},
        \mathrm{guest}}$, $\pk{\mathrm{right}, \mathrm{guest}}$, False)
      \EndIf
      \State call
      $\bar{P}$.\textsc{circulateVirtualSigs}($\mathrm{sigs}_{\mathrm{toRight}}$)
      and assign returned value to $\mathrm{sigs}_{\mathrm{byRight}}$
      \State store all signatures in $\mathrm{sigs}_{\mathrm{byRight}}$ that
      sign any of $\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$,
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{left}}$, $\mathrm{TX}_{\mathrm{loc},
      \mathrm{right}}$, $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$ and remove
      these signatures from $\mathrm{sigs}_{\mathrm{byRight}}$
      \State ensure that the stored signatures contain one valid signature for
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{right}}$ and
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$ which sign the
      \texttt{guest\_all} input by each one of the next $n-j$ hops
      \State ensure that there are exactly $4$ more valid signatures in the
      stored signatures, which sign the $\texttt{2} \wedge
      \texttt{right\_virt\_checked}$ inputs of $\mathrm{TX}_{\mathrm{loc},
      \mathrm{right}}$ and $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$ with
      $\pk{\mathrm{rem}, \mathrm{virt}}$ and $\pk{\mathrm{right},
      \mathrm{guest}}$
      \State output (\textsc{virtualSigsBack},
      $\mathrm{sigs}_{\mathrm{toLeft}}$, $\mathrm{sigs}_{\mathrm{byRight}}$)
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:sibling-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.intermediarySigs}()}
    \begin{algorithmic}[1]
      \State ($\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$,
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{left}}$, $\mathrm{TX}_{\mathrm{loc},
      \mathrm{right}}$, $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$)
      $\gets$ \textsc{virt.getMidTXs}($c$, $c_P$, $c_{\bar{P}}$,
      $c_{\mathrm{sib}}$, $c_{\mathrm{sib}, \mathrm{rem}}$, $\pk{\mathrm{loc},
      F}$, $\pk{\mathrm{rem}, F}$, $\pk{\mathrm{sib}, F}$, $\pk{\mathrm{sib},
      \mathrm{rem} F}$, \texttt{left\_data}.$\pk{\mathrm{rem}, \mathrm{virt}}$,
      $\pk{\mathrm{loc}, \mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{virt}}$,
      \texttt{right\_data}.$\pk{\mathrm{sib}, \mathrm{rem}, \mathrm{virt}}$,
      $\pk{A, V}$, $\pk{B, V}$, $\pk{\mathrm{loc}, \mathrm{virt}}$,
      \texttt{comm\_keys\_loc}, \texttt{comm\_keys\_rem}, $\bar{P}$)
      \State \Comment{not verifying our signatures in
      $\mathrm{sigs}_{\mathrm{byLeft}}$, our (trusted) \texttt{sibling} will do
      that}
      \State input (\textsc{virtual sigs forward},
      $\mathrm{sigs}_{\mathrm{byLeft}}$) to \texttt{sibling}
      \State \trustedcode{\textsc{virt.siblingSigs}()}
      \State $\mathrm{sigs}_{\mathrm{toLeft}} \gets
      \mathrm{sigs}_{\mathrm{byRight}} + \mathrm{sigs}_{\mathrm{toLeft}}$
      \If{\texttt{left\_data} does not contain data from a second-previous hop}
      \Comment{previous hop is \texttt{host\_funder}}
        \State $\mathrm{TX}_{\mathrm{prev}, \mathrm{none}}$ $\gets$
        \textsc{virt.getEdgeTXs}($c_{\mathrm{guest}}$, $c_{\bar{P}}$, $c_P$,
        $\pk{\mathrm{rem}, F}$, $\pk{\mathrm{loc}, F}$, $\pk{\mathrm{rem},
        \mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{virt}}$, $\pk{\mathrm{loc},
        \mathrm{virt}}$, $\pk{\mathrm{left}, \mathrm{guest}}$,
        $\pk{\mathrm{right}, \mathrm{guest}}$, True)
      \EndIf
      \State \Return $\mathrm{sigs}_{\mathrm{toLeft}}$
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:intermediary-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.circulateVirtualSigs}($\mathrm{sigs}_{\mathrm{byLeft}}$)}
    \begin{algorithmic}[1]
      \If{$\mathrm{sigs}_{\mathrm{byLeft}}$ is given as argument} \Comment{we
      are not \texttt{host\_funder}}
        \If{we have a \texttt{sibling}} \Comment{we are not
        \texttt{host\_fundee}}
          \State \Return \textsc{virt.intermediarySigs}()
        \Else \: \Comment{we are \texttt{host\_fundee}}
          \State $\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$ $\gets$
          \textsc{virt.getEdgeTXs}($c_{\mathrm{guest}}$, $c_P$, $c_{\bar{P}}$,
          $\pk{\mathrm{loc}, F}$, $\pk{\mathrm{rem}, F}$, $\pk{\mathrm{loc},
          \mathrm{virt}}$, $\pk{\mathrm{rem}, \mathrm{virt}}$,
          $\pk{\mathrm{left}, \mathrm{guest}}$, $\pk{\mathrm{right},
          \mathrm{guest}}$, False)
          \For{each hop apart from the first and ours ($i \in [2, \dots, n-1]$)}
          \Comment{hop data encoded in \texttt{left\_data}}
            \State extract data needed for \textsc{getMidTXs}() from
            \texttt{left\_data} and assign it to $\texttt{data}_i$ and
            $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$
            \Comment{$\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$ contains each
            party's $\pk{i, \mathrm{virt}}$}
            \State ($\mathrm{TX}_{i, \mathrm{none}}$, $\mathrm{TX}_{i,
            \mathrm{left}}$, $\mathrm{TX}_{i, \mathrm{right}}$, $\mathrm{TX}_{i,
            \mathrm{both}}$) $\gets$ \textsc{virt.getMidTXs}($\texttt{data}_i$,
            $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$)
            \State add \textsc{sign}($\mathrm{TX}_{i, \mathrm{right}}$,
            $\sk{\mathrm{loc}, \mathrm{virt}}$, \textsc{anyprevout}) and
            \textsc{sign}($\mathrm{TX}_{i, \mathrm{both}}$, $\sk{\mathrm{loc},
            \mathrm{virt}}$, \textsc{anyprevout}) to
            $\mathrm{sigs}_{\mathrm{toLeft}}$ \Comment{if $i$-th hop is
            adjacent, $2$ signatures will be produced by each \textsc{sign}()
            invocation: one for the \texttt{guest\_all} and one for the
            $\texttt{2} \wedge \texttt{right\_virt\_checked}$ input}
            \If{$i = n - 1$} \Comment{hop is our previous}
              \State add \textsc{sign}($\mathrm{TX}_{i, \mathrm{left}}$,
              $\sk{\mathrm{loc}, \mathrm{virt}}$, \textsc{anyprevout}) to
              $\mathrm{sigs}_{\mathrm{toLeft}}$
            \EndIf
          \EndFor
          \State \Return $\mathrm{sigs}_{\mathrm{toLeft}}$
        \EndIf
      \Else \: \Comment{we are \texttt{host\_funder}}
        \For{each hop apart from the last and ours ($i \in [2, \dots, n-1]$)}
        \Comment{hop data encoded in \texttt{right\_data}}
          \State extract data needed for \textsc{getMidTXs}() from
          \texttt{right\_data} and assign it to $\texttt{data}_i$ and
          $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$
          \Comment{$\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$ contains each
          party's $\pk{i, \mathrm{virt}}$}
          \State ($\mathrm{TX}_{i, \mathrm{none}}$, $\mathrm{TX}_{i,
          \mathrm{left}}$, $\mathrm{TX}_{i, \mathrm{right}}$, $\mathrm{TX}_{i,
          \mathrm{both}}$) $\gets$ \textsc{virt.getMidTXs}($\texttt{data}_i$,
          $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$)
          \State add \textsc{sign}($\mathrm{TX}_{i, \mathrm{right}}$,
          $\sk{\mathrm{loc}, \mathrm{virt}}$, \textsc{anyprevout}) and
          \textsc{sign}($\mathrm{TX}_{i, \mathrm{both}}$, $\sk{\mathrm{loc},
          \mathrm{virt}}$, \textsc{anyprevout}) to
          $\mathrm{sigs}_{\mathrm{toRight}}$ \Comment{if $i$-th hop is
          adjacent, $2$ signatures will be produced by each \textsc{sign}()
          invocation: one for the \texttt{guest\_all} and one for the
          $\texttt{2} \wedge \texttt{right\_virt\_checked}$ input}
          \If{$i = 2$} \Comment{hop is our next}
            \State add \textsc{sign}($\mathrm{TX}_{i, \mathrm{left}}$,
            $\sk{\mathrm{loc}, \mathrm{virt}}$, \textsc{anyprevout}) to
            $\mathrm{sigs}_{\mathrm{toRight}}$
          \EndIf
        \EndFor
        \State call
        \textsc{virt.circulateVirtualSigs}($\mathrm{sigs}_{\mathrm{toRight}}$)
        of $P$ and assign output to $\mathrm{sigs}_{\mathrm{byRight}}$
        \State $\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$ $\gets$
        \textsc{virt.getEdgeTXs}($c_{\mathrm{guest}}$, $c_P$, $c_{\bar{P}}$,
        $\pk{\mathrm{loc}, F}$, $\pk{\mathrm{rem}, F}$, $\pk{\mathrm{loc},
        \mathrm{virt}}$, $\pk{\mathrm{rem}, \mathrm{virt}}$, $\pk{\mathrm{left},
        \mathrm{guest}}$, $\pk{\mathrm{right}, \mathrm{guest}}$, True)
        \State \Return (\textsc{ok})
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:virtual-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.circulateFundingSigs}($\mathrm{sig}_{\mathrm{loc},
  \mathrm{none}}$)}
    \begin{algorithmic}[1]
      \If{$\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$ is given as argument}
      \Comment{we are not \texttt{host\_funder}}
        \State ensure \textsc{verify}($\mathrm{TX}_{\mathrm{loc},
        \mathrm{none}}$, $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$,
        $\pk{\mathrm{prev}, F}$) = True \Comment{$\pk{\mathrm{prev}, F}$, found
        in \texttt{left\_data}}
        \State $\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}} \gets \{
        \mathrm{sig}_{\mathrm{loc}, \mathrm{none}} \}$
        \If{we have a \texttt{sibling}} \Comment{we are not \texttt{host\_fundee}}
          \State input (\textsc{virtual base sig forward},
          $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$) to \texttt{sibling}
          \Comment{\texttt{sibling} needs $\mathrm{sig}_{\mathrm{loc},
          \mathrm{none}}$ for closing}
          \State \trustedcode{$\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}} \gets
          \{ \mathrm{sig}_{\mathrm{loc}, \mathrm{none}} \}$}
          \State \trustedcode{$\mathrm{sig}_{\mathrm{next}, \mathrm{none}} \gets
          \textsc{sign}(\mathrm{TX}_{\mathrm{next}, \mathrm{none}},
          \sk{\mathrm{loc}, F})$}
          \State \trustedcode{call
          \textsc{virt.circulateVirtualSigs}($\mathrm{sig}_{\mathrm{next},
          \mathrm{none}}$) of $\bar{P}$ and assign returned value to
          $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$}
          \State \trustedcode{ensure \textsc{verify}($\mathrm{TX}_{\mathrm{loc},
          \mathrm{none}}$, $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$,
          $\pk{\mathrm{next}, F}$) = True} \Comment{$\pk{\mathrm{next}, F}$,
          found in \texttt{right\_data}}
          \State \trustedcode{add $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$
          to $\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}}$}
          \State \trustedcode{output (\textsc{virtual base sig back},
          $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$) \Comment{sibling needs
          $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$ for closing}}
          \State add $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$ to
          $\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}}$
        \EndIf
        \State $\mathrm{sig}_{\mathrm{prev}, \mathrm{none}} \gets
        \textsc{sign}(\mathrm{TX}_{\mathrm{prev}, \mathrm{none}},
        \sk{\mathrm{loc}, F})$
        \State \Return $\mathrm{sig}_{\mathrm{prev}, \mathrm{none}}$
      \Else \: \Comment{we are \texttt{host\_funder}}
        \State $\mathrm{sig}_{\mathrm{next}, \mathrm{none}} \gets
        \textsc{sign}(\mathrm{TX}_{\mathrm{next}, \mathrm{none}},
        \sk{\mathrm{loc}, F})$
        \State call
        \textsc{virt.circulateFundingSigs}($\mathrm{sig}_{\mathrm{next},
        \mathrm{none}}$) of $\bar{P}$ and assign returned value to
        $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$
        \State ensure \textsc{verify}($\mathrm{TX}_{\mathrm{loc},
        \mathrm{none}}$, $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$,
        $\pk{\mathrm{next}, F}$) = True \Comment{$\pk{\mathrm{next}, F}$ found
        in \texttt{right\_data}}
        \State $\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}} \gets \{
        \mathrm{sig}_{\mathrm{loc}, \mathrm{none}} \}$
        \State \Return (\textsc{ok})
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:funding-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.circulateRevocations}(\texttt{hops},
  \texttt{revoc\_by\_prev})}
    \begin{algorithmic}[1]
    \If{\texttt{revoc\_by\_prev} is given as argument} \Comment{we are not
    \texttt{host\_funder}}
      \State ensure
      \textsc{pcn.processRemoteRevocation}(\texttt{revoc\_by\_prev}) returns
      (\textsc{ok})
    \Else \: \Comment{we are \texttt{host\_funder}}
      \State $\texttt{revoc\_for\_next} \gets \textsc{pcn.revokePrevious}()$
      \State call \textsc{virt.circulateRevocations}(\texttt{hops},
      \texttt{revoc\_for\_next}) of \texttt{hops}[0].\bob and assign output to
      \texttt{revoc\_by\_next}
      \State ensure
      \textsc{pcn.processRemoteRevocation}(\texttt{revoc\_by\_next}) returns
      (\textsc{ok})
      \State input (\textsc{virtual layer ready}) to \texttt{funder}
      \State \trustedcode{$\textit{State} \gets \textsc{open}$} \TODO{recheck
      state machine}
      \State \trustedcode{reply (\textsc{ok})}
      \State \Return (\textsc{ok})
    \EndIf
    \If{len(\texttt{hops}) $> 1$} \Comment{we are not \texttt{host\_fundee} nor
    \texttt{host\_funder}}
      \State input (\textsc{virtual revocation forward}, \texttt{hops}[1:]) to
      \texttt{hops}[1].\alice
      \State \trustedcode{$\texttt{revoc\_for\_next} \gets
      \textsc{pcn.revokePrevious}()$}
      \State \trustedcode{call \textsc{virt.circulateRevocations}(\texttt{hops},
      \texttt{revoc\_for\_next}) of \texttt{hops}[0].\bob and assign output to
      \texttt{revoc\_by\_next}}
      \State \trustedcode{ensure
      \textsc{pcn.processRemoteRevocation}(\texttt{revoc\_by\_next}) returns
      (\textsc{ok})}
      \State \trustedcode{output (\textsc{virtual revocation back})}
    \EndIf
    \State $\texttt{revoc\_for\_prev} \gets \textsc{pcn.revokePrevious}()$
    \If{len(\texttt{hops}) = 1} \Comment{we are \texttt{host\_fundee}}
      \State output (\textsc{hosts ready}) to \texttt{guest}
      \State \trustedcode{$\textit{State} \gets \textsc{open}$} \TODO{recheck
      state machine}
      \State \trustedcode{reply (\textsc{ok})}
    \EndIf
    \State \Return \texttt{revoc\_for\_prev}
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:revocation}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt} -- close}
    \begin{algorithmic}[1]
      \State On input (\textsc{close}) by $P \in \texttt{guests}$:
      \Indent
        \If{\textit{State} = \textsc{closed}}
          \State output (\textsc{closed}) to $P$
        \EndIf
        \State ensure \textit{State} = \textsc{open}
        \If{$\texttt{host} \neq \ledger$} \Comment{\texttt{host} is a \textsc{virt}}
          \State ignore all messages except for output (\textsc{closed}) by
          \texttt{host}. Also relay to \texttt{host} any (\textsc{check chain
          for closing}) input received
          \State input (\textsc{close}) to \texttt{host}
        \EndIf
        \State \Comment{if we have a \texttt{host}, continue from here on output
        (\textsc{closed}) by it}
        \State send (\textsc{read}) to \ledger and assign reply to
        \texttt{chain}
        \State let \texttt{tx} be the unique valid TX for \texttt{chain} among
        ($\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$,
        $\mathrm{TX}_{\mathrm{loc}, \mathrm{left}}$, $\mathrm{TX}_{\mathrm{loc},
        \mathrm{right}}$, $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$)
        \Comment{if we are not an intermediary, only the first exists}
        \State let \texttt{sigs} be the corresponding set of signatures among
        ($\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}}$,
        $\mathrm{sigs}_{\mathrm{loc}, \mathrm{left}}$,
        $\mathrm{sigs}_{\mathrm{loc}, \mathrm{right}}$,
        $\mathrm{sigs}_{\mathrm{loc}, \mathrm{both}}$)
        \State add \textsc{sign}(\texttt{tx}, $\sk{A, F}$) and
        \textsc{sign}(\texttt{tx}, $\sk{\mathrm{loc}, \mathrm{virt}}$) to
        \texttt{sigs} \Comment{one of the two signatures may be empty, as some
        transactions don't need a signature by both keys. This is not a
        problem.}
        \State ignore all messages except for (\textsc{check chain for closing})
        by \environment
        \State $\textit{State} \gets \textsc{closing}$
        \State send (\textsc{submit}, (\texttt{tx}, \texttt{sigs})) to \ledger
      \EndIndent
      \Statex

      \State On (\textsc{check chain for closing}) by $P \in \texttt{guests}$:
      \Indent
        \State ensure \textit{State} = \textsc{closing}
        \State send (\textsc{read}) to \ledger and assign reply to
        \texttt{chain}
        \If{$\texttt{tx} \in \texttt{chain}$}
          \State $\textit{State} \gets \textsc{closed}$
          \State output (\textsc{closed}) to $P$
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:close}
\end{figure}
