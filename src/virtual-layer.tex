\TODO{reselect \texttt{funder}, \texttt{fundee}, \texttt{guest} names}
\begin{center} % \captionof hinders page break if not in an environment
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State On every activation, before handling the message:
      \Indent
        \If{$\texttt{last\_poll} \neq \bot$} \Comment{virtual layer is ready}
          \State input (\textsc{read}) to \ledger and assign ouput to $\Sigma$
          \If{$\texttt{last\_poll} + p < |\Sigma|$}
            \For{$P \in \{\texttt{guest}, \texttt{funder}, \texttt{fundee}\}$}
            \Comment{at most 1 of \texttt{funder}, \texttt{fundee} is defined}
              \State ensure $P$.\textsc{negligent}() returns (\textsc{ok})
            \EndFor
          \EndIf
        \EndIf
      \EndIndent
      \Statex

      \State \Comment {\texttt{guest} is trusted to give sane inputs, therefore
      a state machine and input verification are redundant}
      \State On input (\textsc{init}, $\texttt{host}_P$, $\bar{P}$,
      \texttt{sibling}, \texttt{fundee}, ($\sk{\mathrm{loc}, \mathrm{fund},
      \mathrm{new}}$, $\pk{\mathrm{loc}, \mathrm{fund}, \mathrm{new}}$),
      $\pk{\mathrm{rem}, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{sib},
      \mathrm{rem}, \mathrm{fund}, \mathrm{new}}$, ($\sk{\mathrm{loc},
      \mathrm{fund}, \mathrm{old}}$, $\pk{\mathrm{loc}, \mathrm{fund},
      \mathrm{old}}$), $\pk{\mathrm{rem}, \mathrm{fund}, \mathrm{old}}$,
      $\pk{\mathrm{loc}, \mathrm{out}}$, $c_P$, $c_{\bar{P}}$,
      $c_{\mathrm{virt}}$, $i$, \texttt{side}, $n$) by \texttt{guest}:
      \Indent
        \State ensure $\texttt{side} \in \{\text{``left''},
        \text{``right''}\}$
        \State store message contents and \texttt{guest}
        \Comment{\texttt{sibling}, $\pk{\mathrm{sib}, \bar{P}, F}$ are missing
        for endpoints, \texttt{fundee} is present only in last node}
        \State $(\sk{i, \mathrm{fund}, \mathrm{new}}, \pk{i, \mathrm{fund},
        \mathrm{new}}) \gets (\sk{\mathrm{loc}, \mathrm{fund}, \mathrm{new}},
        \pk{\mathrm{loc}, \mathrm{fund}, \mathrm{new}})$
        \State $\pk{\texttt{myRem}, \mathrm{fund}, \mathrm{new}} \gets
        \pk{\mathrm{rem}, \mathrm{fund}, \mathrm{new}}$
        \If{$i < n$} \Comment{we are not last hop}
          \State $\pk{\texttt{sibRem}, \mathrm{fund}, \mathrm{new}} \gets
          \pk{\mathrm{sib}, \mathrm{rem}, \mathrm{fund}, \mathrm{new}}$
        \EndIf
        \If{$\texttt{side} = \text{``left''}$}
          \State $\texttt{side}' \gets \text{``right''}$; $\texttt{myRem}
          \gets i-1$; $\texttt{sibRem} \gets i+1$
        \Else \: \Comment{$\texttt{side} = \text{``right''}$}
          \State $\texttt{side}' \gets \text{``left''}$; $\texttt{myRem} \gets
          i+1$; $\texttt{sibRem} \gets i-1$
        \EndIf
        \State $(\sk{i, \texttt{side}, \mathrm{fund}, \mathrm{old}}, \pk{i,
        \texttt{side}, \mathrm{fund}, \mathrm{old}}) \gets (\sk{\mathrm{loc},
        \mathrm{fund}, \mathrm{old}}, \pk{\mathrm{loc}, \mathrm{fund},
        \mathrm{old}})$
        \State $\pk{\mathrm{myRem}, \texttt{side}', \mathrm{fund}, \mathrm{old}}
        \gets \pk{\mathrm{rem}, \mathrm{fund}, \mathrm{old}}$
        \State $\pk{i, \mathrm{out}} \gets \pk{\mathrm{loc}, \mathrm{out}}$
        \State $(c_{i, \texttt{side}}, c_{\texttt{myRem}, \texttt{side}'}) \gets
        (c_P, c_{\bar{P}})$
        \State $\texttt{last\_poll} \gets \bot$
        \If{$\texttt{side} = \text{``left''} \wedge i \neq n$}
          \State $(\sk{i, j, k}, \pk{i, j, k})_{j \in \{2, \dots, n-1\}, k \in
          [n] \setminus \{j\}} \gets \textsc{keyGen}()^{(n-2)(n-1)}$
        \EndIf
        \State output (\textsc{host init ok}) to \texttt{guest}
      \EndIndent
      \Statex

      \State On input (\textsc{host me}, \texttt{funder}, \texttt{fundee},
      $\bar{P}$, $\texttt{host}_P$, $c_{1, \mathrm{right}}$, $c_{2,
      \mathrm{left}}$, $c_{\mathrm{virt}}$, $\pk{\mathrm{left},
      \mathrm{guest}}$, $\pk{\mathrm{right}, \mathrm{guest}}$, ($\sk{1,
      \mathrm{fund}, \mathrm{new}}$, $\pk{1, \mathrm{fund}, \mathrm{new}}$),
      ($\sk{1, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{1,
      \mathrm{right}, \mathrm{fund}, \mathrm{old}}$), $\pk{2, \mathrm{left},
      \mathrm{fund}, \mathrm{old}}$, $\pk{2, \mathrm{left}, \mathrm{fund},
      \mathrm{new}}$, $\pk{1, \mathrm{right}, \mathrm{out}}$, $n$) by
      \texttt{guest}:
      \Indent
        \State $\texttt{last\_poll} \gets \bot$
        \State $i \gets 1$
        \State $(\sk{1, j, k}, \pk{1, j, k})_{j \in \{2, \dots, n-1\}, k \in [n]
        \setminus \{j\}} \gets \textsc{keyGen}()^{(n-2)(n-1)}$
        \State ensure \textsc{virt.circulateKeysCoinsTimes}() returns
        (\textsc{ok})
        \State ensure \textsc{virt.circulateVirtualSigs}() returns (\textsc{ok})
        \State ensure \textsc{virt.circulateFundingSigs}() returns (\textsc{ok})
        \State ensure \textsc{virt.circulateRevocations}() returns (\textsc{ok})
        \State output (\textsc{hosts ready}) to \texttt{guest}
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:keys}
\end{center}

\begin{center}
  \begin{processbox}{\textsc{virt}.\textsc{circulateKeysCoinsTimes}(\texttt{left\_data}):}
    \begin{algorithmic}[1]
      \If{\texttt{left\_data} is given as argument} \Comment{we are not
      \texttt{host\_funder}}
        \State parse \texttt{left\_data} as ($(\pk{j, \mathrm{fund},
        \mathrm{new}})_{j \in [i-1]}$, $(\pk{j, \mathrm{left}, \mathrm{fund},
        \mathrm{old}})_{j \in \{2, \dots, i-1\}}$, $(\pk{j, \mathrm{right},
        \mathrm{fund}, \mathrm{old}})_{j \in [i-1]}$, $(\pk{j, \mathrm{out}})_{j
        \in [i-1]}$, $(c_{j, \mathrm{left}})_{j \in \{2, \dots, i-1\}}$, $(c_{j,
        \mathrm{right}})_{j \in [i-1]}$, $(t_j)_{j \in [i-1]}$,
        $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right},
        \mathrm{virt}}$, $(\pk{h, j, k})_{h \in [i-1], j \in \{2, \dots, n-1\},
        k \in [n] \setminus \{j\}}$)
        \If{we have a \texttt{sibling}} \Comment{we are not
        \texttt{host\_fundee}}
          \State input (\textsc{keys and coins forward}, (\texttt{left\_data},
          ($\sk{i, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{i,
          \mathrm{left}, \mathrm{fund}, \mathrm{old}}$), $c_{i, \mathrm{left}}$,
          $t_{i, \mathrm{left}}$, $(\sk{i, j, k}, \pk{i, j, k})_{j \in \{2,
          \dots, n-1\}, k \in [n] \setminus \{j\}}$) to \texttt{sibling}
          \State \trustedcode{store input as \texttt{left\_data} and parse it as
          ($(\pk{j, \mathrm{fund}, \mathrm{new}})_{j \in [i-1]}$, $(\pk{j,
          \mathrm{left}, \mathrm{fund}, \mathrm{old}})_{j \in \{2, \dots, i\}}$,
          $(\pk{j, \mathrm{right}, \mathrm{fund}, \mathrm{old}})_{j \in [i-1]}$,
          $(\pk{j, \mathrm{out}})_{j \in [i-1]}$, $(c_{j, \mathrm{left}})_{j \in
          \{2, \dots, i\}}$, $(c_{j, \mathrm{right}})_{j \in [i-1]}$, $(t_j)_{j
          \in [i-1]}$, $\sk{i, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
          $t_{i, \mathrm{left}}$, $\pk{\mathrm{left}, \mathrm{virt}}$,
          $\pk{\mathrm{right}, \mathrm{virt}}$, $(\pk{h, j, k})_{h \in [i], j
          \in \{2, \dots, n-1\}, k \in [n] \setminus \{j\}}$, $(\sk{i, j, k})_{j
          \in \{2, \dots, n-1\}, k \in [n] \setminus \{j\}}$}
          \State \trustedcode{$t_i \gets \max{(t_{i, \mathrm{left}}, t_{i,
          \mathrm{right}})}$}
          \State \trustedcode{replace $t_{i, \mathrm{left}}$ in
          \texttt{left\_data} with $t_i$}
          \State \trustedcode{remove $\sk{i, \mathrm{left}, \mathrm{fund},
          \mathrm{old}}$ and $(\sk{i, j, k})_{j \in \{2, \dots, n-1\}, k \in [n]
          \setminus \{j\}}$ from \texttt{left\_data}}
          \State \trustedcode{call
          \textsc{virt.circulateKeysCoinsTimes}(\texttt{left\_data}) of
          $\bar{P}$ and assign returned value to \texttt{right\_data}}
          \State \trustedcode{parse \texttt{right\_data} as ($(\pk{j,
          \mathrm{fund}, \mathrm{new}})_{j\in \{i+1, \dots, n\}}$, $(\pk{j,
          \mathrm{left}, \mathrm{fund}, \mathrm{old}})_{j \in \{i+1, \dots,
          n\}}$, $(\pk{j, \mathrm{right}, \mathrm{fund}, \mathrm{old}})_{j \in
          \{i+1, \dots, n-1\}}$, $(\pk{j, \mathrm{out}})_{j \in \{i+1, \dots,
          n\}}$, $(c_{j, \mathrm{left}})_{j \in \{i+1, \dots, n\}}$, $(c_{j,
          \mathrm{right}})_{j \in \{i+1, \dots, n-1\}}$, $(t_j)_{j \in \{i+1,
          \dots, n\}}$, $(\pk{h, j, k})_{h \in \{i+1, \dots, n\}, j
          \in \{2, \dots, n-1\}, k \in [n] \setminus \{j\}}$}
          \State \trustedcode{output (\textsc{keys and coins back},
          \texttt{right\_data}, ($\sk{i, \mathrm{right}, \mathrm{fund},
          \mathrm{old}}$, $\pk{i, \mathrm{right}, \mathrm{fund},
          \mathrm{old}})$, $c_{i, \mathrm{right}}$, $t_i$)}
          \State store output as \texttt{right\_data} and parse it as ($(\pk{j,
          \mathrm{fund}, \mathrm{new}})_{j \in \{i+1, \dots, n\}}$, $(\pk{j,
          \mathrm{left}, \mathrm{fund}, \mathrm{old}})_{j \in \{i+1, \dots,
          n\}}$, $(\pk{j, \mathrm{right}, \mathrm{fund}, \mathrm{old}})_{j \in
          \{i, \dots, n-1\}}$, $(\pk{j, \mathrm{out}})_{j \in \{i+1, \dots,
          n\}}$, $(c_{j, \mathrm{left}})_{j \in \{i+1, \dots, n\}}$, $(c_{j,
          \mathrm{right}})_{j \in \{i, \dots, n-1\}}$, $(t_j)_{j \in \{i, \dots,
          n\}}$, $(\pk{h, j, k})_{h \in \{i+1, \dots, n\}, j \in \{2, \dots,
          n-1\}, k \in [n] \setminus \{j\}}$, $\sk{i, \mathrm{right},
          \mathrm{fund}, \mathrm{old}}$)
          \State remove $\sk{i, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$
          from \texttt{right\_data}
          \State \Return (\texttt{right\_data}, $\pk{i, \mathrm{fund},
          \mathrm{new}}$, $\pk{i, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
          $\pk{i, \mathrm{out}}$, $c_{i, \mathrm{left}}$)
        \Else \: \Comment{we are \texttt{host\_fundee}}
          \State output (\textsc{check keys}, ($\pk{\mathrm{left},
          \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$)) to
          \texttt{fundee} and expect reply (\textsc{keys ok})
          \State \Return ($\pk{n, \mathrm{fund}, \mathrm{new}}$, $\pk{n,
          \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{n, \mathrm{out}}$,
          $c_{n, \mathrm{left}}$, $t_n$)
        \EndIf
      \Else \: \Comment{we are \texttt{host\_funder}}
        \State call \textsc{virt.circulateKeysCoinsTimes}($\pk{1, \mathrm{fund},
        \mathrm{new}}$, $\pk{1, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$,
        $\pk{1, \mathrm{out}}$, $c_{1, \mathrm{right}}$, $t_1$,
        $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right},
        \mathrm{virt}}$, $(\pk{1, j, k})_{j \in \{2, \dots, n-1\}, k \in [n]
        \setminus \{j\}}$) of $\bar{P}$ and assign returned value to
        \texttt{right\_data}
        \State parse \texttt{right\_data} as ($(\pk{j, \mathrm{fund},
        \mathrm{new}})_{j \in \{2, \dots, n\}}$, $(\pk{j, \mathrm{left},
        \mathrm{fund}, \mathrm{old}})_{j \in \{2, \dots, n\}}$, $(\pk{j,
        \mathrm{right}, \mathrm{fund}, \mathrm{old}})_{j \in \{2, \dots,
        n-1\}}$, $(\pk{j, \mathrm{out}})_{j \in \{2, \dots, n\}}$, $(c_{j,
        \mathrm{left}})_{j \in \{2, \dots, n\}}$, $(c_{j, \mathrm{right}})_{j
        \in \{2, \dots, n-1\}}$, $(t_j)_{j \in \{2, \dots, n\}}$, $(\pk{h, j,
        k})_{h \in \{2, \dots, n\}, j \in \{2, \dots, n-1\}, k \in [n] \setminus
        \{j\}}$)
        \State \Return (\textsc{ok})
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:circulate-keys-and-coins}
\end{center}

\begin{center}
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State \TODO{change all \textsc{getMidTXs}() uses to fit new input/output}
      \State \textsc{getMidTXs}($i$, $n$, $c_{\mathrm{virt}}$, $c_{\mathrm{rem},
      \mathrm{left}}$, $c_{\mathrm{loc}, \mathrm{left}}$, $c_{\mathrm{loc},
      \mathrm{right}}$, $c_{\mathrm{rem}, \mathrm{right}}$, $\pk{\mathrm{rem},
      \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{\mathrm{loc},
      \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{\mathrm{loc},
      \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{\mathrm{rem},
      \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{\mathrm{rem},
      \mathrm{left}, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{loc},
      \mathrm{left}, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{loc},
      \mathrm{right}, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{rem},
      \mathrm{right}, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{left},
      \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$, $\pk{\mathrm{loc},
      \mathrm{out}}$, $(\pk{p,j,k})_{p \in [n], j \in [n-1] \setminus \{1\}, k
      \in [n-1] \setminus \{1, j\}}$, $(\pk{p, 2, 1})_{p \in [n]}$, $(\pk{p,
      n-1, n})_{p \in [n]}$, $(t_j)_{j \in [n-1] \setminus \{1\}}$):
      \Indent
        \State ensure $1 < i < n$
        \State ensure $c_{\mathrm{rem}, \mathrm{left}} \geq c_{\mathrm{virt}}
        \wedge c_{\mathrm{loc}, \mathrm{left}} \geq c_{\mathrm{virt}}$
        \Comment{left parties fund virtual channel}
        \State ensure $c_{\mathrm{rem}, \mathrm{left}} \geq c_{\mathrm{loc},
        \mathrm{right}} \wedge c_{\mathrm{rem}, \mathrm{right}} \geq
        c_{\mathrm{loc}, \mathrm{left}}$ \Comment{avoid griefing attack}
        \State $c_{\mathrm{left}} \gets c_{\mathrm{rem}, \mathrm{left}} +
        c_{\mathrm{loc}, \mathrm{left}}$; $c_{\mathrm{right}} \gets
        c_{\mathrm{loc}, \mathrm{right}} + c_{\mathrm{rem}, \mathrm{right}}$
        \State $\texttt{left\_old\_fund} \gets 2/\{\pk{\mathrm{rem},
        \mathrm{left}, \mathrm{fund}, \mathrm{old}}, \pk{\mathrm{loc},
        \mathrm{left}, \mathrm{fund}, \mathrm{old}}\}$
        \State $\texttt{right\_old\_fund} \gets 2/\{\pk{\mathrm{loc},
        \mathrm{right}, \mathrm{fund}, \mathrm{old}}, \pk{\mathrm{rem},
        \mathrm{right}, \mathrm{fund}, \mathrm{old}}\}$
        \State $\texttt{left\_new\_fund} \gets 2/\{\pk{\mathrm{rem},
        \mathrm{left}, \mathrm{fund}, \mathrm{new}}, \pk{\mathrm{loc},
        \mathrm{left}, \mathrm{fund}, \mathrm{new}}\}$
        \State $\texttt{right\_new\_fund} \gets 2/\{\pk{\mathrm{loc},
        \mathrm{right}, \mathrm{fund}, \mathrm{new}}, \pk{\mathrm{rem},
        \mathrm{right}, \mathrm{fund}, \mathrm{new}}\}$
        \State $\texttt{virt\_fund} \gets 2/\{\pk{\mathrm{left}, \mathrm{virt}},
        \pk{\mathrm{right}, \mathrm{virt}}\}$

        \ForAll{$j \in [n-1] \setminus \{1\}, k \in [n-1] \setminus \{1, j\}$}
          \State $\mathit{all}_{j, k} \gets n/\{\pk{1, j, k}, \dots,
          \pk{n, j, k}\} \wedge \texttt{"}k\texttt{"}$
        \EndFor
        \If{$i = 2$}
          \State $\mathit{all}_{2, 1} \gets n/\{\pk{1, 2, 1}, \dots, \pk{n, 2,
          1}\} \wedge \texttt{"1"}$
        \EndIf
        \If{$i = n-1$}
          \State $\mathit{all}_{n-1, n} \gets n/\{\pk{1, n-1, n}, \dots, \pk{n,
          n-1, n}\} \wedge \texttt{"}n\texttt{"}$
        \EndIf
        \State \Comment{After funding is complete, $A_j$ has the signature of
        all other parties for all $\mathit{all}_{j, k}$ inputs, but other
        parties do not have $A_j$'s signature for this input, therefore only
        $A_j$ can publish it.}
        \State \Comment{$\mathrm{TX}_{i, j, k} :=$ $i$-th move, $j, k$ input
        interval start and end. $j, k$ unneeded for $i = 1$, $k$ unneeded for $i
        = 2$.}
        \State $\mathrm{TX}_1 \gets \mathrm{TX}$:
        \Indent
          \State inputs:
          \Indent
            \State ($c_{\mathrm{left}}$, \texttt{left\_old\_fund}),
            \State ($c_{\mathrm{right}}$, \texttt{right\_old\_fund})
          \EndIndent
          \State outputs:
          \Indent
            \State ($c_{\mathrm{left}} - c_{\mathrm{virt}}$,
            \texttt{left\_new\_fund}),
            \State ($c_{\mathrm{right}} - c_{\mathrm{virt}}$,
            \texttt{right\_new\_fund}),
            \State ($c_{\mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{out}}$),
            \State ($c_{\mathrm{virt}}$,
            \Indent
              \State (if $(i-1 > 1)$ then $\mathit{all}_{i-1, i}$ else False)
              \State $\vee$ (if $(i+1 < n)$ then $\mathit{all}_{i+1, i}$ else
              False)
              \State $\vee$ (
              \Indent
                \State if $(i-1 = 1 \wedge i+1 = n)$ then \texttt{virt\_fund}
                \State else if $(i-1 > 1 \wedge i+1 = n)$ then
                $\texttt{virt\_fund} + t_{i-1}$
                \State else if $(i-1 = 1 \wedge i+1 < n)$ then
                $\texttt{virt\_fund} + t_{i+1}$
                \State else \StarComment{$i-1 > 1 \wedge i+1 < n$}
                $\texttt{virt\_fund} + \max{(t_{i-1}, t_{i+1})}$
              \EndIndent
              \State )
            \EndIndent
            \State )
          \EndIndent
        \EndIndent

        \If{$i = 2$}
          \State $\mathrm{TX}_{2, 1} \gets \mathrm{TX}$:
          \Indent
            \State inputs:
            \Indent
              \State ($c_{\mathrm{virt}}$, $\mathit{all}_{2, 1}$),
              \State ($c_{\mathrm{right}}$, \texttt{right\_old\_fund})
            \EndIndent
            \State outputs:
            \Indent
              \State ($c_{\mathrm{right}} - c_{\mathrm{virt}}$,
              \texttt{right\_new\_fund}),
              \State ($c_{\mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{out}}$),
              \State ($c_{\mathrm{virt}}$,
              \Indent
                \State if $(n > 3)$ then $(\mathit{all}_{3, 2}
                \vee (\texttt{virt\_fund} + t_3))$
                \State else \texttt{virt\_fund}
              \EndIndent
              \State )
            \EndIndent
          \EndIndent
        \EndIf

        \If{$i = n-1$}
          \State $\mathrm{TX}_{2, n} \gets \mathrm{TX}$:
          \Indent
            \State inputs:
            \Indent
              \State ($c_{\mathrm{left}}$, \texttt{left\_old\_fund}),
              \State ($c_{\mathrm{virt}}$, $\mathit{all}_{n-1, n}$)
            \EndIndent
            \State outputs:
            \Indent
              \State ($c_{\mathrm{left}} - c_{\mathrm{virt}}$,
              \texttt{left\_new\_fund}),
              \State ($c_{\mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{out}}$),
              \State ($c_{\mathrm{virt}}$,
              \Indent
                \State if $(n-2 > 1)$ then $(\mathit{all}_{n-2, n-1} \vee
                (\texttt{virt\_fund} + t_{n-2}))$
                \State else \texttt{virt\_fund}
              \EndIndent
              \State )
            \EndIndent
          \EndIndent
        \EndIf

        \ForAll{$k \in \{2, \dots, i-1\}$} \Comment{$i-2$ txs}
          \State $\mathrm{TX}_{2, k} \gets \mathrm{TX}$:
          \Indent
            \State inputs:
            \Indent
              \State ($c_{\mathrm{virt}}$, $\mathit{all}_{i, k}$),
              \State ($c_{\mathrm{right}}$, \texttt{right\_old\_fund})
            \EndIndent
            \State outputs:
            \Indent
              \State ($c_{\mathrm{right}} - c_{\mathrm{virt}}$,
              \texttt{right\_new\_fund}),
              \State ($c_{\mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{out}}$),
              \State ($c_{\mathrm{virt}}$,
              \Indent
                \State (if $(k-1 > 1)$ then $\mathit{all}_{k-1, i}$ else False)
                \State $\vee$ (if $(i+1 < n)$ then $\mathit{all}_{i+1, k}$ else
                False)
                \State $\vee$ (
                \Indent
                  \State if $(k-1 = 1 \wedge i+1 = n)$ then \texttt{virt\_fund}
                  \State else if $(k-1 > 1 \wedge i+1 = n)$ then
                  $\texttt{virt\_fund} + t_{k-1}$
                  \State else if $(k-1 = 1 \wedge i+1 < n)$ then
                  $\texttt{virt\_fund} + t_{i+1}$
                  \State else \StarComment{$k-1 > 1 \wedge i+1 < n$}
                  $\texttt{virt\_fund} + \max{(t_{k-1}, t_{i+1})}$
                \EndIndent
                \State )
              \EndIndent
              \State )
            \EndIndent
          \EndIndent
        \EndFor

        \ForAll{$k \in \{i+1, \dots, n-1\}$} \Comment{$n-i-1$ txs}
          \State $\mathrm{TX}_{2, k} \gets \mathrm{TX}$:
          \Indent
            \State inputs:
            \Indent
              \State ($c_{\mathrm{left}}$, \texttt{left\_old\_fund})
              \State ($c_{\mathrm{virt}}$, $\mathit{all}_{i, k}$),
            \EndIndent
            \State outputs:
            \Indent
              \State ($c_{\mathrm{left}} - c_{\mathrm{virt}}$,
              \texttt{left\_new\_fund}),
              \State ($c_{\mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{out}}$),
              \State ($c_{\mathrm{virt}}$,
              \Indent
                \State (if $(i-1 > 1)$ then $\mathit{all}_{i-1, k}$ else False)
                \State $\vee$ (if $(k+1 < n)$ then $\mathit{all}_{k+1, i}$ else
                False)
                \State $\vee$ (
                \Indent
                  \State if $(i-1 = 1 \wedge k+1 = n)$ then \texttt{virt\_fund}
                  \State else if $(i-1 > 1 \wedge k+1 = n)$ then
                  $\texttt{virt\_fund} + t_{i-1}$
                  \State else if $(i-1 = 1 \wedge k+1 < n)$ then
                  $\texttt{virt\_fund} + t_{k+1}$
                  \State else \StarComment{$i-1 > 1 \wedge k+1 < n$}
                  $\texttt{virt\_fund} + \max{(t_{i-1}, t_{k+1})}$
                \EndIndent
                \State )
              \EndIndent
              \State )
            \EndIndent
          \EndIndent
        \EndFor

        \IfThenElse{$i = 2$}{$m \gets 1$}{$m \gets 2$}
        \IfThenElse{$i = n-1$}{$l \gets n$}{$l \gets n-1$}
        \ForAll{$(k_1, k_2) \in \{m, \dots, i-1\} \times \{i+1, \dots, l\}$}
        \Comment{$(i-m) \cdot (l-i)$ txs}
          \State $\mathrm{TX}_{3, k_1, k_2} \gets \mathrm{TX}$:
          \Indent
            \State inputs:
            \Indent
              \State ($c_{\mathrm{virt}}$, $\mathit{all}_{i, k_1}$),
              \State ($c_{\mathrm{virt}}$, $\mathit{all}_{i, k_2}$)
            \EndIndent
            \State outputs:
            \Indent
              \State ($c_{\mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{out}}$),
              \State ($c_{\mathrm{virt}}$,
              \Indent
                \State (if $(k_1-1 > 1)$ then $\mathit{all}_{k_1-1, \min{(k_2,
                n-1)}}$ else False)
                \State $\vee$ (if $(k_2+1 < n)$ then $\mathit{all}_{k_2+1,
                \max{(k_1, 2)}}$ else False)
                \State $\vee$ (
                \Indent
                  \State if $(k_1-1 \leq 1 \wedge k_2+1 \geq n)$ then
                  \texttt{virt\_fund}
                  \State else if $(k_1-1 > 1 \wedge k_2+1 \geq n)$ then
                  $\texttt{virt\_fund} + t_{k_1-1}$
                  \State else if $(k_1-1 \leq 1 \wedge k_2+1 < n)$ then
                  $\texttt{virt\_fund} + t_{k_2+1}$
                  \State else \StarComment{$k_1-1 > 1 \wedge k_2+1 < n$}
                  \Indent
                    \State $\texttt{virt\_fund} + \max{(t_{k_1-1}, t_{k_2+1})}$
                  \EndIndent
                \EndIndent
                \State )
              \EndIndent
              \State )
            \EndIndent
          \EndIndent
        \EndFor

        \State \Return (
        \Indent
          \State $\mathrm{TX}_1$,
          \State $(\mathrm{TX}_{2, k})_{k \in \{m, \dots, l\} \setminus \{i\}}$,
          \State $(\mathrm{TX}_{3, k_1, k_2})_{(k_1, k_2) \in \{m, \dots, i-1\}
          \times \{i+1, \dots, l\}}$
        \EndIndent
        \State )
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:mid-txs}
\end{center}

\begin{center}
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State \Comment{left and right refer to the two counterparties, with left
      being the one closer to the funder. Note difference with left/right
      meaning in \textsc{virt.getMidTXs}.}
      \State \textsc{getEndpointTX}($i$, $n$, $c_{\mathrm{virt}}$,
      $c_{\mathrm{left}}$, $c_{\mathrm{right}}$, $\pk{\mathrm{left},
      \mathrm{fund}, \mathrm{old}}$, $\pk{\mathrm{right}, \mathrm{fund},
      \mathrm{old}}$, $\pk{\mathrm{left}, \mathrm{fund}, \mathrm{new}}$,
      $\pk{\mathrm{right}, \mathrm{fund}, \mathrm{new}}$ $\pk{\mathrm{left},
      \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$, $(\pk{\mathrm{all},
      j})_{j \in [n]}$, $t$):
      \Indent
        \State ensure $c_{\mathrm{left}} \geq c_{\mathrm{virt}}$ \Comment{left
        party funds virtual channel}
        \State $c_{\mathrm{tot}} \gets c_{\mathrm{left}} + c_{\mathrm{right}}$
        \State $\texttt{old\_fund} \gets 2/\{\pk{\mathrm{left}, \mathrm{fund},
        \mathrm{old}}, \pk{\mathrm{right}, \mathrm{fund}, \mathrm{old}}\}$
        \State $\texttt{new\_fund} \gets 2/\{\pk{\mathrm{left}, \mathrm{fund},
        \mathrm{new}}, \pk{\mathrm{right}, \mathrm{fund}, \mathrm{new}}\}$
        \State $\texttt{virt\_fund} \gets 2/\{\pk{\mathrm{left},
        \mathrm{virt}}, \pk{\mathrm{right}, \mathrm{virt}}\}$
        \If{$i = 1$} \Comment{funder's tx}
          \State $\mathit{all} \gets n/\{\pk{\mathrm{all}, 1}, \dots,
          \pk{\mathrm{all}, n}\} \wedge \texttt{"1"}$
        \Else \: \Comment{fundee's tx}
          \State $\mathit{all} \gets n/\{\pk{\mathrm{all}, 1}, \dots,
          \pk{\mathrm{all}, n}\} \wedge \texttt{"}n\texttt{"}$
        \EndIf
        \State $\mathrm{TX}_1 \gets \mathrm{TX}$: \Comment{endpoints only have
        an ``initiator'' tx}
        \Indent
          \State inputs:
          \Indent
            \State $(c_{\mathrm{tot}}, \texttt{old\_fund})$
          \EndIndent
          \State outputs:
          \Indent
            \State $(c_{\mathrm{tot}} - c_{\mathrm{virt}}, \texttt{new\_fund})$,
            \State $(c_{\mathrm{virt}}, \mathit{all} \vee (\texttt{virt\_fund} +
            t))$
          \EndIndent
        \EndIndent
        \State \Return $\mathrm{TX}_1$
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:endpoint-txs}
\end{center}

\begin{center}
  \begin{processbox}{\textsc{virt.siblingSigs}()}
    \begin{algorithmic}[1]
      \State parse input as $\mathrm{sigs}_{\mathrm{byLeft}}$
      \IfThenElse{$i = 2$}{$m \gets 1$}{$m \gets 2$}
      \IfThenElse{$i = n-1$}{$l \gets n$}{$l \gets n-1$}
      \State ($\mathrm{TX}_{i, 1}$, $(\mathrm{TX}_{i, 2, k})_{k \in \{m, \dots,
      l\} \setminus \{i\}}$, $(\mathrm{TX}_{i, 3, k_1, k_2})_{(k_1, k_2) \in
      \{m, \dots, i-1\} \{i+1, \dots, l\}}$) $\gets$
      \textsc{virt.getMidTXs}($i$, $n$, $c_{\mathrm{virt}}$, $c_{i-1,
      \mathrm{right}}$, $c_{i, \mathrm{left}}$, $c_{i, \mathrm{right}}$,
      $c_{i+1, \mathrm{left}}$, $\pk{i-1, \mathrm{right}, \mathrm{fund},
      \mathrm{old}}$, $\pk{i, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
      $\pk{i, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{i+1,
      \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{i-1, \mathrm{fund},
      \mathrm{new}}$, $\pk{i, \mathrm{fund}, \mathrm{new}}$, $\pk{i,
      \mathrm{fund}, \mathrm{new}}$, $\pk{i+1, \mathrm{fund}, \mathrm{new}}$,
      $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$,
      $\pk{i, \mathrm{out}}$, $(\pk{i,j,k})_{i \in [n], j \in [n-1] \setminus
      \{1\}, k \in [n-1] \setminus \{1, j\}}$, $(\pk{i, 2, 1})_{i \in [n]}$,
      $(\pk{i, n-1, n})_{i \in [n]}$, $(t_i)_{i \in [n-1] \setminus \{1\}}$)
      \Statex
      \State \Comment{notation: $\mathrm{sig}(\mathrm{TX}, \pk{}) :=$ sig with
      \texttt{ANYPREVOUT} flag such that $\textsc{verify}(\mathrm{TX},
      \mathrm{sig}, \pk{}) =$ True}
      \State ensure that the following signatures are present in
      $\mathrm{sigs}_{\mathrm{byLeft}}$ and store them:
      \begin{itemize}
        \item \Comment{$(l-m) \cdot (i-1)$ signatures}
      \end{itemize}
      \Indent
        \State $\forall k \in \{m, \dots, l\} \setminus \{i\}, \forall j \in
        [i-1]:$
        \Indent
          \State sig($\mathrm{TX}_{i, 2, k}, \pk{j, i, k}$)
        \EndIndent
      \EndIndent
      \begin{itemize}
        \item \Comment{$2 \cdot (i-m) \cdot (l-i) \cdot
        (i-1)$ signatures}
      \end{itemize}
      \Indent
        \State $\forall k_1 \in \{m, \dots, i-1\}, \forall k_2 \in \{i+1, \dots,
        l\}, \forall j \in [i-1]:$
        \Indent
          \State sig($\mathrm{TX}_{i, 3, k_1, k_2}, \pk{j, i, k_1}$),
          sig($\mathrm{TX}_{i, 3, k_1, k_2}, \pk{j, i, k_2}$)
        \EndIndent
      \EndIndent
      \State $\mathrm{sigs}_{\mathrm{toRight}} \gets
      \mathrm{sigs}_{\mathrm{byLeft}}$
      \Statex
      \ForAll{$j \in [2, \dots, n-1] \setminus \{i\}$}
        \State ($\mathrm{TX}_{j, 1}$, $(\mathrm{TX}_{j, 2, k})_{k \in \{m,
        \dots, l\} \setminus \{i\}}$, $(\mathrm{TX}_{j, 3, k_1, k_2})_{(k_1,
        k_2) \in \{m, \dots, i-1\} \{i+1, \dots, l\}}$) $\gets$
        \textsc{getMidTXs}($j$, $n$, $c_{\mathrm{virt}}$, $c_{j-1,
        \mathrm{right}}$, $c_{j, \mathrm{left}}$, $c_{j, \mathrm{right}}$,
        $c_{j+1, \mathrm{left}}$, $\pk{j-1, \mathrm{right}, \mathrm{fund},
        \mathrm{old}}$, $\pk{j, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
        $\pk{j, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{j+1,
        \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{j-1, \mathrm{fund},
        \mathrm{new}}$, $\pk{j, \mathrm{fund}, \mathrm{new}}$, $\pk{j,
        \mathrm{fund}, \mathrm{new}}$, $\pk{j+1, \mathrm{fund}, \mathrm{new}}$,
        $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right},
        \mathrm{virt}}$, $\pk{j, \mathrm{out}}$, $(\pk{k, p,
        s})_{k \in [n], p \in [n-1] \setminus \{1\}, s \in [n-1] \setminus \{1,
        p\}}$, $(\pk{k, 2, 1})_{k \in [n]}$, $(\pk{k, n-1, n})_{k \in [n]}$,
        $(t_k)_{k \in [n-1] \setminus \{1\}}$)
        \IfThenElse{$j < i$}{$\mathrm{sigs} \gets
        \mathrm{sigs}_{\mathrm{toLeft}}$}{$\mathrm{sigs} \gets
        \mathrm{sigs}_{\mathrm{toRight}}$}
        \ForAll{$k \in \{m, \dots, l\} \setminus \{i\}$}
          \State add \textsc{sign}($\mathrm{TX}_{j, 2, k}$, $\sk{i, j, k}$,
          \texttt{ANYPREVOUT}) to sigs
        \EndFor
        \ForAll{$k_1 \in \{m, \dots, i-1\}, k_2 \in \{i+1, \dots, l\}$}
          \State add \textsc{sign}($\mathrm{TX}_{j, 3, k_1, k_2}$, $\sk{i, j,
          k_1}$, \texttt{ANYPREVOUT}) to sigs
          \State add \textsc{sign}($\mathrm{TX}_{j, 3, k_1, k_2}$, $\sk{i, j,
          k_2}$, \texttt{ANYPREVOUT}) to sigs
        \EndFor
      \EndFor
      \If{$i+1 = n$} \Comment{next hop is \texttt{host\_fundee}}
        \State $\mathrm{TX}_{n, 1}$ $\gets$ \textsc{virt.getEndpointTX}($n$, $n$,
        $c_{\mathrm{virt}}$, $c_{i, \mathrm{right}}$, $c_n$, $\pk{i,
        \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{n, \mathrm{fund},
        \mathrm{old}}$, $\pk{i, \mathrm{right}, \mathrm{fund}, \mathrm{new}}$,
        $\pk{n, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{left},
        \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$, $(\pk{j, i, n})_{j
        \in [n]}$, $t_n$)
      \EndIf
      \Statex
      \State call
      $\bar{P}$.\textsc{circulateVirtualSigs}($\mathrm{sigs}_{\mathrm{toRight}}$)
      and assign returned value to $\mathrm{sigs}_{\mathrm{byRight}}$
      \State ensure that the following signatures are present in
      $\mathrm{sigs}_{\mathrm{byRight}}$ and store them:
      \begin{itemize}
        \item \Comment{$(l-m) \cdot (n-i)$ signatures}
      \end{itemize}
      \Indent
        \State $\forall k \in \{m, \dots, l\} \setminus \{i\}, \forall j \in
        \{i+1, \dots, n\}:$
        \Indent
          \State sig($\mathrm{TX}_{2, k}, \pk{j, i, k}$)
        \EndIndent
      \EndIndent
      \begin{itemize}
        \item \Comment{$2 \cdot (i-m) \cdot (l-i) \cdot
        (n-i)$ signatures}
      \end{itemize}
      \Indent
        \State $\forall k_1 \in \{m, \dots, i-1\}, \forall k_2 \in \{i+1, \dots,
        l\}, \forall j \in \{i+1, \dots, n\}:$
        \Indent
          \State sig($\mathrm{TX}_{3, k_1, k_2}, \pk{j, i, k_1}$),
          sig($\mathrm{TX}_{3, k_1, k_2}, \pk{j, i, k_2}$)
        \EndIndent
      \EndIndent
      \State output (\textsc{virtualSigsBack},
      $\mathrm{sigs}_{\mathrm{toLeft}}$, $\mathrm{sigs}_{\mathrm{byRight}}$)
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:sibling-sigs}
\end{center}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.intermediarySigs}()}
    \begin{algorithmic}[1]
      \State ($\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$,
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{left}}$, $\mathrm{TX}_{\mathrm{loc},
      \mathrm{right}}$, $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$) $\gets$
      \textsc{virt.getMidTXs}($c_{\mathrm{guest}}$, $c_P$, $c_{\bar{P}}$,
      $c_{\mathrm{sib}}$, $c_{\mathrm{sib}, \mathrm{rem}}$, $\pk{\mathrm{loc},
      F}$, $\pk{\mathrm{rem}, F}$, $\pk{\mathrm{sib}, F}$, $\pk{\mathrm{sib},
      \mathrm{rem}, F}$, $\pk{\mathrm{rem}, \mathrm{virt}}$, $\pk{\mathrm{loc},
      \mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{virt}}$, $\pk{\mathrm{sib},
      \mathrm{rem}, \mathrm{virt}}$, $\pk{\mathrm{left}, \mathrm{guest}}$,
      $\pk{\mathrm{right}, \mathrm{guest}}$, $\pk{\mathrm{loc}, \mathrm{out}}$,
      $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$)
      \State \Comment{not verifying our signatures in
      $\mathrm{sigs}_{\mathrm{byLeft}}$, our (trusted) \texttt{sibling} will do
      that}
      \State input (\textsc{virtual sigs forward},
      $\mathrm{sigs}_{\mathrm{byLeft}}$) to \texttt{sibling}
      \State \trustedcode{\textsc{virt.siblingSigs}()}
      \State $\mathrm{sigs}_{\mathrm{toLeft}} \gets
      \mathrm{sigs}_{\mathrm{byRight}} + \mathrm{sigs}_{\mathrm{toLeft}}$
      \If{\texttt{left\_data} does not contain data from a second-previous hop}
      \Comment{previous hop is \texttt{host\_funder}}
        \State $\mathrm{TX}_{\mathrm{prev}, \mathrm{none}}$ $\gets$
        \textsc{virt.getEndpointTX}($c_{\mathrm{guest}}$, $c_{\bar{P}}$, $c_P$,
        $\pk{\mathrm{rem}, F}$, $\pk{\mathrm{loc}, F}$, $\pk{\mathrm{rem},
        \mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{virt}}$, $\pk{\mathrm{loc},
        \mathrm{virt}}$, $\pk{\mathrm{left}, \mathrm{guest}}$,
        $\pk{\mathrm{right}, \mathrm{guest}}$, $\{\pk{\mathrm{sec}, i}\}_{1
        \dots n}$, True)
      \EndIf
      \State \Return $\mathrm{sigs}_{\mathrm{toLeft}}$
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:intermediary-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.hostFundeeSigs}()}
    \begin{algorithmic}[1]
      \State $\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$ $\gets$
      \textsc{virt.getEndpointTX}($c_{\mathrm{guest}}$, $c_P$, $c_{\bar{P}}$,
      $\pk{\mathrm{loc}, F}$, $\pk{\mathrm{rem}, F}$, $\pk{\mathrm{loc},
      \mathrm{virt}}$, $\pk{\mathrm{rem}, \mathrm{virt}}$,
      $\pk{\mathrm{left}, \mathrm{guest}}$, $\pk{\mathrm{right},
      \mathrm{guest}}$, $\{\pk{\mathrm{sec}, i}\}_{1 \dots n}$, False)
      \label{code:virtual-layer:fundee-sigs:tx-none}
      \For{each hop apart from the first and ours ($i \in [2, \dots, n-1]$)}
      \Comment{hop data encoded in \texttt{left\_data}}
        \State extract data needed for \textsc{getMidTXs}() from
        \texttt{left\_data} and assign it to $\texttt{data}_i$ and
        $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$
        \Comment{$\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$ contains each
        party's $\pk{i, \mathrm{virt}}$}
        \State ($\mathrm{TX}_{i, \mathrm{none}}$, $\mathrm{TX}_{i,
        \mathrm{left}}$, $\mathrm{TX}_{i, \mathrm{right}}$, $\mathrm{TX}_{i,
        \mathrm{both}}$) $\gets$ \textsc{virt.getMidTXs}($\texttt{data}_i$,
        $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$)
        \State add \textsc{sign}($\mathrm{TX}_{i, \mathrm{right}}$,
        $\sk{\mathrm{loc}, \mathrm{virt}}$, \textsc{anyprevout}) and
        \textsc{sign}($\mathrm{TX}_{i, \mathrm{both}}$, $\sk{\mathrm{loc},
        \mathrm{virt}}$, \textsc{anyprevout}) to
        $\mathrm{sigs}_{\mathrm{toLeft}}$ \Comment{if $i$-th hop is
        adjacent, $2$ signatures will be produced by each \textsc{sign}()
        invocation: one for the \texttt{guest\_all} and one for the
        $\texttt{"2"} \wedge \texttt{right\_virt\_checked}$ input}
        \State output (\textsc{sign TXs}, $\mathrm{TX}_{i, \mathrm{left}}$,
        $\mathrm{TX}_{i, \mathrm{right}}$, $\mathrm{TX}_{i, \mathrm{both}}$)
        to \texttt{fundee} and expect reply (\textsc{TXs signed},
        $\mathrm{sigs}_{\mathrm{guest}}$)
        \State add $\mathrm{sigs}_{\mathrm{guest}}$ to
        $\mathrm{sigs}_{\mathrm{toLeft}}$
        \If{$i = n - 1$} \Comment{hop is our previous}
          \State add \textsc{sign}($\mathrm{TX}_{i, \mathrm{left}}$,
          $\sk{\mathrm{loc}, \mathrm{virt}}$, \textsc{anyprevout}) to
          $\mathrm{sigs}_{\mathrm{toLeft}}$
        \EndIf
      \EndFor
      \State \Return $\mathrm{sigs}_{\mathrm{toLeft}}$
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:fundee-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.hostFunderSigs}()}
    \begin{algorithmic}[1]
      \For{each hop apart from the last and ours ($i \in [2, \dots, n-1]$)}
      \Comment{hop data encoded in \texttt{right\_data}}
        \State extract data needed for \textsc{getMidTXs}() from
        \texttt{right\_data} and assign it to $\texttt{data}_i$ and
        $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$
        \Comment{$\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$ contains each
        party's $\pk{i, \mathrm{virt}}$}
        \State ($\mathrm{TX}_{i, \mathrm{none}}$, $\mathrm{TX}_{i,
        \mathrm{left}}$, $\mathrm{TX}_{i, \mathrm{right}}$, $\mathrm{TX}_{i,
        \mathrm{both}}$) $\gets$ \textsc{virt.getMidTXs}($\texttt{data}_i$,
        $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$)
        \State add \textsc{sign}($\mathrm{TX}_{i, \mathrm{right}}$,
        $\sk{\mathrm{loc}, \mathrm{virt}}$, \textsc{anyprevout}) and
        \textsc{sign}($\mathrm{TX}_{i, \mathrm{both}}$, $\sk{\mathrm{loc},
        \mathrm{virt}}$, \textsc{anyprevout}) to
        $\mathrm{sigs}_{\mathrm{toRight}}$ \Comment{if $i$-th hop is
        adjacent, $2$ signatures will be produced by each \textsc{sign}()
        invocation: one for the \texttt{guest\_all} and one for the
        $\texttt{"2"} \wedge \texttt{right\_virt\_checked}$ input}
        \State output (\textsc{sign TXs}, $\mathrm{TX}_{i, \mathrm{left}}$,
        $\mathrm{TX}_{i, \mathrm{right}}$, $\mathrm{TX}_{i, \mathrm{both}}$)
        to \texttt{fundee} and expect reply (\textsc{TXs signed},
        $\mathrm{sigs}_{\mathrm{guest}}$)
        \State add $\mathrm{sigs}_{\mathrm{guest}}$ to
        $\mathrm{sigs}_{\mathrm{toRight}}$
        \If{$i = 2$} \Comment{hop is our next}
          \State add \textsc{sign}($\mathrm{TX}_{i, \mathrm{left}}$,
          $\sk{\mathrm{loc}, \mathrm{virt}}$, \textsc{anyprevout}) to
          $\mathrm{sigs}_{\mathrm{toRight}}$
        \EndIf
      \EndFor
      \State call
      \textsc{virt.circulateVirtualSigs}($\mathrm{sigs}_{\mathrm{toRight}}$)
      of $P$ and assign output to $\mathrm{sigs}_{\mathrm{byRight}}$
      \State $\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$ $\gets$
      \textsc{virt.getEndpointTX}($c_{\mathrm{guest}}$, $c_P$, $c_{\bar{P}}$,
      $\pk{\mathrm{loc}, F}$, $\pk{\mathrm{rem}, F}$, $\pk{\mathrm{loc},
      \mathrm{virt}}$, $\pk{\mathrm{rem}, \mathrm{virt}}$, $\pk{\mathrm{left},
      \mathrm{guest}}$, $\pk{\mathrm{right}, \mathrm{guest}}$,
      $\{\pk{\mathrm{sec}, i}\}_{1 \dots n}$, True)
      \label{code:virtual-layer:funder-sigs:tx-none}
      \State \Return (\textsc{ok})
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:funder-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.circulateVirtualSigs}($\mathrm{sigs}_{\mathrm{byLeft}}$)}
    \begin{algorithmic}[1]
      \If{$\mathrm{sigs}_{\mathrm{byLeft}}$ is given as argument} \Comment{we
      are not \texttt{host\_funder}}
        \If{we have a \texttt{sibling}} \Comment{we are not
        \texttt{host\_fundee}}
          \State \Return \textsc{virt.intermediarySigs}()
        \Else \: \Comment{we are \texttt{host\_fundee}}
          \State \Return \textsc{virt.hostFundeeSigs}()
        \EndIf
      \Else \: \Comment{we are \texttt{host\_funder}}
        \State \Return \textsc{virt.hostFunderSigs}()
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:virtual-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.circulateFundingSigs}($\mathrm{sig}_{\mathrm{loc},
  \mathrm{none}}, \mathrm{sig}_{\mathrm{loc}, \mathrm{right}}$)}
    \begin{algorithmic}[1]
      \If{$\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$ is given as argument}
      \Comment{we are not \texttt{host\_funder}}
        \State ensure \textsc{verify}($\mathrm{TX}_{\mathrm{loc},
        \mathrm{none}}$, $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$,
        $\pk{\mathrm{prev}, F}$) = True \Comment{$\pk{\mathrm{prev}, F}$ found
        in \texttt{left\_data}}
        \State $\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}} \gets \{
        \mathrm{sig}_{\mathrm{loc}, \mathrm{none}} \}$
        \If{$\mathrm{sig}_{\mathrm{loc}, \mathrm{right}}$ is given as argument}
        \Comment{we are not \texttt{host\_fundee}}
          \State ensure \textsc{verify}($\mathrm{TX}_{\mathrm{loc},
          \mathrm{right}}$, $\mathrm{sig}_{\mathrm{loc}, \mathrm{right}}$,
          $\pk{\mathrm{prev}, F}$) = True
          \State $\mathrm{sigs}_{\mathrm{loc}, \mathrm{right}} \gets \{
          \mathrm{sig}_{\mathrm{loc}, \mathrm{right}} \}$
          \State input (\textsc{virtual base sig forward},
          $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$) to \texttt{sibling}
          \Comment{\texttt{sibling} needs $\mathrm{sig}_{\mathrm{loc},
          \mathrm{none}}$ for closing}
          \State \trustedcode{$\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}} \gets
          \{ \mathrm{sig}_{\mathrm{loc}, \mathrm{none}} \}$}
          \State \trustedcode{$\mathrm{sig}_{\mathrm{next}, \mathrm{none}} \gets
          \textsc{sign}(\mathrm{TX}_{\mathrm{next}, \mathrm{none}},
          \sk{\mathrm{loc}, F})$}
          \State \trustedcode{$\texttt{args} \gets \{\mathrm{sig}_{\mathrm{next},
          \mathrm{none}}$\}}
          \If{\trustedcode{\texttt{right\_data} contains data from a second-next
          hop}} \Comment{next hop is not \texttt{host\_fundee}}
            \State \trustedcode{$\mathrm{sig}_{\mathrm{next}, \mathrm{right}}
            \gets \textsc{sign}(\mathrm{TX}_{\mathrm{next}, \mathrm{right}},
            \sk{\mathrm{loc}, F})$}
            \State \trustedcode{add $\mathrm{sig}_{\mathrm{next},
            \mathrm{right}}$ to \texttt{args}}
          \EndIf
          \State \trustedcode{call
          \textsc{virt.circulateFundingSigs}(\texttt{args}) of $\bar{P}$ and
          assign returned values to ($\mathrm{sig}_{\mathrm{loc},
          \mathrm{none}}$, $\mathrm{sig}_{\mathrm{loc}, \mathrm{left}}$)}
          \State \trustedcode{ensure \textsc{verify}($\mathrm{TX}_{\mathrm{loc},
          \mathrm{none}}$, $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$,
          $\pk{\mathrm{next}, F}$) = True} \Comment{$\pk{\mathrm{next}, F}$,
          found in \texttt{right\_data}}
          \State \trustedcode{ensure \textsc{verify}($\mathrm{TX}_{\mathrm{loc},
          \mathrm{left}}$, $\mathrm{sig}_{\mathrm{loc}, \mathrm{left}}$,
          $\pk{\mathrm{next}, F}$) = True}
          \State \trustedcode{add $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$
          to $\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}}$;
          $\mathrm{sigs}_{\mathrm{loc}, \mathrm{left}} \gets \{
          \mathrm{sig}_{\mathrm{loc}, \mathrm{left}} \}$}
          \State \trustedcode{output (\textsc{virtual base sig back},
          $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$) \Comment{sibling needs
          $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$ for closing}}
          \State add $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$ to
          $\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}}$
        \EndIf
        \State $\mathrm{sig}_{\mathrm{prev}, \mathrm{none}} \gets
        \textsc{sign}(\mathrm{TX}_{\mathrm{prev}, \mathrm{none}},
        \sk{\mathrm{loc}, F})$
        \If{\texttt{left\_data} contains data from a second-previous hop}
        \Comment{previous hop not is \texttt{host\_funder}}
          \State $\mathrm{sig}_{\mathrm{prev}, \mathrm{left}} \gets
          \textsc{sign}(\mathrm{TX}_{\mathrm{prev}, \mathrm{left}},
          \sk{\mathrm{loc}, F})$
          \State \Return ($\mathrm{sig}_{\mathrm{prev}, \mathrm{none}}$,
          $\mathrm{sig}_{\mathrm{prev}, \mathrm{left}}$)
        \Else \: \Comment{previous hop is \texttt{host\_funder}}
          \State \Return $\mathrm{sig}_{\mathrm{prev}, \mathrm{none}}$
        \EndIf
      \Else \: \Comment{we are \texttt{host\_funder}}
        \State $\mathrm{sig}_{\mathrm{next}, \mathrm{none}} \gets
        \textsc{sign}(\mathrm{TX}_{\mathrm{next}, \mathrm{none}},
        \sk{\mathrm{loc}, F})$
        \label{code:virtual-layer:funding-sigs:funder-sign-none}
        \State $\mathrm{sig}_{\mathrm{next}, \mathrm{right}} \gets
        \textsc{sign}(\mathrm{TX}_{\mathrm{next}, \mathrm{right}},
        \sk{\mathrm{loc}, F})$
        \label{code:virtual-layer:funding-sigs:funder-sign-right}
        \State call
        \textsc{virt.circulateFundingSigs}($\mathrm{sig}_{\mathrm{next},
        \mathrm{none}}$, $\mathrm{sig}_{\mathrm{next}, \mathrm{right}}$) of
        $\bar{P}$ and assign returned value to $\mathrm{sig}_{\mathrm{loc},
        \mathrm{none}}$
        \State ensure \textsc{verify}($\mathrm{TX}_{\mathrm{loc},
        \mathrm{none}}$, $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$,
        $\pk{\mathrm{next}, F}$) = True \Comment{$\pk{\mathrm{next}, F}$ found
        in \texttt{right\_data}}
        \label{code:virtual-layer:funding-sigs:funder-verify}
        \State $\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}} \gets \{
        \mathrm{sig}_{\mathrm{loc}, \mathrm{none}} \}$
        \State \Return (\textsc{ok})
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:funding-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.circulateRevocations}(\texttt{revoc\_by\_prev})}
    \begin{algorithmic}[1]
    \If{\texttt{revoc\_by\_prev} is given as argument} \Comment{we are not
    \texttt{host\_funder}}
      \State ensure
      \texttt{guest}.\textsc{processRemoteRevocation}(\texttt{revoc\_by\_prev})
      returns (\textsc{ok})
      \label{code:virtual-layer:revocation:non-funder:proc-remote}
    \Else \: \Comment{we are \texttt{host\_funder}}
      \State $\texttt{revoc\_for\_next} \gets
      \texttt{guest}.\textsc{revokePrevious}()$
      \State input (\textsc{read}) to \ledger and assign ouput to $\Sigma$
      \State $\texttt{last\_poll} \gets |\Sigma|$
      \State call \textsc{virt.circulateRevocations}(\texttt{revoc\_for\_next})
      of $\bar{P}$ and assign returned value to \texttt{revoc\_by\_next}
      \label{code:virtual-layer:revocation:revoc-by-next}
      \State ensure
      \texttt{guest}.\textsc{processRemoteRevocation}(\texttt{revoc\_by\_next})
      returns (\textsc{ok}) \Comment{If the ``ensure'' fails, the opening
      process freezes, this is intentional. The channel can still close via
      (\textsc{close})}
      \label{code:virtual-layer:revocation:funder:proc-remote}
      \State \Return (\textsc{ok})
    \EndIf
    \If{we have a \texttt{sibling}} \Comment{we are not \texttt{host\_fundee}
    nor \texttt{host\_funder}}
      \State input (\textsc{virtual revocation forward}) to \texttt{sibling}
      \State \trustedcode{$\texttt{revoc\_for\_next} \gets
      \texttt{guest}.\textsc{revokePrevious}()$}
      \State input (\textsc{read}) to \ledger and assign ouput to $\Sigma$
      \State $\texttt{last\_poll} \gets |\Sigma|$
      \State \trustedcode{call
      \textsc{virt.circulateRevocations}(\texttt{revoc\_for\_next}) of $\bar{P}$
      and assign output to \texttt{revoc\_by\_next}}
      \State \trustedcode{ensure
      \texttt{guest}.\textsc{processRemoteRevocation}(\texttt{revoc\_by\_next})
      returns (\textsc{ok})}
      \State \trustedcode{output (\textsc{hosts ready}) to \texttt{guest} and
      expect reply (\textsc{host ack})}
      \State \trustedcode{output (\textsc{virtual revocation back})}
    \EndIf
    \State $\texttt{revoc\_for\_prev} \gets
    \texttt{guest}.\textsc{revokePrevious}()$
    \State output (\textsc{hosts ready}) to \texttt{guest} and expect reply
    (\textsc{host ack})
    \label{code:virtual-layer:revocation:hosts-ready}
    \State \Return \texttt{revoc\_for\_prev} \Comment{we are not
    \texttt{host\_fundee} nor \texttt{host\_funder}}
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:revocation}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt} -- poll}
    \begin{algorithmic}[1]
      \State On input (\textsc{check for lateral close}) by $R \in$
      \{\texttt{guest}, \texttt{funder}, \texttt{fundee}\}:
      \Indent
        \State input (\textsc{read}) to \ledger and assign output to $\Sigma$
        \State $\texttt{prev\_went\_on\_chain} \gets \mathrm{TX}_{\mathrm{prev},
        \mathrm{left}} \in \Sigma \vee \mathrm{TX}_{\mathrm{prev},
        \mathrm{none}} \in \Sigma$
        \State $\texttt{next\_went\_on\_chain} \gets \mathrm{TX}_{\mathrm{next},
        \mathrm{right}} \in \Sigma \vee \mathrm{TX}_{\mathrm{next},
        \mathrm{none}} \in \Sigma$
        \State $\texttt{last\_poll} \gets |\Sigma|$
        \If{$\texttt{prev\_went\_on\_chain} \vee
        \texttt{next\_went\_on\_chain}$}
          \State ignore all messages except for (\textsc{check if closing}) by
          $R$
          \State $\textit{State} \gets \textsc{closing}$
        \EndIf
        \If{$\texttt{prev\_went\_on\_chain} \wedge
        \texttt{next\_went\_on\_chain}$}
          \State
          \textsc{virt}.\textsc{signAndSubmit}($\mathrm{TX}_{\mathrm{loc},
          \mathrm{both}}$, $\mathrm{sigs}_{\mathrm{loc}, \mathrm{both}}$)
        \ElsIf{\texttt{prev\_went\_on\_chain}}
          \State
          \textsc{virt}.\textsc{signAndSubmit}($\mathrm{TX}_{\mathrm{loc},
          \mathrm{left}}$, $\mathrm{sigs}_{\mathrm{loc}, \mathrm{left}}$)
        \ElsIf{\texttt{next\_went\_on\_chain}}
          \State
          \textsc{virt}.\textsc{signAndSubmit}($\mathrm{TX}_{\mathrm{loc},
          \mathrm{right}}$, $\mathrm{sigs}_{\mathrm{loc}, \mathrm{right}}$)
        \EndIf
      \EndIndent
      \Statex

      \State \textsc{virt}.\textsc{signAndSubmit}(tx, sigs):
      \Indent
        \State add \textsc{sign}(tx, $\sk{\mathrm{loc}, F}$) to sigs
        \State input (\textsc{submit}, tx, sigs) to \ledger
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:poll}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt} -- On input (\textsc{close}) by $R \in
  \{\texttt{guest}, \texttt{funder}, \texttt{fundee}\}$:}
    \begin{algorithmic}[1]
      \State \Comment{At most one of \texttt{funder}, \texttt{fundee} is
      defined}
      \IfThen{\textit{State} = \textsc{closed}}{output (\textsc{closed}) to
      $R$}
      \IfThen{\textit{State} = \textsc{guest punished}}{output (\textsc{guest
      punished}) to $R$}
      \label{code:virtual-layer:close:output-guest-punished}
      \State ensure \textit{State} = \textsc{open}
      \If{$\texttt{host}_P \neq \ledger$} \Comment{$\texttt{host}_P$ is a
      \textsc{virt}}
      \label{code:virtual-layer:close:if-nested-host}
        \State ignore all messages except for output (\textsc{closed}) by
        $\texttt{host}_P$. Also relay to $\texttt{host}_P$ any (\textsc{check if
        closing}) input received
        \State input (\textsc{close}) to $\texttt{host}_P$
      \EndIf
      \State \Comment{if we have a $\texttt{host}_P$, continue from here on
      output (\textsc{closed}) by it}
      \State send (\textsc{read}) to \ledger as $R$ and assign reply to
      $\Sigma$
      \If{\texttt{funder} or \texttt{fundee} is defined and
      $\mathrm{TX}_{\mathrm{none}, \mathrm{loc}}$ is not valid in $\Sigma$}
      \Comment{we are an endpoint and our counterparty has closed}
        \State ignore all messages except for (\textsc{check if closing}) by $R$
        \State $\textit{State} \gets \textsc{closing}$
        \State give up execution token \Comment{control goes to \environment}
      \EndIf
      \State let \texttt{tx} be the unique valid TX for $\Sigma$ among
      ($\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$,
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{left}}$, $\mathrm{TX}_{\mathrm{loc},
      \mathrm{right}}$, $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$)
      \Comment{if we are not an intermediary, only the first exists}
      \label{code:virtual-layer:close:tx}
      \State let \texttt{sigs} be the corresponding set of signatures among
      ($\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}}$,
      $\mathrm{sigs}_{\mathrm{loc}, \mathrm{left}}$,
      $\mathrm{sigs}_{\mathrm{loc}, \mathrm{right}}$,
      $\mathrm{sigs}_{\mathrm{loc}, \mathrm{both}}$)
      \State add \textsc{sign}(\texttt{tx}, $\sk{A, F}$) and
      \textsc{sign}(\texttt{tx}, $\sk{\mathrm{loc}, \mathrm{virt}}$) to
      \texttt{sigs} \Comment{one of the two signatures may be empty, as some
      transactions don't need a signature by both keys. This is not a
      problem.}
      \State ignore all messages except for (\textsc{check if closing}) by $R$
      \State $\textit{State} \gets \textsc{closing}$
      \State send (\textsc{submit}, (\texttt{tx}, \texttt{sigs})) to \ledger
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:close}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt} -- On input (\textsc{check if closing}) by
  $R \in \{\texttt{guest}, \texttt{funder}, \texttt{fundee}\}$:}
    \begin{algorithmic}[1]
      \State ensure \textit{State} = \textsc{closing}
      \State send (\textsc{read}) to \ledger as $R$ and assign reply to $\Sigma$
      \If{\texttt{funder} is defined}
        \State ensure that there exists an output with $c_P + c_{\bar{P}} -
        c_{\mathrm{guest}}$ coins and a $\texttt{"3"} \wedge
        2/\{\pk{\mathrm{loc}, \mathrm{virt}}, \pk{\mathrm{rem},
        \mathrm{virt}}\}$ spending method with expired/non-existent timelock in
        $\Sigma$ \Comment{\texttt{guest}'s output}
        \label{code:virtual-layer:check-chain-close:funder:output-guest}
        \State ensure that there exists an output with $c_{\mathrm{guest}}$
        coins and a $\texttt{"3"} \wedge 2/\{\pk{\mathrm{left}, \mathrm{guest}},
        \pk{\mathrm{right}, \mathrm{guest}}\}$ spending method with
        expired/non-existent timelock in $\Sigma$ \Comment{\texttt{funder}'s
        output}
        \label{code:virtual-layer:check-chain-close:funder:output-funder}
      \ElsIf{\texttt{fundee} is defined}
        \State ensure that there exists an output with $c_P + c_{\bar{P}} -
        c_{\mathrm{guest}}$ coins and a $\texttt{"3"} \wedge
        2/\{\pk{\mathrm{loc}, \mathrm{virt}}, \pk{\mathrm{rem},
        \mathrm{virt}}\}$ spending method with expired/non-existent timelock in
        $\Sigma$ \Comment{\texttt{guest}'s output}
        \State ensure that there exists an output with $c_{\mathrm{guest}}$
        coins and a $\texttt{"3"} \wedge 2/\{\pk{\mathrm{left}, \mathrm{guest}},
        \pk{\mathrm{right}, \mathrm{guest}}\}$ spending method with
        expired/non-existent timelock in $\Sigma$ \Comment{\texttt{fundee}'s
        output}
      \Else \: \Comment{we are intermediary}
        \State ensure that there exists an output with $c_P + c_{\bar{P}} -
        c_{\mathrm{guest}}$ coins and a $\texttt{"3"} \wedge
        2/\{\pk{\mathrm{loc}, \mathrm{virt}}, \pk{\mathrm{rem},
        \mathrm{virt}}\}$ spending method with expired/non-existent timelock and
        an output with $c_{\mathrm{guest}}$ coins and a $\pk{\mathrm{loc},
        \mathrm{out}}$ spending method with expired/non-existent timelock in
        $\Sigma$
      \EndIf
      \State $\textit{State} \gets \textsc{closed}$
      \State output (\textsc{closed}) to $R$
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:check-chain-close}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt} -- punishment handling}
    \begin{algorithmic}[1]
      \State On input (\textsc{used revocation}) by \texttt{guest}:
      \Comment{(\textsc{used revocation}) by \texttt{funder}/\texttt{fundee} is
      ignored}
      \label{code:virtual-layer:punishment:when-punished-1}
      \Indent
        \State $\textit{State} \gets \textsc{guest punished}$
        \State input (\textsc{used revocation}) to $\texttt{host}_P$, expect
        reply (\textsc{used revocation ok})
        \If{\texttt{funder} or \texttt{fundee} is defined}
          \State output (\textsc{enabler used revocation}) to it
        \Else \: \Comment{\texttt{sibling} is defined}
          \State output (\textsc{enabler used revocation}) to \texttt{sibling}
        \EndIf
      \EndIndent
      \Statex

      \State On input (\textsc{enabler used revocation}) by \texttt{sibling}:
      \Indent
        \State $\textit{State} \gets \textsc{guest punished}$
        \State output (\textsc{enabler used revocation}) to \texttt{guest}
      \EndIndent
      \Statex

      \State On output (\textsc{used revocation}) by $\texttt{host}_P$:
      \label{code:virtual-layer:punishment:when-punished-2}
      \Indent
        \State $\itistate \gets \textsc{guest punished}$
        \If{\texttt{funder} or \texttt{fundee} is defined}
          \State output (\textsc{enabler used revocation}) to it
        \Else \: \Comment{\texttt{sibling} is defined}
          \State output (\textsc{enabler used revocation}) to \texttt{sibling}
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:punishment}
\end{figure}
