\section{Protocol Description}
  Conceptually, Elmo is split into four main actions: channel opening,
  payments, cooperative closing and unilateral closing. A channel $(P_1, P_n)$
  between parties $P_1$ and $P_n$
  may be opened directly on-chain, in which case the two parties follow an
  opening procedure similar to that of LN; such a channel is called
  \emph{simple}.
  Otherwise it can be opened on top of a path
  of preexisting \emph{base} channels $(P_1, P_2)$, $(P_2, P_3)$, $\dots$,
  $(P_{n-1}, P_{n})$, in which case $(P_1, P_n)$ is a \emph{virtual}
  channel (since Elmo is recursive, each base channel may itself be simple or
  virtual). To open a virtual
  channel, all parties $P_i$ on the
  path follow our protocol, setting aside funds in their channels as
  collateral for the new virtual channel; this is done
  by creating so-called \emph{virtual} transactions (txs) that essentially
  tie the spending of two adjacent base channels into a single atomic action.
  Once intermediaries are done, a special \emph{funding} output has been
  created off-chain which carries the sum of $P_1$ and $P_n$'s channel
  balance. $P_1$ and $P_n$
  finally create the channel, applying a logic similar to LN on top of
  the funding output: their channel is now open. LN demands that the funding
  output is on-chain, but we lift this requirement. We instead guarantee that
  either endpoint can put the funding output put on-chain unilaterally.

  A payment over an established channel follows a procedure also inspired by
  LN.
  The two parties need to exchange three messages to perform a payment.

  A virtual channel can be optimistically closed completely off-chain. At a high
  level, the parties that control the base channels \emph{revoke} their \emph{virtual}
  txs and the related \emph{commitment} txs. Revoked txs
  cannot be used anymore. This effectively ``peels'' one virtualisation layer.
  Coins are redistributed so that intermediaries ``break even'', while $P_1$
  and $P_n$ get their rightful coins (as reflected in the last virtual channel
  state) in their base channels ($(P_1, P_2)$ and $(P_{n-1}, P_n)$
  respectively).

  Finally, the unilateral closing procedure of a virtual channel $(P_1, P_n)$
  does not need cooperation and consists of signing and publishing a number of
  txs on-chain. In the simplest case, one of the two endpoints, say
  $P_1$, publishes her virtual tx. This prompts $P_2$ to publish her
  virtual tx as well and so on up to $P_{n-1}$, at which point the
  funding output of $(P_1, P_n)$ is automatically on-chain and closing can
  proceed as in LN. If instead any intermediary stays inactive, then a timelock
  expires and a suitable output becomes the funding output for $(P_1, P_n)$, at
  the expense of the inactive party. As we will see below, \texttt{ANYPREVOUT} is
  used in the funding output to ensure that the channel needs only a
  single commitment tx per endpoint, avoiding a state blowup that would be
  exponential in the recursion depth and making off-chain payments efficient.

  Briefly, a virtual channel is built on top of two or more \emph{base
  channels}, which, due to the recursive property, may themselves be simple or
  virtual. The parties that control the base channels are called \emph{base
  parties}. The variadic property ensures that a virtual chanel can use more than two base channels.

  As we mentioned earlier, a channel with its funding tx on-chain is
  called \emph{simple}. A channel is either simple or virtual, not both. At a
  high level, during the channel opening procedure (cf.
  Fig.~\ref{code:ln:open}) the two counterparties (i) create new keypairs and
  exchange the resulting public keys ($2$ messages), then (ii) if the channel is
  virtual, prepare the underlying base channels ($12 \cdot (n-1)$ total
  messages, i.e., $6$ outgoing messages per endpoint and $12$ outgoing messages
  per intermediary, for $n-2$ intermediaries), next (iii) they exchange
  signatures for their respective initial commitment txs ($2$ messages)
  and lastly, (iv) if the channel is simple, the \emph{funder} signs and
  publishes the \emph{funding} tx to the ledger. We note that like LN,
  only one of the two parties, the funder, provides coins for a new channel.
  This limitation simplifies the execution model and analysis, but can be lifted
  at the cost of additional protocol complexity.

  In order to build better intuition for Elmo, let us present examples of the
  lifecycles of a simple and a virtual channel. Consider $5$ parties, $A, B,
  \dots, E$ and $4$ channels, $(A, B)$, $\dots,(D, E)$, that will act as
  the base of the virtual channel $(A, E)$. We first follow the operations of
  the simple channel $(A, B)$ and then those of $(A, E)$. We simplify some parts
  of the protocol to aid comprehension.

  \makeatletter%
  \@ifclassloaded{IEEEtran}%
    {\paragraph{Simple channel}}%
    {\paragraph{Simple channel.}}%
  \makeatother%
  \addtolength{\intextsep}{-15pt}
  \begin{figure}[!htbp]
    \centering
    \subimport{./figures/manual-tikz/}{payment-layer-simple.tex}
    \caption{Left to right: funding, $A$'s commitment and $B$'s revocation txs.
    The symmetric commitment and
    revocation txs of $B$ and $A$ respectively are not shown.
    %$A \wedge B$ needs a signature by both $A$ and $B$,
    $A_R$ is $A$'s revocation key. $A+t$ needs a signature
    by $A$ after relative timelock of $t$. The first commitment output is
    spendable by either $A_R \wedge B_R$ or by $A + t$.}%, with the ``or'' denoted with $\vee$.}
    \label{figure:payment-layer-simple}
  \end{figure}
  \addtolength{\intextsep}{15pt}

  First $A$ and $B$ generate keypairs and exchange the public keys. Each then
  locally generates the \emph{funding} and the two \emph{commitment} txs
  (Fig.~\ref{figure:payment-layer-simple}). The latter are signed and the
  signatures are exchanged. $A$ then publishes the funding tx on-chain. Once it
  is finalised, the channel is open.

  The funding tx moves $A$'s initial coins to a $2$-of-$2$ multisig, i.e., an
  output that needs signatures from both $A$ and $B$ to be spent. There is one
  commitment tx per party, stored locally off-chain. The one held by $A$
  ($C_{A,i}$ in Fig.~\ref{figure:payment-layer-simple}) spends the funding tx
  and has one output for $A$ (initially with all coins) and one for $B$
  (initially with $0$ coins). $A$'s output can be spent by either a multisig, or
  by $A$ after a \emph{relative timelock} of $t$ (relative means that the countdown starts at the moment of
  publication). This is, as we will promptly see, so
  that $B$ has time to \emph{punish} $A$ if she cheats. $B$'s commitment tx
  is symmetric.

  When $A$ pays $c$ coins to $B$, the parties create two new commitment txs.
  They have the same outputs and scripts as their previous ones, save for the
  coins: $A$'s outputs have $c$ coins less, $B$'s outputs have $c$ coins more.
  They sign them and exchange the signatures. In order to ensure only one set of
  commitment txs is valid at a time, they then revoke their previous ones. This
  is done by generating and signing the revocation txs of the previous
  commitment txs. $B$'s revocation tx ($R_B$ in
  Fig.~\ref{figure:payment-layer-simple}) gives to $B$ the coins that belonged
  to $A$ in the previous commitment tx and vice versa. This way both parties are
  disincentivised from publishing an old commitment tx under the threat of
  losing all their channel coins.

  Closing $(A, B)$ is now as simple as unilaterally publishing the latest
  commitment tx on-chain and waiting for the timelock to expire. Since the last
  commitment tx is not revoked, punishment is impossible. Observe that the
  mechanics of simple channels are essentially a simplification of LN.

  \makeatletter%
  \@ifclassloaded{IEEEtran}%
    {\paragraph{Virtual channel}}%
    {\paragraph{Virtual channel.}}%
  \makeatother%
  \addtolength{\intextsep}{-15pt}
  \begin{figure}[!htbp]
    \subimport{./figures/manual-tikz/}{intermediary-initiator-simple.tex}
    \caption{$A-E$ virtual channel: $B$'s initiator transaction. Spends the
    funding outputs of the $A-B$ and $B-C$ channels. Can be used if neither
    $A$ nor $C$ have published a virtual transaction yet. $A_V$: $A$'s
    ``virtual'' key. $A_b$: $A$'s ``bridge'' key.}
    \label{figure:virtual-layer-initiator-simple}
  \end{figure}
  \addtolength{\intextsep}{15pt}

  Assume now that channels $(A, B)$, $\dots,(D, E)$, are open and the ``left''
  party of each owns at least $c$ coins in it. These channels can be either
  simple or virtual -- in the latter case, the recursive property is leveraged.
  Thanks to the similarity of all layers, the description below is identical in
  either case. In order for the virtual channel $(A, E)$ to open using $(A, B)$,
  $\dots,(D, E)$, as base channels, initially with $A$ having $c$ coins, the
  following
  steps are taken. First, the $5$ parties generate and exchange keys. Then the
  base parties are set up: each base channel is updated to contain $c$ less
  coins, taken from the ``left'' party. The updated commitment txs also use new
  keys for their input multisig, since, as we will see, so-called \emph{virtual}
  txs will interject the funding and the commitment txs from now on, all
  together forming the \emph{virtual layer}.

  \addtolength{\intextsep}{-15pt}
  \begin{figure}[!htbp]
    \subimport{./figures/manual-tikz/}{intermediary-extend-interval-simple.tex}
    \caption{$A-E$ virtual channel: One of $B$'s extend interval
    transactions. Spends the virtual output of $A$'s
    initiator transaction and the funding output of the $B$-$C$ channel. Can be
    used if $A$ has already published its initiator transaction and $C$ has not
    published a virtual transaction yet.}
    \label{figure:virtual-layer-extend-interval-simple}
  \end{figure}
  \addtolength{\intextsep}{15pt}

  Next, these virtual txs are generated and signed. These txs sit at the core of
  Elmo. Their logic is as follows: each intermediary is forced to spend both its
  adjacent funding outputs at once if it wants to close either of its channels
  -- the currently valid way of spending the funding output, the commitment tx,
  will soon be revoked. Spending the two funding outputs is done by the
  intermediary's \emph{initiator} virtual tx, which produces one new funding
  output for each of the channels
  (Fig.~\ref{figure:virtual-layer-initiator-simple}, top \& bottom outputs), one
  output that refunds the collateral to the intermediary ($2$nd from top) and,
  crucially, a so-called \emph{virtual} output ($3$rd from top). The latter
  output can be spent by either of the two adjacent parties if they are
  intermediaries, using an \emph{extend-interval} virtual tx. Such a tx also
  spends the other, as-of-yet unspent, funding output of the intermediary that
  publishes it (Fig.~\ref{figure:virtual-layer-extend-interval-simple}, bottom
  input). It has $3$ outputs: one refunding the collateral to the publisher
  (top), another virtual output (middle) and a funding output that replaces the
  one just spent (bottom). This virtual output can in turn be spent by another
  extend-interval tx, which produces yet another virtual output and so on until
  all base funding outputs are spent and all intermediaries are refunded. The
  last virtual output is finally the funding output of the virtual channel.

  The virtual txs are designed around two axes: First, each intermediary can
  only publish a single virtual tx, by which it is refunded its collateral
  exactly once. Second, if the chain of virtual txs is at any point broken by,
  e.g., an inactive intermediary that does not publish its virtual tx, the
  virtual channel will still be funded correctly. This is achieved by turning
  the unclaimed virtual output into the funding output of the virtual channel
  after a timelock (see, e.g., $2$nd spending method of the $3$rd output of
  Fig.~\ref{figure:virtual-layer-initiator-simple}). In this case, the inactive party loses its collateral.

  \addtolength{\intextsep}{-15pt}
  \begin{figure}[!htbp]
    \subimport{./figures/manual-tikz/}{virtual-layer-endpoint-simple.tex}
    \caption{$A-E$ virtual channel: $A$'s initiator transaction. Spends the
    funding output of the $A-B$ channel. Can be used if $B$ has not published
    a virtual transaction.}
    \label{figure:virtual-layer-endpoint-simple}
  \end{figure}
  \addtolength{\intextsep}{15pt}

  A number of considerations remain before the security of the scheme is
  ensured. Firstly, $A$ and $E$ need to be able to unilaterally initiate the
  ``collapse'' of the virtual layer. This is achieved by equipping them with
  special, single-input initiator txs
  (Fig.~\ref{figure:virtual-layer-endpoint-simple}) -- these are the only virtual
  txs needed by the $2$ endpoints. Secondly, intermediaries must be able to
  regain their collateral even if both their funding outputs have been consumed.
  This is ensured via \emph{merge-intervals} virtual txs (e.g.,
  Fig.~\ref{figure:virtual-layer-merge-intervals-simple}) which spend both
  lateral virtual outputs, refund the publisher and produce a new virtual
  output. Thirdly, it must be ensured that no intermediary can publish more than
  one virtual tx to protect the endpoints from an unbounded sequence of virtual
  txs preventing them from accessing their funding output indefinitely -- note
  that malicious parties can fabricate arbitrarily many virtual outputs using
  their own, external to the protocol, coins, therefore if all virtual outputs
  were identical, a perpetual stream of merge-intervals txs, spending one valid
  and one fabricated virtual output, could be published. This is safeguarded by
  specifying on each virtual output the exact sequence of parties that have
  already published a virtual tx and only allowing the parties at the two edges
  to extend it with their virtual tx. Virtual outputs that correspond to cases
  in which all intermediaries have acted are not spendable by another virtual
  transaction, ensuring that the endpoints will eventually obtain a funding
  output. Preventing this attack means that intermediaries need to store
  $O(n^3)$ virtual transactions for a virtual channel over $n$ parties. Lastly,
  the exact values of timelocks have to be carefully selected to ensure that
  enough time is given to each party to act. The timelocks increase linearly
  with the depth of the recursion. The exact values are shown in
  Appxs.~\ref{sec:pseudocode} and~\ref{sec:protocol}.

  \addtolength{\intextsep}{-15pt}
  \begin{figure}[!htbp]
    \subimport{./figures/manual-tikz/}{intermediary-merge-intervals-simple.tex}
    \caption{$A$--$E$ virtual channel: One of $B$'s merge intervals
    transactions. Spends the virtual outputs of $A$'s and $C$'s virtual
    transactions. Usable if both $A$ and $C$ have already published their
    initiator or extend-interval transactions.}
    \label{figure:virtual-layer-merge-intervals-simple}
  \end{figure}
  \addtolength{\intextsep}{15pt}

  After the virtual txs are set up, the parties revoke their previous commitment
  txs. This is achieved by signing the corresponding revocation txs, just like
  for a simple channel.

  \addtolength{\intextsep}{-15pt}
  \begin{figure}
    \centering
    \subimport{./figures/manual-tikz/}{example-start-end-simple.tex}
    \caption{$4$ simple channels supporting a virtual. $A$ starts closing by
    publishing its initiator tx, then $B$--$D$ publish their
    suitable extend-interval. No party stays inactive.
    Virtual outputs are marked with the interval of parties that have
    already published a tx. \emph{Bridge} txs
    like $b$ convert the various virtual outputs into the
    same funding output, as \texttt{ANYPREVOUT} only works across identical
    outputs.}
    \label{figure:example-start-end-simple}
  \end{figure}
  \addtolength{\intextsep}{15pt}

  At last, the virtual layer has been set up: Both $A$ and $E$ can unilaterally
  force the funding output of their virtual channel on-chain, irrespective of
  the actions of the rest of the parties. Likewise, honest intermediaries' funds
  are secure and unilaterally retrievable. $A$ and $E$ finally exchange
  commitment transactions for their new channel, thus concluding its opening.

  Payments over virtual channels are carried out exactly like those of simple
  ones; we refer the reader to the relevant description above.

  Note that all funding outputs use the \texttt{ANYPREVOUT} flag, thus ensuring
  that a single pair of commitment txs can spend any of the funding outputs. If
  \texttt{ANYPREVOUT} were not used, each virtual layer would need a copy of the
  entire set of discussed txs for each possible funding output of its base
  layer, resulting in exponential storage requirements. To make matters worse,
  a payment over channel $C$ would need renegotiation of exponentially many
  commitment txs, as well as recalculation of all their downstream txs, which
  would in turn need interaction with intermediaries of all virtual channels
  built over $C$, completely defeating the essence of payment channels.

  To enhance usability, our protocol allows the virtual channel to be closed
  off-chain, given that all parties cooperate. To do this, the endpoints first
  let the intermediaries know their final virtual channel balance. Then the
  parties of each base channel create new commitment txs for their channels,
  moving the collateral back into the channel: the ``left'' party gets $A$'s
  coins and the ``right'' one gets $E$'s. Thus all intermediaries ``break even''
  across their two channels. Once this is done, all virtual txs are revoked,
  using a logic similar to the revocation procedure of simple channels but
  scaled up to all parties. This is why all virtual tx outputs
  (Figs.~\ref{figure:virtual-layer-endpoint-simple}-\ref{figure:virtual-layer-merge-intervals-simple})
  have a spending method with $A_R \dots E_R$ keys.

  What if one of the parties does not cooperate? Then unilateral, on-chain
  closing must be used. Fig.~\ref{figure:example-start-end-simple} shows how
  this would play out if $A$ initiated this procedure.

  Our protocol is recursive because both simple and virtual channels are
  ultimately represented by a funding output that either is or can be put
  on-chain, therefore new virtual channels can be built on either.

  Both simple and virtual channels avoid key reuse on-chain, thus ensuring party
  privacy against on-chain observers.
