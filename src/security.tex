\section{Security}
  \label{section:security}
  Before providing the UC-based security guarantees, it is useful to obtain
  concrete properties directly from our protocol. We first delineate the
  security guarantees Elmo provides by proving two similar claims regarding the
  conservation of funds in the real and ideal world,
  Lemmas~\ref{lemma:real-balance-security-informal}
  and~\ref{lemma:ideal-balance-informal} respectively. The formal statements
  (\ref{lemma:real-balance-security} and~\ref{lemma:ideal-balance}) along with
  all proofs are deferred
  to Appendix~\ref{sec:proofs}. Informally, the first
  establishes that if an honest, non-negligent party was implicated in a channel
  that has now been unilaterally closed,
  then the party will have at least the expected funds on-chain.

\begin{lemma}[Real world balance security (informal)]
\label{lemma:real-balance-security-informal}
  Consider a real world execution with $P \in \{\alice, \bob\}$ honest,
  non-negligent \textsc{ln} ITI. Assume that all of the following are true:
  \begin{itemize}
    \item $P$ opened the channel, with initial balance $c$,
    \item $P$ is the host of $n$ channels, each funded with $f_i$ coins,
    \item $P$ has cooperatively closed $k$ channels, where the $i$-th channel
    transferred $r_i$ coins from the hosted virtual channel to $P$,
    \item $P$ has sent $m$ payments, each involving $d_i$ coins,
    \item $P$ has received $l$ payments, each involving $e_i$ coins.
  \end{itemize}
  If $P$ closes unilaterally, eventually there will be $h$ outputs on-chain
  spendable only by $P$ or a kindred party, each of value $c_i$, such that
  \begin{equation}
    \sum\limits_{i=1}^h c_i \geq c - \sum\limits_{i=1}^n f_i -
    \sum\limits_{i=1}^m d_i + \sum\limits_{i=1}^l e_i + \sum\limits_{i=1}^k r_i
    \enspace.
  \end{equation}
\end{lemma}

  Lemma~\ref{lemma:ideal-balance-informal} states that for an ideal party in a
  similar situation, the relevant balance stored in \fchan equals the expected
  funds.

\begin{lemma}[Ideal world balance (informal)]
\label{lemma:ideal-balance-informal}
  Consider an ideal world execution with functionality \fchan. Let $P \in
  \{\alice, \bob\}$ one of the two parties of \fchan.
  Assume that all of the following hold:
  \begin{itemize}
    \item $P$ is not corrupted or negligent, nor any member of the
    transitive closure of its hosts has published a revocation transaction,
    \item $P$ opened the channel, with initial balance $c$,
    \item $P$ is the host of $n$ channels, each funded with $f_i$ coins,
    \item $P$ has cooperatively closed $k$ channels, where the $i$-th channel
    transferred $r_i$ coins from the hosted virtual channel to $P$,
    \item $P$ has sent $m$ payments, each involving $d_i$ coins,
    \item $P$ has received $l$ payments, involving $e_i$ coins.
  \end{itemize}
  Let $\texttt{balance}_P$ be the balance that \fchan stores for $P$.
  If the channel is closed (either unilaterally or cooperatively), then the
  following holds with overwhelming probability on the security parameter:
  \begin{equation}
    \texttt{balance}_P = c - \sum\limits_{i=1}^n f_i - \sum\limits_{i=1}^m d_i +
    \sum\limits_{i=1}^l e_i + \sum\limits_{i=1}^k r_i \enspace.
  \end{equation}
\end{lemma}

  In both cases the expected funds are [initial balance - funds for hosted
  virtuals + funds returned from hosted virtuals - outbound payments + inbound
  payments]. Note that the funds for hosted virtuals only refer to those funds
  used by the funder of the virtual channel, not the rest of the base parties.

  Both proofs follow all possible execution paths, keeping track of the
  resulting balance in each case.
  %and coming to the conclusion that balance is
  %secure in all cases, except if signatures are forged.

  It is important to note that in fact \pchan provides a stronger guarantee:
  a party can always unilaterally close its channel
  and obtain the expected funds on-chain within a known number of blocks.
  This stronger guarantee is sufficient to make Elmo reliable
  enough for real-world applications. However an ideal world
  functionality with such guarantees would have to be aware of specific
  txs and signatures, making it as complicated
  as the protocol, thus violating the spirit of the simulation-based security
  paradigm.

  Subsequently we prove Lemma~\ref{lemma:no-halt}, which informally states that
  if an ideal party and all its kindred parties are honest, then \fchan does not
  halt with overwhelming probability.

\begin{lemma}[No halt]
\label{lemma:no-halt}
  In an ideal execution with \fchan and \simulator, if the kindred parties of
  the honest parties of \fchan are themselves honest, then the functionality
  halts with negligible probability in the security parameter (i.e.\
  l.~\ref{code:functionality:close:halt} of Fig.~\ref{code:functionality:close}
  is executed negligibly often).
\end{lemma}

  %This is proven by first arguing that if
  %the conditions of Lemma~\ref{lemma:ideal-balance} for the ideal world hold,
  %then the conditions of Lemma~\ref{lemma:real-balance-security} also hold for
  %the equivalent real world execution, therefore in this case \fchan does not
  %halt. We then argue that also in case the conditions of
  %Lemma~\ref{lemma:ideal-balance} do not hold, \fchan may never halt as well,
  %therefore concluding the proof.

  A salient observation regarding \pchan is that, in order to
  open a virtual channel, it passes inputs to another \pchan instance that
  belongs to a different extended session. This means that \pchan is not
  \emph{subroutine respecting}, as defined in~\cite{uc}. To
  address this issue, we first add a superscript to \pchan, i.e.\
  $\pchansup{n}$. $\pchansup{1}$ is always a simple channel.
  This is done by ignoring instructions to \textsc{open} on top of other
  channels. As for higher superscripts, $\forall n \in
  \mathbb{N}^*, \pchansup{n+1}$ is the same as \pchan but with
  base channels of a maximum superscript $n$. It then holds that $\forall
  n \in \mathbb{N}^*, \pchansup{n}$ is $(\ledger, \pchansup{1}, \dots,
  \pchansup{n-1})$-subroutine respecting, as defined
  in~\cite{DBLP:conf/tcc/BadertscherCHTZ20}. The same superscript trick is done
  to \fchan. To
  the best of the authors' knowledge, this recursion-based proof technique for
  UC security is novel. It is of independent interest and can be reused to prove
  UC security in protocols that may use copies of themselves as subroutines.

  Theorem~\ref{theorem:security:simple} states
  that $\pchansup{1}$ UC-realises $\fchansup{1}$.

\begin{theorem}[Simple Payment Channel Security]
  \label{theorem:security:simple}
  The protocol $\pchansup{1}$ UC-realises $\fchansup{1}$ in the presence of a
  global functionality $\ledger$ and assuming the security of the underlying
  digital signature:
  \begin{gather*}
    \forall \text{ PPT } \adversary, \exists \text{ PPT } \simulator: \forall
    \text{ PPT } \environment \text{ it is }\\
    \textsc{exec}^{\ledger}_{\pchansup{1}, \adversary, \environment} \approx
    \textsc{exec}^{\fchansup{1}, \ledger}_{\simulator, \environment}
  \end{gather*}
\end{theorem}

  The corresponding proof stems from
  Lemma~\ref{lemma:no-halt}, the fact that \fchan is a simple relay and that
  \simulator faithfully simulates \pchan. Lastly we prove that $\forall$
  integers $n \geq 2, \pchansup{n}$ UC-realises $\fchansup{n}$.
  %in the presence of $\fchansup{1}, \dots, \fchansup{n-1}$
  %(leveraging the relevant definition
  %from~\cite{DBLP:conf/tcc/BadertscherCHTZ20}).

\begin{theorem}[Recursive Virtual Payment Channel Security]
  \label{theorem:security:virtual}
  $\forall n \in \mathbb{N}^* \setminus \{1\}$, the protocol $\pchansup{n}$
  UC-realises $\fchansup{n}$ in the presence of $\fchansup{1}, \dots,
  \fchansup{n-1}$ and \ledger, assuming the security of the underlying digital
  signature. Specifically,
  \begin{gather*}
    \forall n \in \mathbb{N}^* \setminus \{1\}, \forall \text{ PPT } \adversary,
    \exists \text{ PPT } \simulator: \forall \text{ PPT } \environment \text{ it
    is } \\
    \textsc{exec}^{\ledger, \fchansup{1}, \dots, \fchansup{n-1}}_{\pchansup{n},
    \adversary, \environment} \approx
    \textsc{exec}^{\fchansup{n}, \ledger}_{\simulator, \environment} \enspace.
  \end{gather*}
\end{theorem}
