\begin{lemma}[Real world balance security]
\label{lemma:real-balance-security}
  Consider a real world execution with $P \in \{\alice, \bob\}$ honest
  \textsc{ln} ITI and $\bar{P}$ the counterparty ITI. Assume that all of the
  following are true:
  \begin{itemize}
    \item the internal variable \texttt{negligent} of $P$ has value ``False'',
    \item $P$ has transitioned to the \textsc{open} \textit{State} for the first
    time after having received $(\textsc{open}, c, \dots)$ by either
    \environment or $\bar{P}$,
    \item $P$ [has received $(\textsc{fund me}, f_i, \dots)$ as input by another
    \textsc{ln} ITI while \textit{State} was \textsc{open} and subsequently $P$
    transitioned to \textsc{open} \textit{State}] $n$ times,
    \item $P$ [has received $(\textsc{pay}, d_i)$ by \environment while
    \textit{State} was \textsc{open} and $P$ subsequently transitioned to
    \textsc{open} \textit{State}] $m$ times,
    \item $P$ [has received $(\textsc{get paid}, e_i)$ by \environment while
    \textit{State} was \textsc{open} and $P$ subsequently transitioned to
    \textsc{open} \textit{State}] $l$ times.
  \end{itemize}
  Let $\phi = 1$ if $P = \alice$, or $\phi = 0$ if $P = \bob$. If $P$ receives
  $(\textsc{close})$ by \environment and, if $\texttt{host}_P \neq \ledger$
  the output of $\texttt{host}_P$ is (\textsc{closed}), then eventually the
  state obtained when $P$ inputs $(\textsc{read})$ to \ledger will contain $h$
  $(c_i, \pk{P, \mathrm{out}})$ outputs such that
  \begin{equation}
  \label{lemma:real-balance-security:ineq}
    \sum\limits_{i=1}^h c_i \geq \phi \cdot c - \sum\limits_{i=1}^n f_i -
    \sum\limits_{i=1}^m d_i + \sum\limits_{i=1}^l e_i \enspace
  \end{equation}
  with overwhelming probability in the security parameter.
\end{lemma}

\begin{proof}
  Define the \emph{history} of a channel as follows: $H = (F, C)$, where each of
  $F, C$ is a list of lists of integers. A party $P$ which satisfies the Lemma
  conditions has a unique, unambiguously and recursively defined history: If the
  value \texttt{hops} in the (\textsc{open}, $c$, $\dots$) message was equal to
  \ledger, then $F$ is the empty list, otherwise $F$ is the concatenation of the
  $F$ and $C$ lists of the party that sent (\textsc{funded}, $\dots$) to $P$, as
  they were at the moment the latter message was sent. After initialised, $F$
  remains immutable. Observe that both aforementioned messages must have been
  received before $P$ transitions to the \textsc{open} state.

  The list $C$ of party $P$ is initialised to $[[g]]$ when $P$'s $\itistate$
  transitions for the first time to \textsc{open}, where $g = c$ if $P =
  \alice$, or $g = 0$ if $P = \bob$; this represents the initial channel
  balance. The value $x$ or $-x$ is appended to the last list in $C$ when
  l.~\ref{code:ln:pay:revocations:paid-in} or
  l.~\ref{code:ln:pay:revocations:paid-out} of
  Fig.~\ref{code:ln:pay:revocations} respectively is executed by $P$; this
  represents the balance change after each payment. Moving on to the funding of
  new virtual channels, whenever $P$ executes
  l.~\ref{code:ln:virtualise:start-end:reduce-coins} of
  Fig.~\ref{code:ln:virtualise:start-end} (therefore funding a new virtual
  channel), $[-c_{\mathrm{guest}}]$ is appended to $C$ and whenever
  l.~\ref{code:ln:virtualise:start-end:reply} of
  Fig.~\ref{code:ln:virtualise:start-end} is executed (in which case $P$ helps
  with the opening of a new virutal channel, but does not fund it), $[0]$ is
  appended to $C$. Therefore $C$ consists of one list of integers for each
  sequence of inbound and outbound payments that have not been interrupted by a
  virtualisation step and a new list is added for every new virtual layer. We
  also observe that a non-negligent party with history $(F, C)$ satisfies the
  Lemma conditions and that the value of the right hand side of the
  inequality~\ref{lemma:real-balance-security:ineq} is equal to
  $\sum\limits_{i=1}^h c_i \geq \sum\limits_{s \in C} \sum\limits_{i \in s} i$.

  Let party $P$ with a particular history. We will inductively prove that $P$
  satisfies the Lemma. The base case is when a channel is opened with
  $\texttt{hops} = \ledger$ and is closed right away, therefore $H = ([], [g])$,
  where $g = c$ if $P = \alice$ and $g = 0$ if $P = \bob$.  $P$ can transition
  to the \textsc{open} \textit{State} for the first time only if all of the
  following have taken place:
  \begin{itemize}
    \item It has received (\textsc{open}, $c$, $\dots$) while in the
    \textsc{init} \textit{State}. In case $P = \alice$, this message must have
    been received as input by \environment (Fig.~\ref{code:ln:open},
    l.~\ref{code:ln:open:alice-open}), or in case $P = \bob$, this message must
    have been received via the network by $\bar{P}$
    (Fig.~\ref{code:ln:exchange-open-keys},
    l.~\ref{code:ln:exchange-open-keys:bob-open}).
    \item It has received $\pk{\bar{P}, F}$. In case $P = \bob$, $\pk{\bar{P},
    F}$ must have been contained in the (\textsc{open}, $\dots$) message by
    $\bar{P}$ (Fig.~\ref{code:ln:exchange-open-keys},
    l.~\ref{code:ln:exchange-open-keys:bob-open}), otherwise if $P = \alice$
    $\pk{\bar{P}, F}$ must have been contained in the (\textsc{accept channel},
    $\dots$) message by $\bar{P}$ (Fig.~\ref{code:ln:exchange-open-keys},
    l.~\ref{code:ln:exchange-open-keys:accept-channel}).
    \item It internally holds a signature on the commitment transaction $C_{P,
    0}$ that is valid when verified with public key $\pk{\bar{P}, F}$
    (Fig.~\ref{code:ln:exchange-open-sigs},
    ll.~\ref{code:ln:exchange-open-sigs:b-verify}
    and~\ref{code:ln:exchange-open-sigs:a-verify}).
    \item It has the transaction $F$ in the \ledger state
    (Fig.~\ref{code:ln:commit-base}, l.~\ref{code:ln:commit-base:f-in-state} or
    Fig.~\ref{code:ln:bob}, l.~\ref{code:ln:bob:state-open}).
  \end{itemize}

  We observe that $P$ satisfies the Lemma conditions with $m = n = l = 0$.
  Before transitioning to the \textsc{open} \textit{State}, $P$ has produced
  only one valid signature for the output $(c, 2/\{\pk{P, F}, \pk{\bar{P},
  F}\})$ of $F$ with $\sk{P, F}$, namely for $C_{\bar{P}, 0}$
  (Fig.~\ref{code:ln:exchange-open-sigs},
  ll.~\ref{code:ln:exchange-open-sigs:a-sign}
  or~\ref{code:ln:exchange-open-sigs:b-sign}), and sent it to $\bar{P}$
  (Fig.~\ref{code:ln:exchange-open-sigs},
  ll.~\ref{code:ln:exchange-open-sigs:a-send}
  or~\ref{code:ln:exchange-open-sigs:b-send}), therefore the only two ways to
  spend $(c, 2/\{\pk{P, F}, \pk{\bar{P}, F}\})$ are by either publishing $C_{P,
  0}$ or $C_{\bar{P}, 0}$. We observe that $C_{P, 0}$ has a ($g$, ($\pk{P,
  \mathrm{out}} + (t + s)$) $\vee$ $2/\{\pk{P, R}, \pk{\bar{P}, R}\}$) output
  (Fig.~\ref{code:ln:exchange-open-sigs},
  l.~\ref{code:ln:exchange-open-sigs:a-tx}
  or~\ref{code:ln:exchange-open-sigs:b-tx}). The spending method $2/\{\pk{P, R},
  \pk{\bar{P}, R}\}$ cannot be used since $P$ has not produced a signature for
  it with $\sk{P, R}$, therefore the alternative spending method, $\pk{P,
  \mathrm{out}} + (t + s)$, is the only one that will be spendable if $C_{P, 0}$
  is included in \ledger, thus contributing $g$ to the sum of outputs that
  contribute to inequality~\ref{lemma:real-balance-security:ineq}. Likewise, if
  $C_{\bar{P}, 0}$ is included in \ledger, it will contribute at least one ($g$,
  $\pk{P, \mathrm{out}}$) output to this inequality, as $C_{\bar{P}, 0}$ has a
  ($g$, $\pk{P, \mathrm{out}}$) output (Fig.~\ref{code:ln:exchange-open-sigs},
  l.~\ref{code:ln:exchange-open-sigs:a-tx}
  or~\ref{code:ln:exchange-open-sigs:b-tx}). Additionally, if $P$ receives
  (\textsc{close}) by \environment while $H = ([], [g])$, it attempts to publish
  $C_{P, 0}$ (Fig.~\ref{code:ln:close}, l.~\ref{code:ln:close:submit}), and will
  either succeed or $C_{\bar{P}, 0}$ will be published instead. We therefore
  conclude that in every case \ledger will eventually have a state $\Sigma$ that
  contains at least one $(g, \pk{P, \mathrm{out}})$ output with overwhelming
  probability (as a signature forgery may happen only with negligible
  probability), therefore satisfying the Lemma consequence.

  Let $P$ with history $H = (F, C)$. The induction hypothesis is that the Lemma
  holds for $P$. In order to perform the induction step, assume that $P$ is in
  the \textsc{open} state. We will prove all the following (the facts to be
  proven are shown with emphasis for clarity):
  \begin{itemize}
    \item If $P$ receives (\textsc{fund me}, $f$, $\dots$) by a (local, trusted)
    \textsc{ln} ITI $R$, subsequently transitions back to the \textsc{open}
    state (therefore moving to history $(F, C')$ where $C'$ is $C + [-f]$) and
    finally receives (\textsc{close}) by \environment and (\textsc{closed}) by
    $\texttt{host}_P$ before any further change to its history, then
    \emph{eventually $P$'s \ledger state will contain $h$ $(c_i, \pk{P,
    \mathrm{out}})$ transaction outputs such that $\sum\limits_{i=1}^h c_i \geq
    \sum\limits_{s \in C} \sum\limits_{x \in s} x$}. Furthermore, given that $P$
    moves to the \textsc{open} state after the (\textsc{fund me}, $\dots$)
    message, it also sends (\textsc{funded}, $\dots$) to  $R$
    (Fig.~\ref{code:ln:virtualise:start-end},
    l.~\ref{code:ln:virtualise:start-end:funder-funded}). If subsequently the
    state of $R$ transitions to \textsc{open} (therefore obtaining history
    $(F_R, C_R)$ where $F_R = F + C$ and $C_R = [[f]]$), and finally receives
    (\textsc{close}) by \environment and (\textsc{closed}) by $\texttt{host}_R$
    ($\texttt{host}_R = \texttt{host}_P$ -- Fig.~\ref{code:ln:bob},
    l.~\ref{code:ln:bob:host}) before any further change to its history, then
    \emph{eventually $R$'s \ledger state will contain $k$ $(c^R_i, \pk{R,
    \mathrm{out}})$ transaction outputs such that $\sum\limits_{i=1}^k c^R_i
    \geq \sum\limits_{s \in C_R} \sum\limits_{x \in s} x$}.
    \item If $P$ receives (\textsc{virtualise}, $\dots$) by an \textsc{ln} ITI
    $R$, subsequently transitions back to \textsc{open} (therefore moving to
    history $(F, C')$ where $C'$ is $C + [0]$) and finally receives
    \textsc{close} by \environment and (\textsc{closed}) by $\texttt{host}_P$
    before any further change to its history, then \emph{eventually $P$'s
    \ledger state will contain $h$ $(c_i, \pk{P, \mathrm{out}})$ transaction
    outputs such that $\sum\limits_{i=1}^h c_i \geq \sum\limits_{s \in C}
    \sum\limits_{i \in s} i$}. Furthermore, given that $P$ moves to the
    \textsc{open} state after the (\textsc{virtualise}, $\dots$) message and in
    case it sends (\textsc{funded}, $\dots$) to some party $R$
    (Fig.~\ref{code:ln:virtualise:start-end},
    l.~\ref{code:ln:virtualise:start-end:helper-output-funded}), the latter
    party is the (local, trusted) \texttt{fundee} of a new virtual channel. If
    subsequently the state of $R$ transitions to \textsc{open} (therefore
    obtaining history $(F_R, C_R)$ where $F_R = F + C$ and $C_R = [[0]]$), and
    finally receives (\textsc{close}) by \environment and (\textsc{closed}) by
    $\texttt{host}_R$ ($\texttt{host}_R = \texttt{host}_P$ --
    Fig.~\ref{code:ln:bob}, l.~\ref{code:ln:bob:host}) before any further change
    to its history, then \emph{eventually $R$'s \ledger state will contain $k$
    $(c^R_i, \pk{R, \mathrm{out}})$ transaction outputs such that
    $\sum\limits_{i=1}^k c^R_i \geq \sum\limits_{s \in C_R} \sum\limits_{x \in
    s} x$}.
    \item If $P$ receives (\textsc{pay}, $d$) by \environment, subsequently
    transitions back to \textsc{open} (therefore moving to history $(F, C')$
    where $C'$ is $C$ with $-d$ appended to the last list of $C$) and finally
    receives \textsc{close} by \environment and (\textsc{closed}) by
    $\texttt{host}_P$ before any further change to its history, then
    \emph{eventually $P$'s \ledger state will contain $h$ $(c_i, \pk{P,
    \mathrm{out}})$ transaction outputs such that $\sum\limits_{i=1}^h c_i \geq
    \sum\limits_{s \in C} \sum\limits_{i \in s} i$}. \item If $P$ receives
    (\textsc{get paid}, $e$) by \environment, subsequently transitions back to
    \textsc{open} (therefore moving to history $(F, C')$ where $C'$ is $C$ with
    $e$ appended to the last list of $C$) and finally receives \textsc{close} by
    \environment and (\textsc{closed}) by $\texttt{host}_P$ before any further
    change to its history, then \emph{eventually $P$'s \ledger state will
    contain $h$ $(c_i, \pk{P, \mathrm{out}})$ transaction outputs such that
    $\sum\limits_{i=1}^h c_i \geq \sum\limits_{s \in C} \sum\limits_{i \in s}
    i$}.
  \end{itemize}
\end{proof}

%\begin{proof}
%    Else if $\texttt{hops} \neq \ledger$, $P$ is able to cause an eventual
%    inclusion of a transaction with output $(c, 2/\{\pk{P, F}, \pk{\bar{P} ,
%    F}\})$ in the \ledger state by passing input (\textsc{close}) to
%    $\texttt{host}_P$ that results in $\texttt{host}_P$ outputting
%    (\textsc{closed}) -- we only examine the case where this output is indeed
%    given, as stipulated in the Lemma conditions.  The eventual transaction
%    output inclusion in \ledger is guaranteed due to the following:
%    \texttt{hops}[0].\texttt{left} (when $P = \alice$,
%    Fig.~\ref{code:ln:prepare-base}, l.~\ref{code:ln:prepare-base:fund-me}) or
%    \texttt{hops}[-1].\texttt{right} (when $P = \bob$, Fig.~\ref{code:ln:bob},
%    l.~\ref{code:ln:bob:funded}) has passed output (\textsc{funded}, $\dots$) to
%    $P$, as this party is trusted (as it executes locally) and has itself been
%    passed output (\textsc{hosts ready}) by its (also trusted) $\texttt{host}$
%    \textsc{virt} ITI (Fig.~\ref{code:ln:virtualise:start-end},
%    l.~\ref{code:ln:virtualise:start-end:hosts-ready}). The \texttt{host} only
%    outputs (\textsc{hosts ready}) when its \texttt{guest} (which is the
%    aforementioned party that outputs (\textsc{funded}, $\dots$)) verifies that
%    the remote revocation of the previous commitment transaction has happened
%    correctly (Fig.~\ref{code:virtual-layer:revocation},
%    ll.~\ref{code:virtual-layer:revocation:non-funder:proc-remote}
%    or~\ref{code:virtual-layer:revocation:funder:proc-remote}). Furthermore,
%    $\texttt{host}_P$ only outputs (\textsc{closed}) if there exists a suitable
%    transation output in \ledger (Fig.~\ref{code:virtual-layer:close},
%    l.~\ref{code:virtual-layer:close:when-closed}). If $\texttt{host}_P$ was
%    prompted to closure by $P$, then this transaction output is the desired one.
%    If $\texttt{host}_P$ hosts a party of another channel and that party
%    prompted a closure the desired transaction output will end up in \ledger as
%    well. The reason for that is because the only way any of the aforementioned
%    party can close honestly its channel is by publishing its copy of the only
%    valid transaction as per Fig.~\ref{code:virtual-layer:close},
%    l.~\ref{code:virtual-layer:close:tx}, which is the exact same transaction
%    that would be published had $P$ closed first. Since $P$ belongs to a newly
%    opened channel, there exist five different valid transactions that include
%    the desired output: $\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$ held by
%    $\texttt{host}_P$ (Fig.~\ref{code:virtual-layer:fundee-sigs},
%    l.~\ref{code:virtual-layer:fundee-sigs:tx-none} if $P$ is fundee,
%    Fig.~\ref{code:virtual-layer:funder-sigs},
%    l.~\ref{code:virtual-layer:funder-sigs:tx-none} if $P$ is funder) and
%    $\mathrm{TX}_{\mathrm{prev}, \mathrm{none}}$, $\mathrm{TX}_{\mathrm{prev},
%    \mathrm{left}}$, $\mathrm{TX}_{\mathrm{prev}, \mathrm{right}}$,
%    $\mathrm{TX}_{\mathrm{prev}, \mathrm{both}}$ if $P$ is fundee or
%    $\mathrm{TX}_{\mathrm{next}, \mathrm{none}}$, $\mathrm{TX}_{\mathrm{next},
%    \mathrm{left}}$, $\mathrm{TX}_{\mathrm{next}, \mathrm{right}}$,
%    $\mathrm{TX}_{\mathrm{next}, \mathrm{both}}$ if $P$ is funder, held by
%    $\texttt{host}_{\bar{P}}$ (Fig.~\ref{code:virtual-layer:intermediary-sigs}).
%    We will here refer to the subscripts ``prev''/``next'' as ``other'' for
%    simplicity.  All valid combinations of these transactions in \ledger (only
%    $\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$, only
%    $\mathrm{TX}_{\mathrm{other}, \mathrm{none}}$, only
%    $\mathrm{TX}_{\mathrm{other}, \mathrm{right}}$, $\mathrm{TX}_{\mathrm{loc},
%    \mathrm{none}}$ and $\mathrm{TX}_{\mathrm{other}, \mathrm{left}}$, or
%    $\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$ and
%    $\mathrm{TX}_{\mathrm{other}, \mathrm{both}}$) eventually result in exactly
%    one output of interest in \ledger. Any other transaction that has the same
%    input as $\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$ is revoked before the
%    output (\textsc{funded}, $\dots$) to $P$ and therefore having any of these
%    transactions published instead would violate the aforementioned Lemma
%    condition.
%  \end{itemize}
%  Given that all of the aforementioned are true, before transitioning to the
%  \textsc{open} \textit{State}, $P$ has produced and sent only one valid signature for
%  the $(c, 2/\{\pk{P, F}, \pk{\bar{P}, F}\})$ output with $\sk{P, F}$, namely
%  for $C_{\bar{P}, 0}$ (Fig.~\ref{code:ln:exchange-open-sigs},
%  ll.~\ref{code:ln:exchange-open-sigs:a-sign}
%  or~\ref{code:ln:exchange-open-sigs:b-sign}), and sent it to $\bar{P}$
%  (Fig.~\ref{code:ln:exchange-open-sigs},
%  ll.~\ref{code:ln:exchange-open-sigs:a-send}
%  or~\ref{code:ln:exchange-open-sigs:b-send}), therefore the unique two ways to
%  spend $(c, 2/\{\pk{P, F}, \pk{\bar{P}, F}\})$ are by either publishing $C_{P,
%  0}$ or $C_{\bar{P}, 0}$. We observe that $C_{P, 0}$ has a ($g$, ($\pk{P,
%  \mathrm{out}} + (t + s)$) $\vee$ $2/\{\pk{P, R}, \pk{\bar{P}, R}\}$) output,
%  where $g = c$ if $P = \alice$ and $g = 0$ if $P = \bob$
%  (Fig.~\ref{code:ln:exchange-open-sigs},
%  l.~\ref{code:ln:exchange-open-sigs:a-tx}
%  or~\ref{code:ln:exchange-open-sigs:b-tx}). Since we assume $P$ is honest, it
%  will never give the opportunity for the spending method $2/\{\pk{P, R},
%  \pk{\bar{P}, R}\}$ to be used (as this corresponds to publishing a revoked
%  transaction), therefore the alternative spending method, $\pk{P, \mathrm{out}}
%  + (t + s)$, is the only one that will be spendable if $C_{P, 0}$ is included
%  in \ledger, therefore contributing $g$ to the sum of outputs that contribute
%  to inequality~\ref{lemma:real-balance-security:ineq}.  Likewise, if
%  $C_{\bar{P}, 0}$ is included in \ledger, it will contribute at least one ($g$,
%  $\pk{P, \mathrm{out}}$) output to this inequality, as $C_{\bar{P}, 0}$ has a
%  ($g$, $\pk{P, \mathrm{out}}$) output (Fig.~\ref{code:ln:exchange-open-sigs},
%  l.~\ref{code:ln:exchange-open-sigs:a-tx}
%  or~\ref{code:ln:exchange-open-sigs:b-tx}). We also observe that, if $n = m = l
%  = 0$, then the Lemma holds.
%
%    %sibling common tx justification
%    , or if $\texttt{host}_P$ has a \texttt{sibling} and the latter prompted a
%    closure,%
%    In particular for the case of \texttt{sibling}s, neither of the two
%    siblings outputs \textsc{hosts ready} before it knows that both their
%    counterparties have revoked properly
%    (Fig.~\ref{code:virtual-layer:revocation}).%
%    and the only valid transaction of each counterparty is one of
%    $\mathrm{TX}_{\mathrm{prev}, \mathrm{none}}$, $\mathrm{TX}_{\mathrm{prev},
%    \mathrm{left}}$, $\mathrm{TX}_{\mathrm{prev}, \mathrm{right}}$,
%    $\mathrm{TX}_{\mathrm{prev}, \mathrm{both}}$ if the counterparty is closer
%    than the local party to the fundee or $\mathrm{TX}_{\mathrm{next},
%    \mathrm{none}}$, $\mathrm{TX}_{\mathrm{next}, \mathrm{left}}$,
%    $\mathrm{TX}_{\mathrm{next}, \mathrm{right}}$, $\mathrm{TX}_{\mathrm{next},
%    \mathrm{both}}$ if the counterparty is closer than the local party to the
%    funder and all these transactions contain the output of interest.%
%\end{proof}
