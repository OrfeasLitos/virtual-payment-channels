\section{Preliminaries}

  \subsection{\ledger Functionality}
  In this work we embrace the Universal Composition (UC) framework~\cite{uc}
  together with its global subroutines extension,
  UCGS~\cite{DBLP:conf/tcc/BadertscherCHTZ20}, to
  model parties, network interactions, adversarial influence and corruptions, as
  well as formalise and prove security. We choose to model the Bitcoin ledger
  with the \ledger
  functionality as defined in~\cite{BMTZ17} and further refined
  in~\cite{genesis}. \ledger formalizes an ideal data structure that is
  distributed and append-only, akin to a blockchain. Participants can read from
  \ledger, which returns an ordered list of transactions. Additionally a party
  can submit a new transaction which, if valid, will eventually be added to the
  ledger when the adversary decides, but necessarily within a predefined time
  window. This property is named liveness. Once a transaction becomes part of
  the ledger, it then becomes visible to all parties at the discretion of the
  adversary, but necessarily within another predefined time window, and it
  cannot be reordered or removed. This is named persistence.

  Moreover, \ledger needs the \Fclock
  functionality~\cite{DBLP:conf/tcc/KatzMTZ13}, which models the notion of time.
  Any \Fclock participant can request to read the current time (which is
  initially 0) and inform \Fclock that her round is over. \Fclock increments the
  time by one once all parties have declared the end of their round. We further note that both
  \ledger and \Fclock are global
  functionalities~\cite{DBLP:conf/tcc/BadertscherCHTZ20} and therefore can be
  accessed directly by the environment.

  \subsection{Modelling time}
  The protocol and functionality defined in this work do not use \Fclock
  directly. Indeed, the only notion of time in our work is provided by the
  blockchain height, as reported by \ledger. We therefore omit it in the
  statement of our lemmas and theorems for simplicity of notation; it should
  normally appear as a hybrid together with \ledger.

  Our protocol is fully asynchronous, i.e., the adversary can delay any network
  message arbitrarily long. The protocol is robust against such delays, as an
  honest party can unilaterally prevent loss of funds even if some of its
  incoming and outgoing network messages are dropped by \adversary, as long as
  the party has input-output communication with the ledger. We also note that,
  following the conventions of single-threaded UC execution model, the duration of local
  computation is not taken into account in any way (as long as it does not
  exceed its polynomial bound).
