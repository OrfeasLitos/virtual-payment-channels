\begin{figure}[H]
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State \textsc{fund}($c$, \texttt{hops}, (\texttt{funder},
      \texttt{fundee}), (\texttt{host\_funder}, \texttt{host\_fundee}),
      \textsc{pcn}, \textit{vid}):
      \Indent
        \State \TODO{do VChan() with hops -- $P_{i-1} P_i, P_i P_{i+1}$ and all
        $P_1 P_n$ held by BOTH $R_{i-1}$ and $L_i$. $P_{i-1} P_i$ held only by
        $R_{i-1}$, $P_i P_{i+1}$ held only by $L_i$. This (probably) ensures
        that only relevant parties can close their channels (with the exception
        of honest $R_{i-1}$ wanting to leave channels virtual but corrupted
        $L_i$ demoting them to base, which however doesn't cost funds to
        anyone), but that they have minimal impact to the decisions of ajdacent
        channels. All $P_{i-1} P_i$ inputs must be signed by $R_{i-1}$ and all
        $P_i P_{i+1}$ inputs by $L_i$.}
      \EndIndent
      \State ensure \texttt{host\_funder} = \alice \: \Comment{we are hosting
      the funder}
      \State $(pk_{A, V}, pk_{B, V}) \gets$ \textsc{pcn.virtualKeys}($c$,
      \texttt{fundee}, \texttt{host\_funder}, \texttt{host\_fundee})
      \State $(pk_{i, V})_{i \in [n]} \gets$ \textsc{virt.hostKeys}($c$,
      \texttt{hops})
      \State $(T_{i,j})_{i \in [n], j \in [n+2]} \gets$
      \textsc{virt.getTXs}($c$, $pk_{A, V}$, $pk_{B, V}$, $(pk_{i, V})_i$)
      \Comment{for $i \in \{1, n\}$, $j$ can only be equal to $1$}
      \State ensure \textsc{pcn.openVirtual}($(T_{i, j})_{i, j}$) returns
      (\textsc{ok})
      \If{real world}
        \State $\texttt{old\_state} \gets \textit{State}$
        \State $\mathit{State} \gets \textsc{updating}$
        \State send (\textsc{fund}, $c$, \texttt{hops}, \texttt{fundee},
        \texttt{virtual\_output}, \texttt{sigs}, \textit{vid}) to
        \texttt{hops}$[1]$ \Comment{\texttt{hops} is 0-indexed,
        \texttt{hops}$[0]$ = \alice}
        \While{\remotecode{we are not the last hop}}
          \State \remotecode{$(L, M, R) \gets$ (previous hop, current hop, next
          hop)}
          \State \remotecode{$(T_{i,j})_{i \in [n], j \in [n+2]} \gets$
          \textsc{virt.getTXs}($c$, $pk_{A, V}$, $pk_{B, V}$, $(pk_{i, V})_i$)}
          \State \TODO{\remotecode{verify all received signatures on their
          relevant TXs}}
          \State \remotecode{$\texttt{old\_state} \gets \textit{State}$}
          \State \remotecode{$\mathit{State} \gets \textsc{updating}$}
          \State \TODO{\remotecode{delegate to sibling channel (with $R$)}}
          \State \remotecode{$(T_{i,j})_{i \in [n], j \in [n+2]} \gets$
          \textsc{virt.getTXs}($c$, $pk_{A, V}$, $pk_{B, V}$, $(pk_{i, V})_i$)}
          \State \TODO{\remotecode{create necessary signatures}}
          \State \remotecode{$\mathit{State} \gets \textsc{updating}$}
          \State \remotecode{send (\textsc{fund}, $c$, \texttt{hops},
          \texttt{fundee}, \texttt{sigs}, \textit{vid}) to $R$}
        \EndWhile
        \State \remotecode{ensure we are the last hop in \texttt{hops} and that
        the previous hop is the sender}
        \State \remotecode{$(L, M) \gets$ (previous hop, current hop)}
        \State \remotecode{$(T_{i,j})_{i \in [n], j \in [n+2]} \gets$
        \textsc{virt.getTXs}($c$, $pk_{A, V}$, $pk_{B, V}$, $(pk_{i, V})_i$)}
        \State \TODO{\remotecode{verify all received signatures on their
        relevant TXs}}
        \State \TODO{\remotecode{maybe delegate to \texttt{fundee} to do more
        checks and/or ask \environment}}
        \State \TODO{\remotecode{create signatures for remote TXs and sign
        revocation(s) of old channel version}}
        \State \remotecode{$\textit{State} \gets \texttt{old\_state}$}
        \State \TODO{\remotecode{send new version remote sigs and old version
        revocation sigs to sender}}
        \While{\remotecode{we are not the first hop}}
          \State \remotecode{ensure \textit{State} = \textsc{updating}}
          \State \TODO{\remotecode{verify received sigs on local TXs (both for
          new and for revoked versions)}}
          \State \TODO{\remotecode{update store of supported virtual channels as
          needed}}
          \State \remotecode{$\textit{State} \gets \texttt{old\_state}$}
          \State \TODO{\remotecode{delegate to sibling channel (with previous
          hop)}}
          \State \TODO{\remotecode{create signatures for remote TXs  and sign
          revocation(s) of old channel version}}
          \State \remotecode{$\textit{State} \gets \texttt{old\_state}$}
          \State \TODO{\remotecode{send new version remote sigs and old version
          revocation sigs to $L$}}
        \EndWhile
        \State ensure \textit{State} = \textsc{updating}
        \State \TODO{verify received sigs on local TXs (both for new and for
        revoked versions)}
        \State \remotecode{$\textit{State} \gets \texttt{old\_state}$}
        \State \TODO{update store of supported virtual channels as needed}
        \State \Return (\textsc{ok})
      \Else \: \Comment{ideal world}
        \State \TODO{similar to real world, but do locally (and avoid
        verification) series of honest players interleaved with \adversary
        notifications, whereas require \adversary to just inform of the
        successful hopping of a series of malicious players in one message}
      \EndIf
      \TODO{expect reply from next hop with all signatures needed for next comm
      TX and the revocation sig of the previous comm TX. While waiting, ignore
      everything else apart from channel closing. Mark virtual channel as open.
      Send to next hop the revocation sig.}
      \State
      \TODO{Add logic for intermediaries and fundee}
      \Statex

      \State \textsc{close}($P$):
        \TODO{continue}
        \TODO{handle arbitrarily nested virtuals (now we only handle one level
        and it leads to nested ifs}
        \If{both channel parties are honest}
          \If{$\mathtt{funded} \neq \emptyset$}
            \State \TODO{prepare virtual layer TX $V$ and its signature --
            careful, may be unneded!}
            \State $C \gets$ TX \{input: $V$.output, outputs: $(c_A, pk_{A,
            \mathrm{out}} \wedge t), (c_B, pk_{B, \mathrm{out}})$\}
            \State $\mathrm{sig}_{B, C} \gets \textsc{sign}(C, sk_{B, V})$
            \State $\mathrm{sig}_{A, C} \gets \textsc{sign}(C, sk_{A, V})$
          \Else
            \State $C \gets$ TX \{input: $F$.output, outputs: $(c_A, pk_{A,
            \mathrm{out}} \wedge t), (c_B, pk_{B, \mathrm{out}})$\}
            \State $\mathrm{sig}_{B, C} \gets \textsc{sign}(C, sk_{B, F})$
            \State $\mathrm{sig}_{A, C} \gets \textsc{sign}(C, sk_{A, F})$
          \EndIf
        \EndIf \: \Comment{if \bob is corrupted, we already have $C$ and
        $\mathrm{sig}_{B, C}$}
        \State $\mathit{State} \gets \textsc{closed}$
        \If{$\mathit{State} = \textsc{open base}$}
          \State input (\textsc{submit}, $(V, \mathrm{sig}_{A, V},
          \mathrm{sig}_{B, V})$, $(C, \mathrm{sig}_{A, C}, \mathrm{sig}_{B,
          C})$) to \ledger
        \Else \: \Comment{$\mathit{State} = \textsc{open virtual}$}
          \If{\alice is the one that had received (\textsc{open virtual}, $\dots$)
          by \texttt{opener}}
            \State $\texttt{initiator} \gets \texttt{opener}$; $\texttt{other}
            \gets \texttt{outer\_peer}$
          \Else \: \Comment{\bob had received (\textsc{open virtual} $\dots$)}
            \State $\texttt{initiator} \gets \texttt{outer\_peer}$;
            $\texttt{other} \gets \texttt{opener}$
          \EndIf
          \If{both parties are honest}
            \If{$\texttt{funded} \neq \emptyset$}
              \State \TODO{prepare virtual layer TXs $V_A, V_B$ and their
              signatures}
              \State $C' \gets$ TX \{input: $V$.output, outputs: $(c_A, pk_{A,
              \mathrm{out}}), (c_B, pk_{B, \mathrm{out}} \wedge t)$\}
              \State $\mathrm{sig}_{A, C}' \gets \textsc{sign}(C', sk_{A, V})$;
              $\mathrm{sig}_{B, C}' \gets \textsc{sign}(C', sk_{B, V})$
            \Else \: \Comment{there are no virtual channels on top of us}
              \State $C' \gets$ TX \{input: $F$.output, outputs: $(c_A, pk_{A,
              \mathrm{out}}), (c_B, pk_{B, \mathrm{out}} \wedge t)$\}
              \State $\mathrm{sig}_{A, C}' \gets \textsc{sign}(C', sk_{A, F})$;
              $\mathrm{sig}_{B, C}' \gets \textsc{sign}(C', sk_{B, F})$
            \EndIf
            \State provide delayed output (\textsc{peer closed virtual}, $(V_B,
            \mathrm{sig}_{A, V_B}, \mathrm{sig}_{B, V_B})$, $(C',
            \mathrm{sig}_{A, C}', \mathrm{sig}_{B, C}')$) to \texttt{other} as
            \bob
          \EndIf
          \If{$\mathtt{funded} \neq \emptyset$}
            \State $\mathtt{output} \gets (\textsc{closed virtual}, (V,
            \mathrm{sig}_{A, V}, \mathrm{sig}_{B, V}), (C, \mathrm{sig}_{A, C},
            \mathrm{sig}_{B, C}))$
          \Else
            \State $\mathtt{output} \gets (\textsc{closed virtual}, (C,
            \mathrm{sig}_{A, C}, \mathrm{sig}_{B, C}))$
          \EndIf
          \State output \texttt{output} to \texttt{initiator} as \alice
        \EndIf
        \Statex

        \State \textsc{closed}($c_L$, $c_R$, $(\mathrm{tx}_i,
        (\sigma_{ij})_j)_i$):
        \Indent
          \ForAll{$i$ in $1 \dots |(\mathrm{tx}_i, (\sigma_{ij})_j)_i|$}
            \State ensure \textsc{verify}($\mathrm{tx}_i$, $(\sigma_{ij})_j$) =
            True
          \EndFor
          \State ensure ($\mathrm{tx}_1$, $(\sigma_{1j})_j$) has exactly $1$
          input, which spends an output of $V$ of value $c_L + c_R$
          \State return (\textsc{ok})
        \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt} -- utils}
    \begin{algorithmic}[1]
      \State \textsc{hostKeys}(\texttt{hops}): \Comment{can be implemented with
      \alice as leader or with 2 direct messages between all hops ($O(n^2)$)}
      \TODO{decide if we need to move to \textsc{updating} state here}
      \Indent
        \For{$i$ from $1$ to $n$} \Comment{one iteration executed by each hop}
          \If{$i \neq 1$}
            \State ensure $\texttt{hops}[i-1] =$ sender $\wedge \texttt{hops}[i]
            =$ self
          \EndIf
          \State $(sk_{i, V}, pk_{i, V}) \gets \textsc{keyGen}()$
          \If{real world}
            \State send (\textsc{hostKeysForward}, \texttt{hops}, $(pk_{j, V})_{j
            \in \{1, \dots, i\}}$) to \texttt{hops}[$i+1$]
          \Else \: \Comment{ideal world}
            \If{\texttt{hops}[$i+1$] is honest}
              \State send (\textsc{hostKeysForward}, \texttt{hops}, $(pk_{j,
              V})_{j \in \{1, \dots, i\}}$, \texttt{hops}[$i+1$]) to \adversary,
              expecting reply (\textsc{ok})
            \Else \: \Comment{\texttt{hops}[$i+1$] is corrupted}
              \State send (\textsc{hostKeysForward}, \texttt{hops}, $(pk_{j,
              V})_{j \in \{1, \dots, i\}}$, \texttt{hops}[$i+1$]) to \adversary,
              expecting reply (\textsc{hostKeysForward}, \texttt{hops}, $(pk_{j,
              V})_{j \in \{1, \dots, k-1\}}$, \texttt{hops}[$k$]) where
              \texttt{hops}[$k$] is the first honest hop after
              \texttt{hops}[$i+1$], or no response if there is no such hop
            \EndIf
          \EndIf
        \EndFor \: \Comment{control is at \texttt{host\_fundee}}
        \For{$i$ from $n$ down to $1$} \Comment{one iteration executed by each hop}
          \If{$i \neq n$}
            \State ensure \texttt{hops} is the same as in the previous ``for''
            loop
          \EndIf
          \If{real world}
            \State send (\textsc{hostKeysBackward}, \texttt{hops}, $(pk_{j,
            V})_{j \in \{i, \dots, n\}}$) to \texttt{hops}[$i-1$]
          \Else \: \Comment{ideal world}
            \If{\texttt{hops}[$i-1$] is honest}
              \State send (\textsc{hostKeysBackward}, \texttt{hops}, $(pk_{j,
              V})_{j \in \{i, \dots, n\}}$, \texttt{hops}[$i-1$]) to \adversary,
              expecting reply (\textsc{ok})
            \Else \: \Comment{\texttt{hops}[$i-1$] is corrupted}
              \State send (\textsc{hostKeysBackward}, \texttt{hops}, $(pk_{j,
              V})_{j \in \{i, \dots, n\}}$, \texttt{hops}[$i-1$]) to \adversary,
              expecting reply (\textsc{hostKeysBackward}, \texttt{hops},
              $(pk_{j, V})_{j \in \{k+1, \dots, n\}}$, \texttt{hops}[$k$]) where
              \texttt{hops}[$k$] is the first honest hop before
              \texttt{hops}[$i-1$], or no response if there is no such hop
            \EndIf
          \EndIf
        \EndFor \: \Comment{control is at \texttt{host\_funder}}
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:host-keys}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.getTXs($c$, $pk_{A, V}$, $pk_{B, V}$, $(pk_{i,
  V})_{i \in [n]}$)}}
    \begin{algorithmic}[1]
      \State 
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:get-txs}
\end{figure}
