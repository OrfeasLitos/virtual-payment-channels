\begin{systembox}{\fch}
  Initially \texttt{isOpen} is set to \texttt{false}.

  Message (\textsc{register}, \texttt{otherPlayer}, $pk$, \texttt{myDelay},
  \texttt{remoteDelay}):
    \begin{itemize}
      \item Until exactly two players are registered (call them \alice{} and
      \bob, in order of registration), ignore all other messages. After that,
      ignore all \textsc{register} messages.
      \item Store $pk$ as $pk_{\alice}$ or $pk_{\bob}$ respectively.
      \item After receiving one \textsc{register} message from a player,
      ignore all further \textsc{register} messages from the same player.
      \item \alice{} must input \bob{} as \texttt{otherPlayer} and vice versa.
      \item \alice's \texttt{myDelay} must match \bob's \texttt{remoteDelay}
      and vice versa.
    \end{itemize}

  In all subsequent messages, denote $P$ the sender (which must be either
  \alice{} or \bob) and $P'$ the counterparty.

  Upon receiving (\textsc{open}, $(sk_{\mathrm{in}}, pk_{\mathrm{in}})$, $c$):
  \begin{itemize}
    \item $c_P \gets c, c_{P'} \gets 0$
    \item $(sk_{P, F}, pk_{P, F}) \gets \mathtt{KeyGen}(), (sk_{P', F},
    pk_{P', F}) \gets \mathtt{KeyGen}()$
    \item $\mathtt{openTX} \gets \tx((\txin(pk_{\mathrm{in}}, \text{selfsig
    with } sk_{\mathrm{in}})), (\txout(\mathtt{msig} = pk_{P, F} \wedge pk_{P',
    F}, c)))$
    \item send (\textsc{submit}, \texttt{openTX}) to \ledger as $P$
  \end{itemize}

  Upon receiving (\textsc{isOpen}):
  \begin{itemize}
    \item send (\textsc{read}) to \ledger{} as $P$ and assign reply to
    $\Sigma_P$
    \item if $\mathtt{openTX} \in \Sigma_P$, set \texttt{isOpen} to
    \texttt{true} and return (\textsc{isOpen}, \texttt{true}), else return
    (\textsc{isOpen}, \texttt{false})
  \end{itemize}

  Upon receiving (\textsc{pay}, $c$):
  \begin{itemize}
    \item if $\mathtt{isOpen} = \mathtt{true}$ and $c_P \geq c$, decrease
    $c_P$ by $c$, increase $c_P'$ by $c$ and return (\textsc{paid}) to $P$
    \item else return (\textsc{notPaid}) to $P$
  \end{itemize}

  Upon receiving (\textsc{getBalance}):
  \begin{itemize}
    \item if $\mathtt{isOpen} = \mathtt{true}$, return (\textsc{balance},
    $c_P, c_{P'}$) to $P$
    \item else return (\textsc{notOpen}) to $P$
  \end{itemize}

  Upon receiving (\textsc{corrupt}, $P$) from \adversary, mark $P$ as corrupted
  and send $sk_P$ to \adversary

  Upon receiving (\textsc{close}):
  \begin{itemize}
    \item $\mathtt{txInput} \gets \txin(\mathtt{msig}, \text{selfsig with }
    sk_{P, F} \wedge sk_{P', F})$
    \item if $P'$ is corrupted, send (\textsc{cooperate}, $P'$) to \adversary
    \item if reply is (\textsc{cooperate}) or if $P'$ is not corrupted, set
    \texttt{closeTX} to $\tx((\mathtt{txInput}), (\txout(pk_P, c_P),
    \txout(pk_{P'}, c_{P'})))$ (with signature)
    \item else if reply is (\textsc{notCooperate}),
    \begin{itemize}
      \item $(sk_{\mathrm{rev}}, pk_{\mathrm{rev}}) \gets \mathtt{KeyGen}()$
      \item $\mathtt{closeTX} \gets \tx((\mathtt{txInput}), (\txout(\rdel(pk_P,
      \mathtt{delay}_{P'}) \vee pk_{\mathrm{rev}}, c_P), \txout(pk_{P'},
      c_{P'})))$ (with signature)
    \end{itemize}
    \item set $c_P, c_{P'}$ to 0 and \texttt{isOpen} to \texttt{false}
    \item send (\textsc{submit}, \texttt{closeTX}) to \ledger{} as $P$
  \end{itemize}
\end{systembox}
