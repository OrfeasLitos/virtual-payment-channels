\section{On Globality}
  \label{sec:globality}
  Since \fchan corresponds to a single channel, which in turn can form the base
  of multiple independent virtual channels and thus needs to be accessible by
  all of them, \fchan is a global functionality, i.e., it can communicate with
  entities outside the (single-channel) protocol. The alternative of modelling
  all channels within a single protocol~\cite{DBLP:conf/csfw/KiayiasL20} leads
  to a monolithic, hard-to-reuse ideal functionality.

  As per Def.~$19$ of~\cite{cryptoeprint:2000/067}, a
  \emph{subroutine respecting} protocol must not pass input to a party of a
  different session. In order to open a
  virtual channel however, \pchan
  passes inputs to a \pchan instance of another session, thus
  \pchan is not subroutine respecting. To
  address this, we first add a superscript to \pchan, i.e.,
  $\pchansup{n}$. $\pchansup{1}$ is always a simple channel.
  This is done by ignoring instructions to \textsc{open} on top of other
  channels. As for higher superscripts, $\forall n \in
  \mathbb{N}^*, \pchansup{n+1}$ is the same as \pchan but with
  base channels of a maximum superscript $n$. It then holds that $\forall
  n \in \mathbb{N}^*, \pchansup{n}$ is \emph{$(\ledger, \pchansup{1}, \dots,
  \pchansup{n-1})$-subroutine
  respecting}~\cite{DBLP:conf/tcc/BadertscherCHTZ20}. The same superscript
  trick is done to \fchan, thus the composition theorem
  of~\cite{DBLP:conf/tcc/BadertscherCHTZ20} is applicable
  (Appx.~\ref{sec:proofs}). To
  the best of the authors' knowledge, this recursion-based proof technique for
  UC security is novel. It is of independent interest and can be reused to prove
  UC security in protocols that may use copies of themselves as subroutines.
  Theorems~\ref{theorem:security:simple} and~\ref{theorem:security:virtual}
  (Appx.~\ref{sec:proofs}) state
  that $\forall n \geq 1, \pchansup{n}$ UC-realises $\fchansup{n}$. Furthermore,
  all ideal global subroutines can be replaced with their real counterparts
  (Lemma~\ref{lemma:merged-emulate} and Theorem~\ref{theorem:replacement}).
