\section{Security}
  \label{section:security}
    Before providing the UC-based security guarantees, it is useful to obtain
  concrete properties directly from our protocol. We first delineate the
  security guarantees Elmo provides by proving
  Lemma~\ref{lemma:real-balance-security-informal} which discusses the
  conservation of funds. The formal statements
  (\ref{lemma:real-balance-security} and~\ref{lemma:ideal-balance}) along with
  all proofs are deferred
  to Appx.~\ref{sec:proofs}. Informally, it
  establishes that if an honest, non-negligent party was implicated in a channel
  that has now been unilaterally closed,
  then the party will have at least the expected funds on-chain.

\begin{lemma}[Real world balance security (informal)]
\label{lemma:real-balance-security-informal}
  Consider a real world execution with $P \in \{\alice, \bob\}$ an honest,
  non-negligent party. Assume that all of the following are true:
  \begin{itemize}
    \item $P$ opened the channel, with initial balance $c$,
    \item $P$ is the host of $n$ channels, each funded with $f_i$ coins,
    \item $P$ has cooperatively closed $k$ channels, where the $i$-th channel
    transferred $r_i$ coins from the hosted virtual channel to $P$,
    \item $P$ has sent $m$ payments, each involving $d_i$ coins,
    \item $P$ has received $l$ payments, each involving $e_i$ coins.
  \end{itemize}
  If $P$ closes unilaterally, eventually there will be $h$ outputs on-chain
  spendable only by $P$, each of value $c_i$, such that
  \begin{equation}
    \sum\limits_{i=1}^h c_i \geq c - \sum\limits_{i=1}^n f_i -
    \sum\limits_{i=1}^m d_i + \sum\limits_{i=1}^l e_i + \sum\limits_{i=1}^k r_i
    \enspace.
  \end{equation}
\end{lemma}

  The expected funds are [initial balance - funds for hosted
  virtuals + funds returned from hosted virtuals - outbound payments + inbound
  payments]. Note that the funds for hosted virtuals only refer to those funds
  used by the funder of the virtual channel, not the rest of the base parties.

\begin{proofsketch}[Lemma~\ref{lemma:real-balance-security-informal}]
  The proof follows all possible execution paths, keeping track of the
  resulting balance in each case and coming to the conclusion that balance is
  secure in all cases, except if signatures are forged.
  %This is proven by first arguing that if
  %the conditions of Lemma~\ref{lemma:ideal-balance} for the ideal world hold,
  %then the conditions of Lemma~\ref{lemma:real-balance-security} also hold for
  %the equivalent real world execution, therefore in this case \fchan does not
  %halt. We then argue that also in case the conditions of
  %Lemma~\ref{lemma:ideal-balance} do not hold, \fchan may never halt as well,
  %therefore concluding the proof.
\end{proofsketch}
    It is important to note that in fact \pchan provides a stronger guarantee:
  a party can always unilaterally close its channel
  and obtain the expected funds on-chain within a known number of blocks.
  This stronger guarantee is sufficient to make Elmo reliable
  enough for real-world applications. However an ideal world
  functionality with such guarantees would have to be aware of specific
  txs and signatures, making it as complicated
  as the protocol, thus violating the spirit of the simulation-based security
  paradigm.

  Subsequently (Appx.~\ref{sec:proofs}) we prove the ``no-halt'' Lemma (\ref{lemma:no-halt}), which informally states that
  if an ideal party is honest, then our ideal
  functionality \fchan (Appx.~\ref{sec:functionality}) does not
  halt with overwhelming probability.

  Since \fchan corresponds to a single channel, which in turn can form the base
  of multiple independent virtual channels and thus needs to be accessible by
  all of them, \fchan is a global functionality, i.e., it can communicate with
  entities outside the (single-channel) protocol. The alternative of modelling
  all channels within a single protocol~\cite{DBLP:conf/csfw/KiayiasL20} leads
  to a monolithic, hard-to-reuse ideal functionality.

  A salient observation is that, in order to open a virtual channel, \pchan
  passes inputs to another \pchan instance
  that belongs to a different extended session, therefore \pchan is not
  \emph{subroutine respecting}, as defined in~\cite{uc}. To
  address this, we first add a superscript to \pchan, i.e.,
  $\pchansup{n}$. $\pchansup{1}$ is always a simple channel.
  This is done by ignoring instructions to \textsc{open} on top of other
  channels. As for higher superscripts, $\forall n \in
  \mathbb{N}^*, \pchansup{n+1}$ is the same as \pchan but with
  base channels of a maximum superscript $n$. It then holds that $\forall
  n \in \mathbb{N}^*, \pchansup{n}$ is $(\ledger, \pchansup{1}, \dots,
  \pchansup{n-1})$-subroutine respecting, as defined
  in~\cite{DBLP:conf/tcc/BadertscherCHTZ20}. The same superscript trick is done
  to \fchan. To
  the best of the authors' knowledge, this recursion-based proof technique for
  UC security is novel. It is of independent interest and can be reused to prove
  UC security in protocols that may use copies of themselves as subroutines.
  Theorems~\ref{theorem:security:simple} and~\ref{theorem:security:virtual}
  (Appx.~\ref{sec:proofs}) state
  that $\forall n \geq 1, \pchansup{n}$ UC-realises $\fchansup{n}$.
