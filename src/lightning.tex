\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- init}
    \begin{algorithmic}[1]
      \State \textsc{init}(\texttt{keys}, \dave):
      \Indent
        \State $pk_{D, \mathrm{out}} \gets \texttt{keys}$
        \State \Return (\textsc{ok})
      \EndIndent
      \Statex

      \State \textsc{topUp}(\texttt{funder}): \TODO{move to \textsc{common} if
      more stuff fits there}
      \Indent
        \State $(sk_{\mathrm{chain}}, pk_{\mathrm{chain}}) \gets
        \textsc{keyGen}()$
        \State output (\textsc{public key}, $pk_{\mathrm{chain}}$) to \dave
        \While{$\nexists \mathrm{tx} \in \Sigma, c_{\mathrm{chain}}:
        (c_{\mathrm{chain}}, pk_{\mathrm{chain}}) \in \mathrm{tx.outputs}$}
          \State wait\footnote{while waiting, all other messages by \dave are
          ignored} for input (\textsc{check top up}) by \dave
          \State input (\textsc{read}) to \ledger as \dave and assign ouput to
          $\Sigma$
        \EndWhile
        \State $\texttt{base\_output} \gets (c_{\mathrm{chain}},
        pk_{\mathrm{chain}})$
        \State \Return (\textsc{ok}, $c_{\mathrm{chain}}$)
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:init}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- base}
    \begin{algorithmic}[1]
      \State \textsc{openBase}(\texttt{fundee}):
      \Indent
        \State $(sk_{A, F}, pk_{A, F}) \gets \textsc{keyGen}()$;
        $(sk_{A, R}, pk_{A, R}) \gets \textsc{keyGen}()$
        \If{ideal world}
          \State $(sk_{B, F}, pk_{B, F}) \gets \textsc{keyGen}()$; $(sk_{B, R},
          pk_{B, R}) \gets \textsc{keyGen}()$
        \Else \: \Comment{real world}
          \State send (\textsc{open base channel}, $c_{\mathrm{chain}}$, $pk_{A,
          F}$, $pk_{A, R}$, $pk_{A, \mathrm{out}}$) to \texttt{fundee}
          \State \Comment{colored code is run by \texttt{fundee}. Validation is
          implicit}
          \State \remotecode{ensure super.\textit{State} = \textsc{init}}
          \Comment{``super'': storage of enclosing protocol}
          \State \remotecode{store $pk_{A, F}$, $pk_{A, R}$, $pk_{A,
          \mathrm{out}}$}
          \State \remotecode{$(sk_{B, F}, pk_{B, F}) \gets \textsc{keyGen}()$};
          $(sk_{B, R}, pk_{B, R}) \gets \textsc{keyGen}()$
          \State \remotecode{reply (\textsc{accept base channel}, $pk_{B,
          F}$, $pk_{B, R}$, $pk_{B, \mathrm{out}}$)}
          \State store $pk_{B, F}$, $pk_{B, R}$, $pk_{B, \mathrm{out}}$
        \EndIf
        \State $F \gets$ TX \{input: \texttt{base\_output}, output:
        $(c_{\mathrm{chain}}, 2/\{pk_{A, F}, pk_{B, F}\})$\}
        \If{real world}
          \State $C_{A, 0} \gets$ TX \{input: $F$.output, outputs:
          ($c_{\mathrm{chain}}$, ($pk_{A, \mathrm{out}}$ $\wedge$
          \texttt{delay}) $\vee$ ($pk_{A, R}$ $\wedge$ $pk_{B, R}$)), ($0$,
          $pk_{B, \mathrm{out}}$)\}
          \State $C_{B, 0} \gets$ TX \{input: $F$.output, outputs:
          ($c_{\mathrm{chain}}$, $pk_{A, \mathrm{out}}$), ($0$, ($pk_{B,
          \mathrm{out}}$ $\wedge$ \texttt{delay}) $\vee$ ($pk_{A, R}$ $\wedge$
          $pk_{B, R}$))\}
          \State $\mathrm{sig}_{A, C, 0} \gets \textsc{sign}(C_{B, 0}, sk_{A,
          F})$
          \State send (\textsc{funding created}, \texttt{base\_output},
          $F$, $\mathrm{sig}_{A, C, 0}$) to \texttt{fundee}
          \State \Comment{implicitly verify that this is a continuation of the
          previous exchange}
          \State \remotecode{$F \gets$ TX \{input: \texttt{base\_output}, output:
          $(c_{\mathrm{chain}}, 2/\{pk_{A, F}, pk_{B, F}\})$\}}
          \State \remotecode{$C_{B, 0} \gets$ TX \{input: $F$.output, outputs:
          ($c_{\mathrm{chain}}$, $pk_{A, \mathrm{out}}$), ($0$, ($pk_{B,
          \mathrm{out}}$ $\wedge$ \texttt{delay}) $\vee$ ($pk_{A, R}$ $\wedge$
          $pk_{B, R}$))\}}
          \State \remotecode{ensure \textsc{verify}($C_{B, 0}$,
          $\mathrm{sig}_{A, C, 0}$, $pk_{A, F}$) = True}
          \State \remotecode{$C_{A, 0} \gets$ TX \{input: $F$.output, outputs:
          ($c_{\mathrm{chain}}$, ($pk_{A, \mathrm{out}}$ $\wedge$
          \texttt{delay}) $\vee$ ($pk_{A, R}$ $\wedge$ $pk_{B, R}$)), ($0$,
          $pk_{B, \mathrm{out}}$)\}}
          \State \remotecode{$\mathrm{sig}_{B, C, 0} \gets \textsc{sign}(C_{A,
          0}, sk_{B, F})$}
          \State \remotecode{reply (\textsc{funding signed}, $\mathrm{sig}_{B,
          C, 0}$)}
          \State ensure \textsc{verify}($C_{A, 0}$, $\mathrm{sig}_{B, C, 0}$,
          $pk_{B, F}$) = True
        \EndIf
        \State $\mathrm{sig}_F \gets \textsc{sign}(F, sk_{\mathrm{chain}})$
        \State send $(\textsc{open}, c_{\mathrm{chain}}, pk_{A, \mathrm{out}},
        pk_{B, \mathrm{out}}, F, \mathrm{sig}_F, \texttt{funder})$ to \adversary
        \While{$F \notin \Sigma$}
          \State wait for input (\textsc{check funding}) by \texttt{funder}
          \State input (\textsc{read}) to \ledger as \texttt{funder} and assign
          output to $\Sigma$
        \EndWhile
        \State \Return (\textsc{ok}, $c_{\mathrm{chain}}$)
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:base}
\end{figure}

\TODO{re-check and dedup}
\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- open virtual}
    \begin{algorithmic}[1]
      \State \textsc{openVirtual}(\texttt{fundee}, \texttt{host\_funder},
      \texttt{host\_fundee}, $c$):
      \Indent
        \State $(sk_{A, F}, pk_{A, F}) \gets \textsc{keyGen}()$
        \If{ideal world}
          \State $(sk_{B, F}, pk_{B, F}) \gets \textsc{keyGen}()$
        \Else \: \Comment{real world}
          \State send (\textsc{open virtual channel}, $c$, $pk_{A, F}$, $pk_{A,
          \mathrm{out}}$, \texttt{host\_fundee}) to \texttt{fundee}
          \State \Comment{colored code is run by \texttt{fundee}. Validation is
          implicit}
          \State \remotecode{ensure super.\textit{State} = \textsc{init}}
          \Comment{``super'': storage of enclosing protocol}
          \State \remotecode{store $pk_{A, F}$, $pk_{A, \mathrm{out}}$}
          \State \remotecode{$(sk_{B, F}, pk_{B, F}) \gets \textsc{keyGen}()$}
          \State \remotecode{reply (\textsc{accept virtual channel}, $pk_{B,
          F}$, $pk_{B, \mathrm{out}}$)}
        \EndIf
        \State send (\textsc{funding keys}, $c$, $pk_{A, F}$, $pk_{B, F}$) to
        \texttt{host\_funder}.\textsc{virt}
        \State \trustedcode{$C_{\mathrm{temp}} \gets C_i$ with $c$ coins moved
        from our output to new 2/\{$pk_{A, F}$, $pk_{B, F}$\} output named
        \texttt{funding\_output}} \TODO{make more formal}
        \State \trustedcode{reply (\textsc{funding output},
        \texttt{funding\_output})}
        \If{real world}
          \State $C_{A, 0} \gets$ TX \{input: \texttt{funding\_output}, outputs:
          ($c$, $pk_{A, \mathrm{out}}$ $\wedge$ $pk_{B, \mathrm{out}}$ $\wedge$
          \texttt{delay}), ($0$, $pk_{B, \mathrm{out}}$)\}
          \State $C_{B, 0} \gets$ TX \{input: \texttt{funding\_output}, outputs:
          ($c$, $pk_{A, \mathrm{out}}$), ($0$, $pk_{A, \mathrm{out}}$ $\wedge$
          $pk_{B, \mathrm{out}}$ $\wedge$ $\texttt{delay}$)\}
          \State $\mathrm{sig}_{A, C, 0} \gets \textsc{sign}(C_{B, 0}, sk_{A,
          F})$
          \State send (\textsc{funding created}, $c$, \texttt{funding\_output},
          $\mathrm{sig}_{A, C, 0}$) to \texttt{fundee}
          \State \Comment{implicitly verify that this is a continuation of the
          previous exchange}
          \State \remotecode{$C_{B, 0} \gets$ TX \{input:
          \texttt{funding\_output}, outputs: ($c$, $pk_{A, \mathrm{out}}$),
          ($0$, $pk_{A, \mathrm{out}}$ $\wedge$ $pk_{B, \mathrm{out}}$ $\wedge$
          $\texttt{delay}$)\}}
          \State \remotecode{ensure \textsc{verify}($C_{B, 0}$,
          $\mathrm{sig}_{A, C, 0}$, $pk_{A, F}$) = True}
          \State \remotecode{$C_{A, 0} \gets$ TX \{input:
          \texttt{funding\_output}, outputs: ($c$, $pk_{A, \mathrm{out}}$
          $\wedge$ $pk_{B, \mathrm{out}}$ $\wedge$ $\texttt{delay}$), ($0$,
          $pk_{B, \mathrm{out}}$)\}}
          \State \remotecode{$\mathrm{sig}_{B, C, 0} \gets \textsc{sign}(C_{A,
          0}, sk_{B, F})$}
          \State \remotecode{reply (\textsc{funding signed}, $\mathrm{sig}_{B,
          C, 0}$)}
          \State ensure \textsc{verify}($C_{A, 0}$, $\mathrm{sig}_{B, C, 0}$,
          $pk_{B, F}$) = True
        \EndIf
        \State send (\textsc{channel established}) to
        \texttt{host\_funder}.\textsc{virt}
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:open-virtual}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- pay}
    \begin{algorithmic}[1]
      \State \textsc{pay}($x$, \textit{payid}):
      \Indent
        \State $C_{\mathrm{rem}, \mathrm{temp}} \gets C_{\mathrm{rem}, i}$ with
        $x$ coins moved from \alice's to \bob's output
        \State $\mathrm{sig}_{\mathrm{payee}, C, i+1} \gets
        \textsc{sign}(C_{\mathrm{rem}, \mathrm{temp}}, sk_{A, F})$ \Comment{kept
        by payee}
        \State send (\textsc{pay}, $x$, $\mathrm{sig}_{\mathrm{payee}, C, i+1}$,
        \textit{payid}) to \bob
        \State \remotecode{$C_{\mathrm{loc}, \mathrm{temp}} \gets
        C_{\mathrm{loc}, i}$ with $x$ coins moved from \alice's to \bob's
        output}
        \State \remotecode{ensure \textsc{verify}($C_{\mathrm{loc},
        \mathrm{temp}}$, $\mathrm{sig}_{\mathrm{payee}, C, i+1}$, $pk_{A, F}$) =
        True}
        \State \remotecode{$C_{\mathrm{rem}, \mathrm{temp}} \gets
        C_{\mathrm{rem}, i}$ with $x$ coins moved from \alice's to \bob's
        output}
        \State \remotecode{$\mathrm{sig}_{\mathrm{payer}, C, i+1} \gets
        \textsc{sign}(C_{\mathrm{rem}, \mathrm{temp}}, sk_{B, F})$}
        \Comment{kept by payer}
        \State \remotecode{$R_{\mathrm{rem}, i+1} \gets$ TX \{input:
        $C_{\mathrm{loc}, \mathrm{temp}}$.outputs.payee, output: ($c_B$, $pk_{A,
        \mathrm{out}}$)\}}
        \State \remotecode{$\mathrm{sig}_{\mathrm{payer}, R, i+1} \gets
        \textsc{sign}(R_{\mathrm{rem}, i+1}, sk_{B, R})$}
        \State \remotecode{reply (\textsc{commitment signed},
        $\mathrm{sig}_{\mathrm{payer}, C, i+1}$,
        $\mathrm{sig}_{\mathrm{payer}, R, i+1}$)}
        \State $C_{\mathrm{loc}, \mathrm{temp}} \gets C_{\mathrm{loc}, i}$ with
        $x$ coins moved from \alice's to \bob's output
        \State ensure \textsc{verify}($C_{\mathrm{loc}, \mathrm{temp}}$,
        $\mathrm{sig}_{\mathrm{payer}, C, i+1}$, $pk_{B, F}$) = True
        \State $R_{\mathrm{loc}, i+1} \gets$ TX \{input: $C_{\mathrm{rem},
        \mathrm{temp}}$.outputs.payee, output: ($c_B$, $pk_{A,
        \mathrm{out}}$)\}
        \State ensure \textsc{verify}($R_{\mathrm{loc}, i+1}$,
        $\mathrm{sig}_{\mathrm{payer}, R, i+1}$, $pk_{B, R}$) = True
        \State $R_{\mathrm{rem}, i+1} \gets$ TX \{input: $C_{\mathrm{loc},
        \mathrm{temp}}$.outputs.payer, output: ($c_A$, $pk_{B, \mathrm{out}}$)\}
        \State $\mathrm{sig}_{\mathrm{payee}, R, i+1} \gets
        \textsc{sign}(R_{\mathrm{rem}, i+1}, sk_{A, R})$
        \State add ($x$, \textit{payid}) to \texttt{paid\_out}
        \State send (\textsc{revoke and ack}, $\mathrm{sig}_{\mathrm{payee}, R,
        i+1}$) to \bob
        \State $R_{\mathrm{loc}, i+1} \gets$ TX \{input: $C_{\mathrm{rem},
        \mathrm{temp}}$.outputs.payer, output: ($c_A$, $pk_{B,
        \mathrm{out}}$)\}
        \State ensure \textsc{verify}($R_{\mathrm{loc}, i+1}$,
        $\mathrm{sig}_{\mathrm{payee}, R, i+1}$, $pk_{A, R}$) = True
        \State \remotecode{add ($x$, \textit{payid}) to \texttt{paid\_in}}
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:pay}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- close}
    \begin{algorithmic}[1]
      \State \textsc{close}($P$, $(\mathrm{tx}_i, (\sigma_{ij})_j)_i$):
      \Indent
        \State \TODO{also cover case when we are virtual}
        \State $\mathit{State} \gets (\textsc{closing}, P, (\mathrm{tx}_i)_i)$
        \State input (\textsc{submit}, $(\mathrm{tx}_i, (\sigma_{ij})_j)_i$)
        to \ledger as $P$
      \EndIndent
      \Statex

      \State On activation when $\textit{State} = (\textsc{closing}, P,
      (\mathrm{tx}_i)_i)$:
      \Indent
        \State input (\textsc{read}) to \ledger as $P$ and assign reply to
        $\Sigma$
        \State ensure all transactions $(\mathrm{tx}_i)_i$ are contained in
        $\Sigma$
        \State \Return (\textsc{ok})
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:virtual}
\end{figure}
