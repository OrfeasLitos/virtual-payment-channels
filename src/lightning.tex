\section{Protocol} \ \\
\label{sec:protocol}

\begin{center}
  \begin{processbox}{\textsc{ln} -- init}
    \begin{algorithmic}[1]
      \State \Comment{When not specified, input comes from and output goes to
      \environment.}
      \State \Comment{The ITI knows whether it is \alice (funder) or \bob
      (fundee). The activated party is $P$ and the counterparty is $\bar{P}$.}
      \State On every activation, before handling the message:
      \Indent
        \If{$\texttt{last\_poll} \neq \bot \wedge \itistate \neq
        \textsc{closed}$} \Comment{channel is open}
          \State input (\textsc{read}) to \ledger and assign ouput to $\Sigma$
          \If{$\texttt{last\_poll} + p < |\Sigma|$} \Comment{$p$ is a global
          parameter}
            \State $\texttt{negligent} \gets$ True
            \label{code:ln:init:negligent}
          \EndIf
        \EndIf
      \EndIndent
      \Statex

      \State On (\textsc{init}, $\pk{P, \mathrm{out}}$):
      \Indent
        \State ensure $\itistate = \bot$
        \State $\itistate \gets \textsc{init}$
        \State store $\pk{P, \mathrm{out}}$
        \State $(c_A, c_B, \texttt{locked}_A, \texttt{locked}_B) \gets (0, 0, 0,
        0)$
        \State $(\texttt{paid\_out}, \texttt{paid\_in}) \gets (\emptyset,
        \emptyset)$
        \State $\texttt{negligent} \gets$ False
        \State $\texttt{last\_poll} \gets \bot$
        \State output (\textsc{init ok})
      \EndIndent
      \Statex

      \State On (\textsc{top up}):
      \Indent
        \State ensure $P = \alice$ \Comment{activated party is the funder}
        \State ensure $\itistate = \textsc{init}$
        \label{code:ln:init:change-state}
        \State $(\sk{P, \mathrm{chain}}, \pk{P, \mathrm{chain}}) \gets
        \textsc{keyGen}()$
        \State input (\textsc{read}) to \ledger and assign ouput to $\Sigma$
        \State output (\textsc{top up to}, $\pk{P, \mathrm{chain}}$)
        \While{$\neg\exists \mathrm{tx} \in \Sigma, c_{P, \mathrm{chain}}: (c_{P,
        \mathrm{chain}}, \pk{P, \mathrm{chain}}) \in \mathrm{tx.outputs}$}
          \State \Comment{while waiting, all other messages by $P$ are ignored}
          \State wait for input (\textsc{check top up})
          \State input (\textsc{read}) to \ledger and assign ouput to $\Sigma$
        \EndWhile
        \State $\itistate \gets \textsc{topped up}$
        \State output (\textsc{top up ok}, $c_{P, \mathrm{chain}}$)
      \EndIndent
      \Statex

      \State On (\textsc{balance}):
      \Indent
        \State ensure $\mathit{State}^P \in \{\textsc{open}, \textsc{closed}\}$
        \label{code:functionality:chan:skeleton:base:balance:start}
        \State output (\textsc{balance}, $c_A, \pk{A, \mathrm{out}}, c_B, \pk{B,
        \mathrm{out}}, \texttt{locked}_A, \texttt{locked}_B$)
        \label{code:functionality:chan:skeleton:base:balance:end}
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:init}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln} -- methods used by \textsc{virt}}
    \begin{algorithmic}[1]
      \State \textsc{revokePrevious}():
      \label{code:ln:methods-for-virt:revoke-previous}
      \Indent
        \State ensure $\itistate \in \textsc{waiting for (outbound)
        revocation}$
        \State $R_{\bar{P}, i} \gets$ TX \{input: $C_{P, i}$.outputs.$P$,
        output: ($C_{P, i}$.outputs.$P$.value, $pk_{\bar{P}, \mathrm{out}}$)\}
        \State $\mathrm{sig}_{A, R, i} \gets \textsc{sign}(R_{\bar{P}, i},
        \sk{P, R, i})$
        \If{$\itistate = \textsc{waiting for revocation}$}
          \State $\itistate \gets \textsc{waiting for inbound revocation}$
        \Else \: \Comment{$\itistate = \textsc{waiting for outbound
        revocation}$}
          \State $i \gets i + 1$
          \State $\itistate \gets \textsc{waiting for hosts ready}$
        \EndIf
        \State $\texttt{host}_P \gets \texttt{host}_P'$ \Comment{forget old
        host, use new host instead}
        \State $\texttt{layer} \gets \texttt{layer} + 1$
        \label{code:ln:methods-for-virt:host-update}
        \State \Return $\mathrm{sig}_{P, R, i}$
      \EndIndent
      \Statex

      \State \textsc{processRemoteRevocation}($\mathrm{sig}_{\bar{P}, R, i}$):
      \label{code:ln:methods-for-virt:process-remote-revocation}
      \Indent
        \State ensure $\itistate = \textsc{waiting for (inbound)
        revocation}$
        \State $R_{P, i} \gets$ TX \{input: $C_{\bar{P}, i}$.outputs.$P$,
        output: ($C_{\bar{P}, i}$.outputs.$\bar{P}$.value, $pk_{P,
        \mathrm{out}}$)\}
        \State ensure \textsc{verify}($R_{P, i}$, $\mathrm{sig}_{\bar{P}, R,
        i}$, $\pk{\bar{P}, R, i}$) = True
        \If{$\itistate = \textsc{waiting for revocation}$}
          \State $\itistate \gets \textsc{waiting for outbound
          revocation}$
        \Else \: \Comment{$\itistate = \textsc{waiting for inbound
        revocation}$}
          \State $i \gets i + 1$
          \State $\itistate \gets \textsc{waiting for hosts ready}$
        \EndIf
        \State \Return (\textsc{ok})
      \EndIndent
      \Statex

      \State \textsc{negligent}():
      \Indent
        \State $\texttt{negligent} \gets$ True
        \label{code:ln:methods-for-virt:negligent}
        \State \Return (\textsc{ok})
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:methods-for-virt}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln.exchangeOpenKeys}()}
    \begin{algorithmic}[1]
      \State $(\sk{A, F}, \pk{A, F}), (\sk{A, R, 1}, \pk{A, R, 1}), (\sk{A, R,
      2}, \pk{A, R, 2}) \gets \textsc{keyGen}()^3$
      \State $\itistate \gets \textsc{waiting for opening keys}$
      \State send (\textsc{open}, $c$, \texttt{hops}, $\pk{A, F}$, $\pk{A, R,
      1}$, $\pk{A, R, 2}$, $\pk{A, \mathrm{out}}$) to \texttt{fundee}
      \label{code:ln:exchange-open-keys:bob-open}
      \State \Comment{colored code is run by honest \texttt{fundee}.
      Validation is implicit}
      \State \remotecode{ensure we run the code of \bob}
      \State \remotecode{ensure $\itistate = \textsc{init}$}
      \State \remotecode{store $\pk{A, F}$, $\pk{A, R, 1}$, $\pk{A, R, 2}$,
      $\pk{A, \mathrm{out}}$}
      \State \remotecode{$(\sk{B, F}, \pk{B, F}), (\sk{B, R, 1}, \pk{B, R, 1}),
      (\sk{B, R, 2}, \pk{B, R, 2}) \gets \textsc{keyGen}()^3$}
      \If{\remotecode{\texttt{hops} = ``\texttt{ledger}''}} \Comment{opening base
      channel}
        \State \remotecode{$\texttt{layer} \gets 0$}
        \State \remotecode{$t_P \gets s + p$} \Comment{$s$ is the upper bound of
        $\eta$ from Lemma~7.19 of~\cite{BMTZ17}}
        \State \remotecode{$\itistate \gets \textsc{waiting for comm
        sig}$}
      \Else \: \Comment{opening virtual channel}
        \State \remotecode{$\itistate \gets \textsc{waiting for
        check keys}$}
      \EndIf
      \State \remotecode{reply (\textsc{accept channel}, $\pk{B, F}$,
      $\pk{B, R, 1}$, $\pk{B, R, 2}$, $\pk{B, \mathrm{out}}$)}
      \label{code:ln:exchange-open-keys:accept-channel}
      \State ensure $\itistate = \textsc{waiting for opening keys}$
      \State store $\pk{B, F}$, $\pk{B, R, 1}$, $\pk{B, R, 2}$, $\pk{B,
      \mathrm{out}}$
      \State $\itistate \gets \textsc{opening keys ok}$
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:exchange-open-keys}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln.prepareBase}()}
    \begin{algorithmic}[1]
      \If{\texttt{hops} = ``\texttt{ledger}''} \Comment{opening base channel}
        \State $F \gets$ TX \{input: $(c, \pk{A, \mathrm{chain}})$, output: $(c,
        2/\{\pk{A, F}, \pk{B, F}\})$\}
        \label{code:ln:base:create-funding}
        \State $\texttt{host}_P \gets$ ``\texttt{ledger}''
        \State $\texttt{layer} \gets 0$
        \State $t_P \gets s + p$
      \Else \: \Comment{opening virtual channel}
        \State input (\textsc{fund me}, \bob, \texttt{hops}, $c$, $\pk{A, F}$,
        $\pk{B, F}$) to \texttt{hops}[0].\texttt{left} and expect output
        (\textsc{funded}, $\texttt{host}_P$, \texttt{funder\_layer}, $t_P$)
        \Comment{ignore any other message}
        \label{code:ln:prepare-base:fund-me}
        \State $\texttt{layer} \gets \texttt{funder\_layer}$
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:prepare-base}
\end{center} \ \\


\begin{center}
  \begin{processbox}{\textsc{ln.exchangeOpenSigs}()}
    \begin{algorithmic}[1]
      \State \Comment{$s = (2 + q)\texttt{windowSize}$, where $q$ and
      \texttt{windowSize} are defined in Proposition~\ref{prop:liveness}}
      \State $C_{A, 0} \gets$ TX \{input: $(c, 2/\{\pk{A, F}, \pk{B, F}\})$,
      outputs: ($c$, ($\pk{A, \mathrm{out}} + (p + s)$) $\vee$ $2/\{\pk{A, R,
      1}, \pk{B, R, 1}\}$), ($0$, $\pk{B, \mathrm{out}}$)\}
      \label{code:ln:exchange-open-sigs:a-tx}
      \State $C_{B, 0} \gets$ TX \{input: $(c, 2/\{\pk{A, F}, \pk{B, F}\})$,
      outputs: ($c$, $\pk{A, \mathrm{out}}$), ($0$, ($\pk{B, \mathrm{out}} + (p
      + s)$) $\vee$ $2/\{\pk{A, R, 1}, \pk{B, R, 1}\}$)\}
      \label{code:ln:exchange-open-sigs:b-tx}
      \State $\mathrm{sig}_{A, C, 0} \gets \textsc{sign}(C_{B, 0}, \sk{A, F})$
      \label{code:ln:exchange-open-sigs:a-sign}
      \State $\itistate \gets \textsc{waiting for comm sig}$
      \State send (\textsc{funding created}, $(c, \pk{A, \mathrm{chain}})$,
      $\mathrm{sig}_{A, C, 0}$) to \texttt{fundee}
      \label{code:ln:exchange-open-sigs:a-send}
      \State \remotecode{ensure $\itistate = \textsc{waiting for comm
      sig}$} \Comment{if opening virtual channel, we have received
      (\textsc{funded}, \texttt{host\_fundee}) by
      \texttt{hops}[-1].\texttt{right} (Fig~\ref{code:ln:bob},
      l.~\ref{code:ln:bob:host})}
      \If{\remotecode{\texttt{hops} = ``\texttt{ledger}''}} \Comment{opening base channel}
        \State \remotecode{$F \gets$ TX \{input: $(c, \pk{A, \mathrm{chain}})$,
        output: $(c, 2/\{\pk{A, F}, \pk{B, F}\})$\}}
      \EndIf
      \State \remotecode{$C_{B, 0} \gets$ TX \{input: $(c, 2/\{\pk{A, F}, \pk{B,
      F}\})$, outputs: ($c$, $\pk{A, \mathrm{out}}$), ($0$, ($\pk{B,
      \mathrm{out}} + (p + s)$) $\vee$ $2/\{\pk{A, R, 1}, \pk{B, R, 1}\}$)\}}
      \State \remotecode{ensure \textsc{verify}($C_{B, 0}$, $\mathrm{sig}_{A, C,
      0}$, $\pk{A, F}$) = True}
      \label{code:ln:exchange-open-sigs:b-verify}
      \State \remotecode{$C_{A, 0} \gets$ TX \{input: $(c, 2/\{\pk{A, F}, \pk{B,
      F}\})$, outputs: ($c$, ($\pk{A, \mathrm{out}} + (p + s)$) $\vee$
      $2/\{\pk{A, R, 1}, \pk{B, R, 1}\}$), ($0$, $\pk{B, \mathrm{out}}$)\}}
      \State \remotecode{$\mathrm{sig}_{B, C, 0} \gets \textsc{sign}(C_{A, 0},
      \sk{B, F})$}
      \label{code:ln:exchange-open-sigs:b-sign}
      \If{\remotecode{\texttt{hops} = ``\texttt{ledger}''}} \Comment{opening base channel}
        \State \remotecode{$\itistate \gets \textsc{waiting to check
        funding}$}
      \Else \: \Comment{opening virtual channel}
        \State \remotecode{$c_A \gets c$; $c_B \gets 0$; $i \gets 0$}
        \State \remotecode{$\itistate \gets \textsc{open}$}
        \label{code:ln:exchange-open-sigs:state-open}
      \EndIf
      \State \remotecode{reply (\textsc{funding signed}, $\mathrm{sig}_{B, C,
      0}$)}
      \label{code:ln:exchange-open-sigs:b-send}
      \State ensure $\itistate = \textsc{waiting for comm sig}$
      \State ensure \textsc{verify}($C_{A, 0}$, $\mathrm{sig}_{B, C, 0}$,
      $\pk{B, F}$) = True
      \label{code:ln:exchange-open-sigs:a-verify}
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:exchange-open-sigs}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln.commitBase}()}
    \begin{algorithmic}[1]
      \State $\mathrm{sig}_F \gets \textsc{sign}(F, \sk{A, \mathrm{chain}})$
      \label{code:ln:base:sign-funding}
      \State input $(\textsc{submit}, (F, \mathrm{sig}_F))$ to \ledger{}
      \Comment{enter ``while'' below before sending}
      \While{$F \notin \Sigma$}
      \label{code:ln:commit-base:f-in-state}
        \State wait for input (\textsc{check funding}) \Comment{ignore all other
        messages}
        \State input (\textsc{read}) to \ledger and assign output to $\Sigma$
      \EndWhile
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:commit-base}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln} -- external open messages for \bob}
    \begin{algorithmic}[1]
      \State On output (\textsc{funded}, $\texttt{host}_P$,
      \texttt{funder\_layer}, $t_P$) by \texttt{hops}[-1].\texttt{right}:
      \label{code:ln:bob:funded}
      \Indent
        \State ensure $\itistate = \textsc{waiting for funded}$
        \State store $\texttt{host}_P$ \Comment{we will talk directly to
        $\texttt{host}_P$}
        \label{code:ln:bob:host}
        \State $\texttt{layer} \gets \texttt{funder\_layer}$
        \State $\itistate \gets \textsc{waiting for comm sig}$
        \State reply (\textsc{fund ack})
      \EndIndent
      \Statex

      \State On output (\textsc{check keys}, ($\pk{1}$, $\pk{2}$)) by
      \texttt{hops}[-1].\texttt{right}:
      \Indent
        \State ensure $\itistate = \textsc{waiting for check keys}$
        \State ensure $\pk{1} = \pk{A, F} \wedge \pk{2} = \pk{B, F}$
        \State $\itistate \gets \textsc{waiting for fudned}$
        \State reply (\textsc{keys ok})
      \EndIndent
      \Statex

      \State On input (\textsc{check funding}):
      \Indent
        \State ensure $\itistate = \textsc{waiting to check funding}$
        \State input (\textsc{read}) to \ledger and assign output to $\Sigma$
        \If{$F \in \Sigma$}
          \State $\itistate \gets \textsc{open}$
          \label{code:ln:bob:state-open}
          \State reply (\textsc{open ok})
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:bob}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln} -- On (\textsc{open}, $c$, \texttt{hops},
  \texttt{fundee}):}
    \begin{algorithmic}[1]
      \State \Comment{\texttt{fundee} is \bob}
      \label{code:ln:open:alice-open}
      \State ensure we run the code of \alice{} \Comment{activated party is the
      funder}
      \If{\texttt{hops} = ``\texttt{ledger}''} \Comment{opening base channel}
        \State ensure $\itistate = \textsc{topped up}$
        \State ensure $c = c_{A, \mathrm{chain}}$
      \Else \: \Comment{opening virtual channel}
        \State ensure $\mathrm{len}(\texttt{hops}) \geq 2$ \Comment{cannot open
        a virtual over 1 channel}
      \EndIf
      \State \textsc{ln.exchangeOpenKeys}()
      \State \textsc{ln.prepareBase}()
      \State \textsc{ln.exchangeOpenSigs}()
      \If{\texttt{hops} = ``\texttt{ledger}''}
        \State \textsc{ln.commitBase}()
      \EndIf
      \State input (\textsc{read}) to \ledger and assign output to $\Sigma$
      \State $\texttt{last\_poll} \gets |\Sigma|$
      \State $c_A \gets c$; $c_B \gets 0$; $i \gets 0$
      \State $\itistate \gets \textsc{open}$
      \label{code:ln:open:state-open}
      \State output (\textsc{open ok}, $c$, \texttt{fundee}, \texttt{hops})
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:open}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln}.\textsc{updateForVirtual}()}
    \begin{algorithmic}[1]
      \State $C_{\bar{P}, i+1} \gets C_{\bar{P}, i}$ with $\pk{P, F}'$,
      $\pk{\bar{P}, F}'$, $\pk{\bar{P}, R, i+1}$ and $\pk{P, R, i+1}$ instead of
      $\pk{P, F}$, $\pk{\bar{P}, F}$, $\pk{\bar{P}, R, i}$ and $\pk{P, R, i}$
      respectively, reducing the input and $P$'s output by $c_{\mathrm{virt}}$
      \State $\mathrm{sig}_{P, C, i+1} \gets \textsc{sign}(C_{\bar{P}, i+1})$
      \Comment{kept by $\bar{P}$}
      \State $(\sk{P, R, i+2}, \pk{P, R, i+2}) \gets \textsc{keyGen}()$
      \State send (\textsc{update forward}, $\mathrm{sig}_{P, C, i+1}$, $\pk{P,
      R, i+2}$) to $\bar{P}$
      \State \Comment{$P$ refers to payer and $\bar{P}$ to payee both in local
      and remote code}
      \State \remotecode{$C_{\bar{P}, i+1} \gets C_{\bar{P}, i}$ with $\pk{P,
      F}'$, $\pk{\bar{P}, F}'$, $\pk{P, R, i+1}$ and $\pk{\bar{P}, R, i+1}$
      instead of $\pk{P, F}$, $\pk{\bar{P}, F}$, $\pk{P, R, i}$ and
      $\pk{\bar{P}, R, i}$ respectively, reducing the input and $P$'s output by
      $c_{\mathrm{virt}}$}
      \State \remotecode{ensure \textsc{verify}($C_{\bar{P}, i+1}$,
      $\mathrm{sig}_{P, C, i+1}$, $\pk{P, F}'$) = True}
      \State \remotecode{$C_{P, i+1} \gets C_{P, i}$ with $\pk{\bar{P}, F}'$,
      $\pk{P, F}'$, $\pk{\bar{P}, R, i+1}$ and $\pk{P, R, i+1}$ instead of
      $\pk{\bar{P}, F}$, $\pk{P, F}$, $\pk{\bar{P}, R, i}$ and $\pk{P, R, i}$
      respectively, reducing the input and $P$'s output by $c_{\mathrm{virt}}$}
      \State \remotecode{$\mathrm{sig}_{\bar{P}, C, i+1} \gets
      \textsc{sign}(C_{P, i+1}, sk_{\bar{P}, F}')$} \Comment{kept by $P$}
      \State \remotecode{$(\sk{\bar{P}, R, i+2}, \pk{\bar{P}, R, i+2}) \gets
      \textsc{keyGen}()$}
      \State \remotecode{reply (\textsc{update back}, $\mathrm{sig}_{\bar{P}, C,
      i+1}$, $\pk{\bar{P}, R, i+2}$)}
      \State $C_{P, i+1} \gets C_{P, i}$ with $\pk{\bar{P}, F}'$, $\pk{P, F}'$,
      $\pk{\bar{P}, R, i+1}$ and $\pk{P, R, i+1}$ instead of $\pk{\bar{P}, F}$,
      $\pk{P, F}$, $\pk{\bar{P}, R, i}$ and $\pk{P, R, i}$ respectively,
      reducing the input and $P$'s output by $c_{\mathrm{virt}}$
      \State ensure \textsc{verify}($C_{P, i+1}$, $\mathrm{sig}_{\bar{P}, C,
      i+1}$, $\pk{\bar{P}, F}'$) = True
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:open:virtual-update}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln} -- virtualise start and end}
    \begin{algorithmic}[1]
      \State On input (\textsc{fund me}, \texttt{fundee}, \texttt{hops},
      $c_{\mathrm{virt}}$, $\pk{A, V}$, $\pk{B, V}$) by \texttt{funder}:
      \Indent
        \State ensure $\itistate = \textsc{open}$
        \State ensure $c_P - \texttt{locked}_P \geq c_{\mathrm{virt}}$
        \State $\itistate \gets \textsc{virtualising}$
        \State $(\sk{P, F}', \pk{P, F}') \gets \textsc{keyGen}()$
        \State define new \textsc{virt} ITI $\texttt{host}_P'$
        \label{code:ln:virtualise:start-end:define}
        \State send (\textsc{virtualising}, $\texttt{host}_P'$, $\pk{P, F}'$,
        \texttt{hops}, \texttt{fundee}, $c_{\mathrm{virt}}$, $2$,
        len(\texttt{hops})) to $\bar{P}$ and expect reply (\textsc{virtualising
        ack}, $\texttt{host}_{\bar{P}}'$, $\pk{\bar{P}, F}'$)
        \State ensure $\pk{\bar{P}, F}'$ is different from $\pk{\bar{P}, F}$ and
        all older $\bar{P}$'s funding public keys
        \State \textsc{ln}.\textsc{updateForVirtual}()
        \label{code:ln:virtualise:start-end:virtual-update}
        \State $\itistate \gets \textsc{waiting for revocation}$
        \State input (\textsc{host me}, \texttt{funder}, \texttt{fundee},
        $\texttt{host}_{\bar{P}}'$, $\texttt{host}_P$, $c_P$, $c_{\bar{P}}$,
        $c_{\mathrm{virt}}$, $\pk{A, V}$, $\pk{B, V}$, ($\sk{P, F}'$, $\pk{P,
        F}'$), ($\sk{P, F}$, $\pk{P, F}$), $\pk{\bar{P}, F}$, $\pk{\bar{P},
        F}'$, $\pk{P, \mathrm{out}}$, len(\texttt{hops})) to $\texttt{host}_P'$
        \label{code:ln:virtualise:start-end:host-me}
      \EndIndent
      \Statex

      \State On output (\textsc{hosts ready}, $t_P$) by $\texttt{host}_P$:
      \Comment{$\texttt{host}_P$ is the new host, renamed in
      Fig.~\ref{code:ln:methods-for-virt},
      l.~\ref{code:ln:methods-for-virt:host-update}}
      \label{code:ln:virtualise:start-end:hosts-ready}
      \Indent
        \State ensure $\itistate = \textsc{waiting for hosts ready}$
        \State $\itistate \gets \textsc{open}$
        \State move $\sk{P, F}$, $\pk{P, F}$, $\pk{\bar{P}, F}$ to list of old
        funding keys
        \State $(\sk{P, F}, \pk{P, F}) \gets (\sk{P, F}', \pk{P, F}')$;
        $\pk{\bar{P}, F} \gets \pk{\bar{P}, F}'$
        \If{len(\texttt{hops}) = 1} \Comment{we are the last hop}
          \State output (\textsc{funded}, $\texttt{host}_P$, $\texttt{layer}$,
          $t_P$) to \texttt{fundee} and expect reply (\textsc{fund ack})
          \label{code:ln:virtualise:start-end:helper-output-funded}
        \ElsIf{we have received input \textsc{fund me} just before we moved to
        the \textsc{virtualising} state} \Comment{we are the first hop}
          \State $c_P \gets c_P - c_{\mathrm{virt}}$
          \label{code:ln:virtualise:start-end:reduce-coins}
          \State output (\textsc{funded}, $\texttt{host}_P$, $\texttt{layer}$,
          $t_P$) to \texttt{funder} \Comment{do not expect reply by
          \texttt{funder}}
          \label{code:ln:virtualise:start-end:funder-funded}
        \EndIf
        \State reply (\textsc{host ack})
        \label{code:ln:virtualise:start-end:reply}
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:virtualise:start-end}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln} -- virtualise hops}
    \begin{algorithmic}[1]
      \State On (\textsc{virtualising}, $\texttt{host}_{\bar{P}}'$,
      $\pk{\bar{P}, F}'$, \texttt{hops}, \texttt{fundee}, $c_{\mathrm{virt}}$,
      $i$, $n$) by $\bar{P}$:
      \Indent
        \State ensure $\itistate = \textsc{open}$
        \State ensure $c_{\bar{P}} - \texttt{locked}_{\bar{P}} \geq c$; $1 \leq
        i \leq n$
        \State ensure $\pk{\bar{P}, F}'$ is different from $\pk{\bar{P}, F}$ and
        all older $\bar{P}$'s funding public keys
        \State $\itistate \gets \textsc{virtualising}$
        \State $\texttt{locked}_{\bar{P}} \gets \texttt{locked}_{\bar{P}} + c$
        \Comment{if $\bar{P}$ is hosting the \texttt{funder}, $\bar{P}$ will
        transfer $c_{\mathrm{virt}}$ coins instead of locking them, but the end
        result is the same}
        \State $(\sk{P, F}', \pk{P, F}') \gets \textsc{keyGen}()$
        \If{$\mathrm{len}(\texttt{hops}) > 1$} \Comment{we are not the last hop}
          \State define new \textsc{virt} ITI $\texttt{host}_P'$
          \State input (\textsc{virtualising}, $\texttt{host}_P'$, ($\sk{P,
          F}'$, $\pk{P, F}'$), $\pk{\bar{P}, F}'$, $\pk{P, \mathrm{out}}$,
          \texttt{hops}[1:], \texttt{fundee}, $c_{\mathrm{virt}}$,
          $c_{\bar{P}}$, $c_P$, $i$, $n$) to \texttt{hops}[1].\texttt{left} and
          expect reply (\textsc{virtualising ack}, \texttt{host\_sibling},
          $\pk{\mathrm{sib}, \bar{P}, F}$)
          \State input (\textsc{init}, $\texttt{host}_P$,
          $\texttt{host}_{\bar{P}}'$, \texttt{host\_sibling}, ($\sk{P, F}'$,
          $\pk{P, F}'$), $\pk{\bar{P}, F}'$, $\pk{\mathrm{sib}, \bar{P}, F}$,
          ($\sk{P, F}$, $\pk{P, F}$), $\pk{\bar{P}, F}$, $\pk{P, \mathrm{out}}$,
          $c_P$, $c_{\bar{P}}$, $c_{\mathrm{virt}}$, $i$, $t_P$, ``left'', $n$)
          to $\texttt{host}_P'$ and expect reply (\textsc{host init ok})
        \Else \: \Comment{we are the last hop}
          \State input (\textsc{init}, $\texttt{host}_P$,
          $\texttt{host}_{\bar{P}}'$, \texttt{fundee}=\texttt{fundee}, ($\sk{P,
          F}'$, $\pk{P, F}'$), $\pk{\bar{P}, F}'$, ($\sk{P, F}$, $\pk{P, F}$),
          $\pk{\bar{P}, F}$, $\pk{P, \mathrm{out}}$, $c_P$, $c_{\bar{P}}$,
          $c_{\mathrm{virt}}$, $t_P$, $i$, ``left'', $n$) to new \textsc{virt}
          ITI $\texttt{host}_P'$ and expect reply (\textsc{host init ok})
        \EndIf
        \State $\itistate \gets \textsc{waiting for revocation}$
        \State send (\textsc{virtualising ack}, $\texttt{host}_P'$, $\pk{P, F}'$)
        to $\bar{P}$
      \EndIndent
      \Statex

      \State On input (\textsc{virtualising}, \texttt{host\_sibling}, ($\sk{P,
      F}'$, $\pk{P, F}'$), $\pk{\mathrm{sib}, \bar{P}, F}$, $\pk{\mathrm{sib},
      \mathrm{out}}$, \texttt{hops}, \texttt{fundee}, $c_{\mathrm{virt}}$,
      $c_{\mathrm{sib}, \mathrm{rem}}$, $c_{\mathrm{sib}}$, $i$, $n$) by
      \texttt{sibling}:
      \Indent
        \State ensure $\itistate = \textsc{open}$
        \State ensure $c_P - \texttt{locked}_P \geq c$
        \State ensure $c_{\mathrm{sib}, \mathrm{rem}} \geq c_P \wedge
        c_{\bar{P}} \geq c_{\mathrm{sib}}$ \Comment{avoid value loss by griefing
        attack: one counterparty closes with old version, the other stays idle
        forever}
        \State $\itistate \gets \textsc{virtualising}$
        \State $\texttt{locked}_P \gets \texttt{locked}_P + c$
        \State define new \textsc{virt} ITI $\texttt{host}_P'$
        \State send (\textsc{virtualising}, $\texttt{host}_P'$, $\pk{P, F}'$,
        \texttt{hops}, \texttt{fundee}, $c_{\mathrm{virt}}$, $i+1$, $n$) to
        \texttt{hops}[0].\texttt{right} and expect reply (\textsc{virtualising
        ack}, $\texttt{host}_{\bar{P}}'$, $\pk{\bar{P}, F}'$)
        \State ensure $\pk{\bar{P}, F}'$ is different from $\pk{\bar{P}, F}$ and
        all older $\bar{P}$'s funding public keys
        \State \textsc{ln}.\textsc{updateForVirtual}()
        \State input (\textsc{init}, $\texttt{host}_P$,
        $\texttt{host}_{\bar{P}}'$, \texttt{host\_sibling}, ($\sk{P, F}'$,
        $\pk{P, F}'$), $\pk{\bar{P}, F}'$, $\pk{\mathrm{sib}, \bar{P}, F}$,
        ($\sk{P, F}$, $\pk{P, F}$), $\pk{\bar{P}, F}$, $\pk{\mathrm{sib},
        \mathrm{out}}$, $c_P$, $c_{\bar{P}}$, $c_{\mathrm{virt}}$, $i$,
        ``right'', $n$) to $\texttt{host}_P'$ and expect reply (\textsc{host
        init ok})
        \State $\itistate \gets \textsc{waiting for revocation}$
        \State output (\textsc{virtualising ack}, $\texttt{host}_P'$,
        $\pk{\bar{P}, F}'$) to \texttt{sibling}
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:open:virtualise:hops}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln}.\textsc{signaturesRoundTrip}()}
    \begin{algorithmic}[1]
      \State $C_{\bar{P}, i+1} \gets C_{\bar{P}, i}$ with $\pk{P, R, i+1}$ and
      $\pk{\bar{P}, R, i+1}$ instead of $\pk{P, R, i}$ and $\pk{\bar{P}, R, i}$
      respectively, and $x$ coins moved from $P$'s to $\bar{P}$'s output
      \label{code:ln:pay:signatures:new-comm}
      \State $\mathrm{sig}_{P, C, i+1} \gets \textsc{sign}(C_{\bar{P}, i+1},
      \sk{P, F})$ \Comment{kept by $\bar{P}$}
      \label{code:ln:pay:signatures:sign-new-comm}
      \State $(\sk{P, R, i+2}, \pk{P, R, i+2}) \gets \textsc{keyGen}()$
      \State $\itistate \gets \textsc{waiting for commitment signed}$
      \State send (\textsc{pay}, $x$, $\mathrm{sig}_{P, C, i+1}$, $\pk{P, R,
      i+2}$) to $\bar{P}$
      \label{code:ln:pay:signatures:pay}
      \State \Comment{$P$ refers to payer and $\bar{P}$ to payee both in local
      and remote code}
      \State \remotecode{ensure $\itistate = \textsc{waiting to get paid} \wedge
      x = y$}
      \State \remotecode{$C_{\bar{P}, i+1} \gets C_{\bar{P}, i}$ with $\pk{P, R,
      i+1}$ and $\pk{\bar{P}, R, i+1}$ instead of $\pk{P, R, i}$ and
      $\pk{\bar{P}, R, i}$ respectively, and $x$ coins moved from $P$'s to
      $\bar{P}$'s output}
      \State \remotecode{ensure \textsc{verify}($C_{\bar{P}, i+1}$,
      $\mathrm{sig}_{P, C, i+1}$, $\pk{P, F}$) = True}
      \label{code:ln:pay:signatures:verify}
      \State \remotecode{$C_{P, i+1} \gets C_{P, i}$ with $\pk{\bar{P}, R, i+1}$
      and $\pk{P, R, i+1}$ instead of $\pk{\bar{P}, R, i}$ and $\pk{P, R, i}$
      respectively, and $x$ coins moved from $P$'s to $\bar{P}$'s output}
      \State \remotecode{$\mathrm{sig}_{\bar{P}, C, i+1} \gets
      \textsc{sign}(C_{P, i+1}, \sk{\bar{P}, F})$} \Comment{kept by $P$}
      \State \remotecode{$R_{P, i} \gets$ TX \{input: $C_{\bar{P},
      i}$.outputs.$P$, output: ($c_{\bar{P}}$, $\pk{P, \mathrm{out}}$)\}}
      \State \remotecode{$\mathrm{sig}_{\bar{P}, R, i} \gets
      \textsc{sign}(R_{P, i}, \sk{\bar{P}, R, i})$}
      \State \remotecode{$(\sk{\bar{P}, R, i+2}, \pk{\bar{P}, R, i+2}) \gets
      \textsc{keyGen}()$}
      \State \remotecode{$\itistate \gets \textsc{waiting for pay revocation}$}
      \State \remotecode{reply (\textsc{commitment signed},
      $\mathrm{sig}_{\bar{P}, C, i+1}$, $\mathrm{sig}_{\bar{P}, R, i}$,
      $\pk{\bar{P}, R, i+2}$)}
      \State ensure $\itistate = \textsc{waiting for commitment signed}$
      \State $C_{P, i+1} \gets C_{P, i}$ with $\pk{\bar{P}, R, i+1}$ and $\pk{P,
      R, i+1}$ instead of $\pk{\bar{P}, R, i}$ and $\pk{P, R, i}$ respectively,
      and $x$ coins moved from $P$'s to $\bar{P}$'s output
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:pay:signatures}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln}.\textsc{revocationsTrip}()}
    \begin{algorithmic}[1]
      \State ensure \textsc{verify}($C_{P, i+1}$, $\mathrm{sig}_{\bar{P}, C,
      i+1}$, $\pk{\bar{P}, F}$) = True
      \label{code:ln:pay:revocations:verify-comm}
      \State $R_{P, i} \gets$ TX \{input: $C_{\bar{P}, i}$.outputs.$\bar{P}$,
      output: ($c_{\bar{P}}$, $\pk{P, \mathrm{out}}$)\}
      \State ensure \textsc{verify}($R_{P, i}$, $\mathrm{sig}_{\bar{P}, R,
      i}$, $\pk{\bar{P}, R, i}$) = True
      \label{code:ln:pay:revocations:verify-rev}
      \State $R_{\bar{P}, i} \gets$ TX \{input: $C_{P, i}$.outputs.$P$, output:
      ($c_P$, $\pk{\bar{P}, \mathrm{out}}$)\}
      \State $\mathrm{sig}_{P, R, i} \gets \textsc{sign}(R_{\bar{P}, i},
      \sk{P, R, i})$
      \label{code:ln:pay:revocations:sign-rev}
      \State add $x$ to \texttt{paid\_out}
      \label{code:ln:pay:revocations:paid-out}
      \State $c_P \gets c_P - x; c_{\bar{P}} \gets c_{\bar{P}} + x$; $i \gets
      i + 1$
      \State $\itistate \gets \textsc{open}$
      \If{$\texttt{host}_P \neq$ ``\texttt{ledger}'' $\: \wedge$ we have a
      \texttt{host\_sibling}} \Comment{we are intermediary channel}
        \State input (\textsc{new balance}, $c_P$, $c_{\bar{P}}$) to
        $\texttt{host}_P$
        \State \trustedcode{relay message as input to \texttt{sibling}}
        \Comment{run by \textsc{virt}}
        \State \trustedcode{relay message as output to \texttt{guest}}
        \Comment{run by \textsc{virt}}
        \State \trustedcode{store new sibling balance and reply (\textsc{new
        balance ok})}
        \State \trustedcode{output (\textsc{new balance ok}) to
        \texttt{sibling}}
        \Comment{run by \textsc{virt}}
        \State \trustedcode{output (\textsc{new balance ok}) to \texttt{guest}}
        \Comment{run by \textsc{virt}}
      \EndIf
      \State send (\textsc{revoke and ack}, $\mathrm{sig}_{P, R, i}$) to
      $\bar{P}$
      \label{code:ln:pay:revocations:send-rev}
      \State \remotecode{ensure $\itistate = \textsc{waiting for pay
      revocation}$}
      \State \remotecode{$R_{\bar{P}, i} \gets$ TX \{input: $C_{P,
      i}$.outputs.$\bar{P}$, output: ($c_P$, $\pk{\bar{P}, \mathrm{out}}$)\}}
      \State \remotecode{ensure \textsc{verify}($R_{\bar{P}, i}$,
      $\mathrm{sig}_{P, R, i}$, $\pk{P, R, i}$) = True}
      \label{code:ln:pay:revocations:verify}
      \State \remotecode{add $x$ to \texttt{paid\_in}}
      \label{code:ln:pay:revocations:paid-in}
      \State \remotecode{$c_P \gets c_P - x; c_{\bar{P}} \gets c_{\bar{P}} +
      x$; $i \gets i + 1$}
      \State \remotecode{$\itistate \gets \textsc{open}$}
      \If{\remotecode{$\texttt{host}_P \neq$ ``\texttt{ledger}'' $\wedge$
      $\bar{P}$ has a \texttt{host\_sibling}}} \Comment{we are intermediary
      channel}
        \State \remotecode{input (\textsc{new balance}, $c_{\bar{P}}$, $c_P$)
        to $\texttt{host}_{\bar{P}}$}
        \State \remotecode{relay message as input to \texttt{sibling}}
        \Comment{run by \textsc{virt}}
        \State \remotecode{relay message as output to \texttt{guest}}
        \Comment{run by \textsc{virt}}
        \State \remotecode{store new sibling balance and reply (\textsc{new
        balance ok})}
        \State \remotecode{output (\textsc{new balance ok}) to \texttt{sibling}}
        \Comment{run by \textsc{virt}}
        \State \remotecode{output (\textsc{new balance ok}) to \texttt{guest}}
        \Comment{run by \textsc{virt}}
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:pay:revocations}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln} -- On (\textsc{pay}, $x$):}
    \begin{algorithmic}[1]
      \State ensure $\itistate = \textsc{open} \wedge c_P \geq x$
      \If{$\texttt{host}_P \neq$ ``\texttt{ledger}'' $\wedge$ $P$ has a
      \texttt{host\_sibling}} \Comment{we are intermediary channel}
        \State ensure $c_{\mathrm{sib}, \mathrm{rem}} \geq c_P - x \wedge
        c_{\bar{P}} + x \geq c_{\mathrm{sib}}$ \Comment{avoid value loss by
        griefing attack: one counterparty closes with old version, the other
        stays idle forever}
      \EndIf
      \State \textsc{ln}.\textsc{signaturesRoundTrip}()
      \State \textsc{ln}.\textsc{revocationsTrip}()
      \State \Comment{No output is given to the caller, this is intentional}
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:pay}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln} -- On (\textsc{get paid}, $y$):}
    \begin{algorithmic}[1]
      \State ensure $\itistate = \textsc{open} \wedge c_{\bar{P}} \geq y$
      \If{$\texttt{host}_{P} \neq$ ``\texttt{ledger}'' $\wedge$ $P$ has a
      \texttt{host\_sibling}} \Comment{we are intermediary channel}
        \State ensure $c_P + y \leq c_{\mathrm{sib}, \mathrm{rem}} \wedge
        c_{\mathrm{sib}} \leq c_{\bar{P}} - y$ \Comment{avoid value loss by
        griefing attack}
      \EndIf
      \State store $y$
      \State $\itistate \gets \textsc{waiting to get paid}$
      \label{code:ln:get-paid:state}
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:get-paid}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln} -- On (\textsc{check for lateral close}):}
    \begin{algorithmic}[1]
      \If{$\texttt{host}_P \neq$ ``\texttt{ledger}''}
        \State input (\textsc{check for lateral close}) to
        $\texttt{host}_P$
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:poll-virtual}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln} -- On (\textsc{check chain for closed}):}
    \begin{algorithmic}[1]
      \State ensure $\itistate \notin \{\bot, \textsc{init},
      \textsc{topped up}\}$ \Comment{channel open}
      \State \Comment{even virtual channels check \ledger directly. This is
      intentional}
      \State input (\textsc{read}) to \ledger and assign reply to $\Sigma$
      \State $\texttt{last\_poll} \gets |\Sigma|$
      \If{$\exists 0 \leq j < i : C_{\bar{P}, j} \in \Sigma$}
      \Comment{counterparty has closed maliciously}
        \State $\itistate \gets \textsc{closing}$
        \State \textsc{ln}.\textsc{submitAndCheckRevocation}($j$)
        \State $\itistate \gets \textsc{closed}$
        \label{code:ln:poll:state-closed-punished}
        \State output (\textsc{closed})
      \ElsIf{$C_{P, i} \in \Sigma \vee C_{\bar{P}, i} \in \Sigma$}
        \State $\itistate \gets \textsc{closed}$
        \label{code:ln:poll:state-closed-honestly}
        \State output (\textsc{closed})
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:poll}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln}.\textsc{submitAndCheckRevocation}($j$)}
    \begin{algorithmic}[1]
      \State $\mathrm{sig}_{P, R, j} \gets \textsc{sign}(R_{P, j}, \sk{P, R,
      j})$
      \State input (\textsc{submit}, ($R_{P, j}$, $\mathrm{sig}_{P, R, j}$,
      $\mathrm{sig}_{\bar{P}, R, j}$)) to \ledger
      \While{$\neg\exists R_{P, j} \in \Sigma$}
        \State wait for input (\textsc{check revocation}) \Comment{ignore
        other messages}
        \State input (\textsc{read}) to \ledger and assign output to $\Sigma$
      \EndWhile
      \State $c_P \gets c_P + c_{\bar{P}}$
      \If{$\texttt{host}_P \neq$ ``\texttt{ledger}''}
        \State input (\textsc{used revocation}) to $\texttt{host}_P$
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:submit-revocation}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln} -- On (\textsc{forceClose}):}
    \begin{algorithmic}[1]
      \State ensure $\itistate \notin \{\bot, \textsc{init}, \textsc{topped up},
      \textsc{closed}, \textsc{base punished}\}$ \Comment{channel open}
      \If{$\texttt{host}_P \neq$ ``\texttt{ledger}''} \Comment{we have a virtual channel}
        \State $\itistate \gets \textsc{host closing}$
        \State input (\textsc{forceClose}) to $\texttt{host}_P$ and keep relaying any
        (\textsc{check if closing}) or (\textsc{forceClose}) input to
        $\texttt{host}_P$ until receiving output (\textsc{closed}) by
        $\texttt{host}_P$
        \label{code:ln:close:relay}
        \State $\texttt{host}_P \gets$ ``\texttt{ledger}''
      \EndIf
      \State $\itistate \gets \textsc{closing}$
      \State input (\textsc{read}) to \ledger and assign output to $\Sigma$
      \If{$C_{\bar{P}, i} \in \Sigma$} \Comment{counterparty has closed
      honestly}
        \State no-op \Comment{do nothing}
      \ElsIf{$\exists 0 \leq j < i : C_{\bar{P}, j} \in \Sigma$}
      \Comment{counterparty has closed maliciously}
        \State \textsc{ln}.\textsc{submitAndCheckRevocation}($j$)
      \Else \: \Comment{counterparty is idle}
        \While{$\not\exists$ unspent \texttt{output} $\in \Sigma$ that $C_{P, i}$
        can spend} \Comment{possibly due to an active timelock}
          \State wait for input (\textsc{check virtual}) \Comment{ignore other
          messages}
          \State input (\textsc{read}) to \ledger and assign output to $\Sigma$
        \EndWhile
        \State $\mathrm{sig}_{P, C, i}' \gets \textsc{sign}(C_{P, i}, \sk{P,
        F})$
        \State input (\textsc{submit}, $(C_{P, i}, \mathrm{sig}_{P, C, i},
        \mathrm{sig}_{P, C, i}')$) to \ledger
        \label{code:ln:close:submit}
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:close}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln} -- On output (\textsc{enabler used revocation})
  by $\texttt{host}_P$:}
    \begin{algorithmic}[1]
      \State $\itistate \gets \textsc{base punished}$
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:used-revocation}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln} -- On (\textsc{coopClose}):}
    \Comment{any endpoint or intermediary can initiate virtual channel closing}
    \begin{algorithmic}[1]
      \State ensure $\texttt{host}_P \neq$ ``\texttt{ledger}''
      \State ensure $\itistate = \textsc{open}$
      \State $\itistate \gets \textsc{coop closing}$
      \If{we are not \texttt{fundee}}
        \State send (\textsc{coop close}) to \texttt{fundee} and expect output
        (\textsc{coopClosed}) by $\texttt{host}_P$
      \Else \: \Comment{we are \texttt{fundee}}
        \State execute code of Fig.~\ref{code:ln:coop-close-fundee}
        \label{code:ln:coop-close:goto}
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:coop-close}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln} -- On (\textsc{coop close}) by $R$}
    \Comment{also executed when we are instructed to close a channel
    cooperatively by \environment -- c.f.\ Fig.~\ref{code:ln:coop-close},
    l.~\ref{code:ln:coop-close:goto}}
    \begin{algorithmic}[1]
      \State ensure we are \texttt{fundee}
      \State input (\textsc{coop close}, $(c_{\bar{P}}, c_P)$) to
      $\texttt{host}_P$ and expect output (\textsc{new comm tx}, $C_{n-1,
      \mathrm{right}}$, $\mathrm{sig}_{n-1, \mathrm{right}, C}$, $\pk{n, R,
      i+2}$)
      \State $\texttt{sig\_bal} \gets ((c_{\bar{P}}, c_P),
      \textsc{sign}((c_{\bar{P}}, c_P), \sk{P, F}))$
      \State $\itistate \gets \textsc{waiting to revoke virt comm}$
      \State send (\textsc{coop close}, \texttt{sig\_bal}, $C_{n-1,
      \mathrm{right}}$, $\mathrm{sig}_{n-1, \mathrm{right}, C}$, $\pk{n, R,
      i+2}$) to $\bar{P}$
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:coop-close-fundee}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{ln} -- On output (\textsc{coop close}, $(c_1,
  c_2)$) by $\texttt{host}_P$:}
    \TODO{maybe extend this for base parties that are not necessarily kindred to
    the fundee}
    \Comment{$c_1 + c_2 = c_{\mathrm{virt}}$}
    \begin{algorithmic}[1]
      \State remove most recent keys from list of old funding keys and assign
      them to $\sk{P, F}', \pk{P, F}'$ and $\pk{\bar{P}, F}'$
      \State $C_{\bar{P}, i+1} \gets$ TX \{input: ($c_P + c_{\bar{P}} +
      c_{\mathrm{virt}}, 2/\{\pk{\bar{P}, F}', \pk{P, F}'\}$), outputs:
      ($c_{\bar{P}} + c_1$, $(\pk{\bar{P}, \mathrm{out}} + (p + s)) \vee
      (2/\{\pk{\bar{P}, R, i+1}, \pk{P, R, i+1}\})$), ($c_P + c_2$, $\pk{P,
      \mathrm{out}}$)\}
      \State $\mathrm{sig}_{P, C, i+1} \gets \textsc{sign}(C_{\bar{P}, i+1},
      \sk{P, F}')$
      \State $(\sk{P, R, i+2}, \pk{P, R, i+2}) \gets \textsc{keyGen}()$
      \State $\itistate \gets \textsc{waiting for virtual revocation}$
      \State input (\textsc{new comm tx}, $C_{\bar{P}, i+1}$, $\mathrm{sig}_{P,
      C, i+1}$, $\pk{P, R, i+2}$) to $\texttt{host}_P$
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:coop-close-base}
\end{center} \ \\

\begin{center}
  \begin{processbox}{On (\textsc{coop close}, $\texttt{sig\_bal}_{\bar{P}}$,
  $C_{n-1, \mathrm{right}}$, $\mathrm{sig}_{n-1, \mathrm{right}, C}$, $\pk{n, R,
  i+2}$) by $\bar{P}$}
    \begin{algorithmic}[1]
      \State ensure $P = \texttt{funder} \wedge \bar{P} = \texttt{fundee}$
      \State parse $\texttt{sig\_bal}_{\bar{P}}$ as $(c_P', c_{\bar{P}}'),
      \mathrm{sig})$
      \State ensure $c_P = c_P' \wedge c_{\bar{P}} = c_{\bar{P}}' \wedge
      \textsc{verify}((c_P', c_{\bar{P}}'), \mathrm{sig}, \pk{\bar{P}, F})$
      \State $\texttt{sig\_bal}_P \gets ((c_P, c_{\bar{P}}), \textsc{sign}((c_P,
      c_{\bar{P}}), \sk{P, F}))$
      \State $\itistate \gets \textsc{waiting to revoke virt comm}$
      \State input (\textsc{coop close}, $\texttt{sig\_bal}_P$, sig, $C_{n-1,
      \mathrm{right}}$, $\mathrm{sig}_{n-1, \mathrm{right}, C}$, $\pk{n, R,
      i+2}$ to $\texttt{host}_P$
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:ln:coop-close-funder}
\end{center} \ \\
