\begin{figure}[H]
  \begin{simulatorbox}{\simulator{} -- general message handling rules}
    \begin{itemize}
      \item On receiving (\textsc{relay}, \texttt{in\_msg}, $P$, $R$,
      \texttt{in\_mode}) by \fchan (\texttt{in\_mode} $\in$ \{input, output,
      network\}, $P \in \{\alice, \bob\}$), handle (\texttt{in\_msg}) with the
      simulated party $P$ as if it was received from $R$ by means of
      \texttt{in\_mode}. In case simulated $P$ does not exist yet, initialise it
      as an \textsc{ln} ITI. If there is a resulting message \texttt{out\_msg}
      that is to be sent by simulated $P$ to $R'$ by means of
      $\texttt{out\_mode} \in$ \{input, output, network\}, send (\textsc{relay},
      \texttt{out\_msg}, $P$, $R'$, \texttt{out\_mode}) to \fchan.
      \item On receiving by \fchan a message to be sent by $P$ to $R$ via the
      network, carry on with this action (i.e. send this message via the
      internal \adversary).
      \item Relay any other incoming message to the internal \adversary
      unmodified.
      \item On receiving a message (\texttt{msg}) by the internal \adversary, if it is
      addressed to one of the parties that correspond to \fchan, handle the
      message internally with the corresponding simulated party. Otherwise relay
      the message to its intended recipient unmodified. \Comment{Other
      recipients are \environment, \ledger or parties unrelated to \fchan}
    \end{itemize}

    Given that \fchan relays all messages and that we simulate the real-world
    machines that correspond to \fchan, the simulation is perfectly
    indistinguishable from the real world.
  \end{simulatorbox}
  \caption{}
  \label{code:simulator:flow}
\end{figure}

\begin{figure}[H]
  \begin{simulatorbox}{\simulator{} -- notifications to \fchan}
    \begin{itemize}
      \item When referring to a player $P$, it must be one of the parties that
      correspond to \fchan.
      \item When an action in the current Figure interrupts the simulation of a
      party, the latter is continued from the interruption location after
      control is handed back by \fchan.
    \end{itemize} \ \\
    \begin{algorithmic}[1]
      \State On (\textsc{corrupt}) by \adversary, addresed to $P$:
      \Indent
        \State \Comment{After executing this code, deliver (\textsc{corrupt}) to
        simulated $P$ as detailed in Fig.~\ref{code:simulator:flow}.  Given that
        \fchan returns control directly to us after it handles this message, we
        will always deliver (\textsc{corrupt}) successfully.}
        \State send (\textsc{info}, \textsc{became corrupted or negligent}, $P$)
        to \fchan
        \label{code:simulator:corrupted}
      \EndIndent
      \Statex

      \State When simulated $P$ sets its internal variable \texttt{negligent} to
      True (Fig.~\ref{code:ln:methods-for-virt},
      l.~\ref{code:ln:methods-for-virt:negligent}/Fig.~\ref{code:ln:init},
      l.~\ref{code:ln:init:negligent}):
      \Indent
        \State send (\textsc{info}, \textsc{became corrupted or negligent}, $P$)
        to \fchan
        \label{code:simulator:negligent}
      \EndIndent
      \Statex

      \State When simulated $P$ moves to the \textsc{init} state
      (Fig.~\ref{code:ln:init}, l.~\ref{code:ln:init:change-state}):
      \Indent
        \State send (\textsc{info}, \textsc{init}, $P$) to \fchan
      \EndIndent
      \Statex

      \State When the last of the honest simulated \fchan's parties moves to the
      \textsc{open} state for the first time
      (Fig.~\ref{code:ln:exchange-open-sigs},
      l.~\ref{code:ln:exchange-open-sigs:state-open}/Fig.~\ref{code:ln:bob},
      l.~\ref{code:ln:bob:state-open}/Fig.~\ref{code:ln:open},
      l.~\ref{code:ln:open:state-open}):
      \Indent
        \State send (\textsc{info}, \textsc{open}) to \fchan
        \label{code:simulator:open}
      \EndIndent
      \Statex

      \State When (both \fchan's simulated parties are honest and one party
      completes sending a payment (Fig.~\ref{code:ln:pay:revocations},
      l.~\ref{code:ln:pay:revocations:paid-out}) and the counterparty completes
      receiving that payment (Fig.~\ref{code:ln:pay:revocations},
      l.~\ref{code:ln:pay:revocations:paid-in})), or (when only one of the two
      is honest and (completes either receiving or sending a payment)):
      \Comment{also send this message if both parties are honest when
      Fig.~\ref{code:ln:pay:revocations},
      l.~\ref{code:ln:pay:revocations:paid-out} is executed by one party, but
      its counterparty is corrupted before executing
      Fig.~\ref{code:ln:pay:revocations},
      l.~\ref{code:ln:pay:revocations:paid-in}}
      \Indent
        \State send (\textsc{info}, \textsc{pay ok}) to \fchan
      \EndIndent
      \Statex

      \State When (both \fchan's simulated parties are honest and they both
      complete changing to a new host (Fig.~\ref{code:ln:methods-for-virt},
      l.~\ref{code:ln:methods-for-virt:host-update})), or (when only one of the
      two is honest and it completes changing to a new host): \Comment{also send
      this message if both parties are honest when the change of host is
      executed by one party, but its counterparty is corrupted before changing
      host}
      \Indent
        \State send (\textsc{info}, \textsc{fund ok}) to \fchan
      \EndIndent
      \Statex

      \State When one of the honest simulated \fchan's parties moves to the
      \textsc{closed} state (Fig.~\ref{code:ln:poll},
      l.~\ref{code:ln:poll:state-closed}/Fig.~\ref{code:ln:close},
      l.~\ref{code:ln:close:state-closed}):
      \Indent
        \State send (\textsc{info}, \textsc{close}) to \fchan
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{code:simulator}
\end{figure}
