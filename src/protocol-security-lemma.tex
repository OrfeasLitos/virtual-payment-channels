\section{Omitted Proofs} \ \\
\label{sec:proofs}

\begin{lemma}[Real world balance security]
\label{lemma:real-balance-security}
  Consider a real world execution with $P \in \{\alice, \bob\}$ honest
  \textsc{ln} ITI and $\bar{P}$ the counterparty ITI. Assume that all of the
  following are true:
  \begin{itemize}
    \item the internal variable \texttt{negligent} of $P$ has value ``False'',
    \item $P$ has transitioned to the \textsc{open} \textit{State} for the first
    time after having received $(\textsc{open}, c, \dots)$ by either
    \environment or $\bar{P}$,
    \item $P$ [has received $(\textsc{fund me}, f_i, \dots)$ as input by another
    \textsc{ln} ITI while \textit{State} was \textsc{open} and subsequently $P$
    transitioned to \textsc{open} \textit{State}] $n$ times,
    \item $P$ [has received $(\textsc{check coop close fundee}, (\_, r_i),
    \dots)$ as output by $\texttt{host}_P$ while \textit{State} was
    \textsc{open} and subsequently $P$ transitioned to \textsc{open}
    \textit{State}] $j$ times,
    \item $P$ [has received $(\textsc{coop close sign comm funder}, (l_i, \_))$
    as output by $\texttt{host}_P$ while \textit{State} was \textsc{open} and
    subsequently $P$ transitioned to \textsc{open} \textit{State}] $k$ times,
    \item $P$ [has received $(\textsc{pay}, d_i)$ by \environment while
    \textit{State} was \textsc{open} and $P$ subsequently transitioned to
    \textsc{open} \textit{State}] $m$ times,
    \item $P$ [has received $(\textsc{get paid}, e_i)$ by \environment while
    \textit{State} was \textsc{open} and $P$ subsequently transitioned to
    \textsc{open} \textit{State}] $l$ times.
  \end{itemize}
  Let $\phi = 1$ if $P = \alice$, or $\phi = 0$ if $P = \bob$.
  \begin{itemize}
    \item If $P$ receives $(\textsc{forceClose})$ by \environment and, if
    $\texttt{host}_P \neq$ ``\texttt{ledger}'' the output of $\texttt{host}_P$
    is $(\textsc{closed})$, then eventually the state obtained when $P$ inputs
    $(\textsc{read})$ to \ledger will contain $h$ outputs each of value $c_i$
    and that has been spent or is exclusively spendable by $\pk{R,
    \mathrm{out}}$ such that
    \begin{equation}
    \label{lemma:real-balance-security:ineq}
      \sum\limits_{i=1}^h c_i \geq \phi \cdot c - \sum\limits_{i=1}^n f_i -
      \sum\limits_{i=1}^m d_i + \sum\limits_{i=1}^l e_i + \sum\limits_{i=1}^j
      r_i + \sum\limits_{i=1}^k l_i
    \end{equation}
    with overwhelming probability in the security parameter, where $R$ is a
    local, kindred \textsc{ln} machine (i.e.\ either $P$, the \texttt{guest} of
    $\texttt{host}_P$'s \texttt{sibling}, the party to which $P$ sent
    \textsc{fund me} if such a message has been sent, or the \texttt{guest} of
    the \texttt{sibling} of one of the transitive closure of hosts of $P$).
    \item Assume that, at some particular instant during the execution,
    \begin{enumerate}
      \item $\texttt{host}_P \neq$ ``\texttt{ledger}'',
      \item $P$ has $\itistate$ \textsc{open}.
    \end{enumerate}
    Consider two alternative series of subsequent execution steps:
    \begin{enumerate}
      \item The \texttt{guest} of $\texttt{host}_P$ (call them $S$) receives
      $(\textsc{forceClose})$ by \environment. From that point onward, all
      protocol parties (even corrupted ones) honestly follow the protocol.
      Eventually a total of $c_b$ coins is exclusively spendable by $\pk{R,
      \mathrm{out}}$, where $R$ is a machine kindred to $S$. Additionally, there
      is at least one funding output of $P$'s channel $(c_P + c_{\bar{P}},
      2/\{\pk{P, F}, \pk{\bar{P}, F}\})$ that is on-chain and unspent.
      \item $P$ receives either $(\textsc{coopClose})$ by \environment or
      $(\textsc{coop close}, $\dots$)$ by some other ITI, and $P$'s variable
      $\texttt{hosting}$ is False. Subsequently, $P$'s $\itistate$ transitions
      to \textsc{coop closed} and then the $\itistate$ of $S$ transitions to
      \textsc{open}. The next time $S$ is activated is via a
      $(\textsc{forceClose})$ input by \environment and eventually a total of
      $c_t$ coins is exclusively spendable by $\pk{R, \mathrm{out}}$.
    \end{enumerate}
    It then holds that
    \begin{equation}
      \label{eq:real-balance-coop-close}
      c_t - c_b \geq \phi \cdot c - \sum\limits_{i=1}^n f_i -
      \sum\limits_{i=1}^m d_i + \sum\limits_{i=1}^l e_i + \sum\limits_{i=1}^j
      r_i + \sum\limits_{i=1}^k l_i
    \end{equation}
    with overwhelming probability in the security parameter.
  \end{itemize}
\end{lemma}

\begin{proof}[Proof of Lemma~\ref{lemma:real-balance-security}]
  We first note that, as signature forgeries only happen with negligible
  probability and only a polynomial number of signatures are verified by honest
  parties throughout an execution, the event in which any forged signature
  passes the verification of an honest party or of \ledger happens only with
  negligible probability. We can therefore ignore this event throughout this
  proof and simply add a computationally negligible distance between
  \environment's outputs in the real and the ideal world at the end.

  We also note that $\pk{P, \mathrm{out}}$ has been provided by \environment,
  therefore it can freely use coins spendable by this key. This is why we allow
  for any of the $\pk{P, \mathrm{out}}$ outputs to have been spent.

  Define the \emph{history} of a channel as $H = (F, C)$, where each of $F, C$
  is a list of lists of integers. A party $P$ which satisfies the Lemma
  conditions has a unique, unambiguously and recursively defined history: If the
  value \texttt{hops} in the (\textsc{open}, $c$, $\texttt{hops}$, $\dots$)
  message was equal to ``\texttt{ledger}'', then $F$ is the empty list, otherwise $F$ is the
  concatenation of the $F$ and $C$ lists of the party that sent
  (\textsc{funded}, $\dots$) to $P$, as they were at the moment the latter
  message was sent. After initialised, $F$ remains immutable. Observe that, if
  $\texttt{hops} \neq$ ``\texttt{ledger}'', both aforementioned messages must have been
  received before $P$ transitions to the \textsc{open} state.

  The list $C$ of party $P$ is initialised to $[[g]]$ when $P$'s $\itistate$
  transitions for the first time to \textsc{open}, where $g = c$ if $P =
  \alice$, or $g = 0$ if $P = \bob$; this represents the initial channel
  balance. The value $x$ or $-x$ is appended to the last list in $C$ when a
  payment is received (Fig.~\ref{code:ln:pay:revocations},
  l.~\ref{code:ln:pay:revocations:paid-in}) or sent
  (Fig.~\ref{code:ln:pay:revocations},
  l.~\ref{code:ln:pay:revocations:paid-out}) respectively by $P$. Moving on to
  the funding of new virtual channels, whenever $P$ funds a new virtual channel
  (Fig.~\ref{code:ln:virtualise:start-end},
  l.~\ref{code:ln:virtualise:start-end:reduce-coins}), $[-c_{\mathrm{virt}}]$
  is appended to $C$ and whenever $P$ helps with the opening of a new virtual
  channel, but does not fund it (Fig.~\ref{code:ln:virtualise:start-end},
  l.~\ref{code:ln:virtualise:start-end:reply}), $[0]$ is appended to $C$.
  In case of cooperatively closing a channel
  (Figs.~\ref{code:ln:coop-close}-\ref{code:ln:coop-close-funder}
  \&~\ref{code:virtual-layer:coop-close-intermediary}) to which $P$'s channel is
  base, if this channel was initially funded by $P$, when the closing procedure
  completes (Fig.~\ref{code:ln:coop-close-funder},
  l.~\ref{code:ln:coop-close-funder:update-coins}) $[c_1']$ is appended to $C$.
  Likewise, if in the closed virtual channel $P$ was the base of the
  \texttt{fundee} (Fig.~\ref{code:virtual-layer:coop-close-intermediary},
  l.~\ref{code:virtual-layer:coop-close-intermediary:host-of-fundee-revoke}),
  then $[c_2']$ (Fig.~\ref{code:virtual-layer:coop-close-intermediary},
  l.~\ref{code:virtual-layer:coop-close-intermediary:first-invoke-guest}) is
  appended to $C$. In case $P$ was a left intermediary for the closed virtual
  channel (Fig.~\ref{code:virtual-layer:coop-close-intermediary},
  l.~\ref{code:virtual-layer:coop-close-intermediary:first-activation-guest}),
  then $[c_2']$ is appended to $C$.
  Lastly, in case $P$ was a right intermediary for the closed
  virtual channel (Fig.~\ref{code:virtual-layer:coop-close-intermediary},
  l.~\ref{code:virtual-layer:coop-close-intermediary:first-activation-guest-sibling}),
  then $[c_1' - c_{\mathrm{virt}}]$ is appended to $C$. Therefore $C$ consists
  of one list of integers for each sequence of inbound and outbound payments
  that have not been interrupted by a virtualisation step and a new list is
  added for every virtual layer that is created or torn down cooperatively. We
  also observe that a non-negligent party with history $(F, C)$ satisfies the
  Lemma conditions and that the value of the right hand side of the
  inequality~(\ref{lemma:real-balance-security:ineq}) is equal to
  $\sum\limits_{s \in C} \sum\limits_{x \in s} x$, as all inbound and outbound
  payment values, new channel funding values and cooperative closing refunds
  that appear in the Lemma conditions are recorded in $C$.

  Let party $P$ with a particular history. We will inductively prove that $P$
  satisfies the Lemma. The base case is when a channel is opened with
  $\texttt{hops} =$ ``\texttt{ledger}'' and is closed right away, therefore $H =
  ([], [g])$, where $g = c$ if $P = \alice$ and $g = 0$ if $P = \bob$.  $P$ can
  transition to the \textsc{open} \textit{State} for the first time only if all
  of the following have taken place:
  \begin{itemize}
    \item It has received (\textsc{open}, $c$, $\dots$) while in the
    \textsc{init} \textit{State}. In case $P = \alice$, this message must have
    been received as input by \environment (Fig.~\ref{code:ln:open},
    l.~\ref{code:ln:open:alice-open}), or in case $P = \bob$, this message must
    have been received via the network by $\bar{P}$
    (Fig.~\ref{code:ln:exchange-open-keys},
    l.~\ref{code:ln:exchange-open-keys:bob-open}).
    \item It has received $\pk{\bar{P}, F}$. In case $P = \bob$, $\pk{\bar{P},
    F}$ must have been contained in the (\textsc{open}, $\dots$) message by
    $\bar{P}$ (Fig.~\ref{code:ln:exchange-open-keys},
    l.~\ref{code:ln:exchange-open-keys:bob-open}), otherwise if $P = \alice$
    $\pk{\bar{P}, F}$ must have been contained in the (\textsc{accept channel},
    $\dots$) message by $\bar{P}$ (Fig.~\ref{code:ln:exchange-open-keys},
    l.~\ref{code:ln:exchange-open-keys:accept-channel}).
    \item It internally holds a signature on the commitment transaction $C_{P,
    0}$ that is valid when verified with public key $\pk{\bar{P}, F}$
    (Fig.~\ref{code:ln:exchange-open-sigs},
    ll.~\ref{code:ln:exchange-open-sigs:b-verify}
    and~\ref{code:ln:exchange-open-sigs:a-verify}).
    \item It has the transaction $F$ in the \ledger state
    (Fig.~\ref{code:ln:commit-base}, l.~\ref{code:ln:commit-base:f-in-state} or
    Fig.~\ref{code:ln:bob}, l.~\ref{code:ln:bob:state-open}).
  \end{itemize}

  We observe that $P$ satisfies the Lemma conditions with $m = n = l = 0$.
  Before transitioning to the \textsc{open} \textit{State}, $P$ has produced
  only one valid signature for the ``funding'' output $(c, 2/\{\pk{P, F},
  \pk{\bar{P}, F}\})$ of $F$ with $\sk{P, F}$, namely for $C_{\bar{P}, 0}$
  (Fig.~\ref{code:ln:exchange-open-sigs},
  ll.~\ref{code:ln:exchange-open-sigs:a-sign}
  or~\ref{code:ln:exchange-open-sigs:b-sign}), and sent it to $\bar{P}$
  (Fig.~\ref{code:ln:exchange-open-sigs},
  ll.~\ref{code:ln:exchange-open-sigs:a-send}
  or~\ref{code:ln:exchange-open-sigs:b-send}), therefore the only two ways to
  spend $(c, 2/\{\pk{P, F}, \pk{\bar{P}, F}\})$ are by either publishing $C_{P,
  0}$ or $C_{\bar{P}, 0}$. We observe that $C_{P, 0}$ has a ($g$, ($\pk{P,
  \mathrm{out}} + (t + s)$) $\vee$ $2/\{\pk{P, R}, \pk{\bar{P}, R}\}$) output
  (Fig.~\ref{code:ln:exchange-open-sigs},
  l.~\ref{code:ln:exchange-open-sigs:a-tx}
  or~\ref{code:ln:exchange-open-sigs:b-tx}). The spending method $2/\{\pk{P, R},
  \pk{\bar{P}, R}\}$ cannot be used since $P$ has not produced a signature for
  it with $\sk{P, R}$, therefore the alternative spending method, $\pk{P,
  \mathrm{out}} + (t + s)$, is the only one that will be spendable if $C_{P, 0}$
  is included in \ledger, thus contributing $g$ to the sum of outputs that
  contribute to inequality~(\ref{lemma:real-balance-security:ineq}). Likewise,
  if $C_{\bar{P}, 0}$ is included in \ledger, it will contribute at least one
  ($g$, $\pk{P, \mathrm{out}}$) output to this inequality, as $C_{\bar{P}, 0}$
  has a ($g$, $\pk{P, \mathrm{out}}$) output
  (Fig.~\ref{code:ln:exchange-open-sigs},
  l.~\ref{code:ln:exchange-open-sigs:a-tx}
  or~\ref{code:ln:exchange-open-sigs:b-tx}). Additionally, if $P$ receives
  (\textsc{forceClose}) by \environment while $H = ([], [g])$, it attempts to publish
  $C_{P, 0}$ (Fig.~\ref{code:ln:close}, l.~\ref{code:ln:close:submit}), and will
  either succeed or $C_{\bar{P}, 0}$ will be published instead. We therefore
  conclude that in every case \ledger will eventually have a state $\Sigma$ that
  contains at least one $(g, \pk{P, \mathrm{out}})$ output, therefore satisfying
  the Lemma consequence.

  Let $P$ with history $H = (F, C)$. The induction hypothesis is that the Lemma
  holds for $P$. Let $c_P$ the sum in the right hand side of
  inequality~(\ref{lemma:real-balance-security:ineq}). In order to perform the
  induction step, assume that $P$ is in the \textsc{open} state. We will prove
  all the following (the facts to be proven are shown with emphasis for
  clarity):
  \begin{itemize}
    \item If $P$ receives (\textsc{fund me}, $f$, $\dots$) by a (local, kindred)
    \textsc{ln} ITI $R$, subsequently transitions back to the \textsc{open}
    state (therefore moving to history $(F, C')$ where $C' = C + [-f]$) and
    finally receives (\textsc{forceClose}) by \environment and (\textsc{closed}) by
    $\texttt{host}_P$ before any further change to its history, then
    \emph{eventually $P$'s \ledger state will contain $h$ transaction outputs
    each of value $c_i$ exclusively spendable or already spent by $\pk{P,
    \mathrm{out}}$ that are descendants of an output with spending method
    $2/\{\pk{P, F}, \pk{\bar{P}, F}\}$ such that $\sum\limits_{i=1}^h c_i \geq
    \sum\limits_{s \in C'} \sum\limits_{x \in s} x$}. Furthermore, given that
    $P$ moves to the \textsc{open} state after the (\textsc{fund me}, $\dots$)
    message, it also sends (\textsc{funded}, $\dots$) to $R$
    (Fig.~\ref{code:ln:virtualise:start-end},
    l.~\ref{code:ln:virtualise:start-end:funder-funded}). If subsequently the
    state of $R$ transitions to \textsc{open} (therefore obtaining history
    $(F_R, C_R)$ where $F_R = F + C$ and $C_R = [[f]]$), and finally receives
    (\textsc{forceClose}) by \environment and (\textsc{closed}) by $\texttt{host}_R$
    ($\texttt{host}_R = \texttt{host}_P$ -- Fig.~\ref{code:ln:bob},
    l.~\ref{code:ln:bob:host}) before any further change to its history, then
    \emph{eventually $R$'s \ledger state will contain $k$ transaction outputs
    each of value $c^R_i$ exclusively spendable or already spent by $\pk{R,
    \mathrm{out}}$ that are descendants of an output with spending method
    $2/\{\pk{R, F}, \pk{\bar{R}, F}\}$ such that $\sum\limits_{i=1}^k c^R_i \geq
    \sum\limits_{s \in C_R} \sum\limits_{x \in s} x$}.
    \item If $P$ receives (\textsc{virtualising}, $\dots$) by $\bar{P}$ or
    \texttt{sibling},
    subsequently transitions back to \textsc{open} (therefore moving to history
    $(F, C')$ where $C' = C + [0]$) and finally receives (\textsc{forceClose}) by
    \environment and (\textsc{closed}) by $\texttt{host}_P$ before any further
    change to its history, then \emph{eventually $P$'s \ledger state will
    contain $h$ transaction outputs each of value $c_i$ exclusively spendable or
    already spent by $\pk{P, \mathrm{out}}$ that are descendants of an output
    with spending method $2/\{\pk{P, F}, \pk{\bar{P}, F}\}$ such that
    $\sum\limits_{i=1}^h c_i \geq \sum\limits_{s \in C} \sum\limits_{x \in s}
    x$}. Furthermore, given that $P$ moves to the \textsc{open} state after the
    (\textsc{virtualising}, $\dots$) message and in case it sends
    (\textsc{funded}, $\dots$) to some party $R$
    (Fig.~\ref{code:ln:virtualise:start-end},
    l.~\ref{code:ln:virtualise:start-end:helper-output-funded}), the latter
    party is the (local, kindred) \texttt{fundee} of a new virtual channel. If
    subsequently the state of $R$ transitions to \textsc{open} (therefore
    obtaining history $(F_R, C_R)$ where $F_R = F + C$ and $C_R = [[0]]$), and
    finally receives (\textsc{forceClose}) by \environment and (\textsc{closed}) by
    $\texttt{host}_R$ ($\texttt{host}_R = \texttt{host}_P$ --
    Fig.~\ref{code:ln:bob}, l.~\ref{code:ln:bob:host}) before any further change
    to its history, then \emph{eventually $R$'s \ledger state will contain an
    output with a $2/\{\pk{R, F}, \pk{\bar{R}, F}\}$ spending method.}
    \item If $P$ receives (\textsc{check coop close}, $\dots$) by
    $\texttt{host}_P$, subsequently transitions back to \textsc{open} (therefore
    moving to history $(F, C')$ where $C' = C + [c_2']$), and finally receives
    (\textsc{forceClose}) by \environment and (\textsc{closed}) by
    $\texttt{host}_P$ before any further change to its history, then
    \emph{eventually $P$'s \ledger state will contain $h$ transaction outputs
    each of value $c_i$ exclusively spendable or already spent by $\pk{P,
    \mathrm{out}}$ that are descendants of an output with spending method
    $2/\{\pk{P, F}, \pk{\bar{P}, F}\}$ such that $\sum\limits_{i=1}^h c_i \geq
    \sum\limits_{s \in C} \sum\limits_{x \in s} x$.}
    \item If $P$ receives (\textsc{coop close sign comm}, $\dots$) by
    $\texttt{host}_P$, subsequently transitions back to \textsc{open} (therefore
    moving to history $(F, C')$ where $C' = C + [c_1' - c_{\mathrm{virt}}]$),
    and finally receives (\textsc{forceClose}) by \environment and
    (\textsc{closed}) by $\texttt{host}_P$ before any further change to its
    history, then \emph{eventually $P$'s \ledger state will contain $h$
    transaction outputs each of value $c_i$ exclusively spendable or already
    spent by $\pk{P, \mathrm{out}}$ that are descendants of an output with
    spending method $2/\{\pk{P, F}, \pk{\bar{P}, F}\}$ such that
    $\sum\limits_{i=1}^h c_i \geq \sum\limits_{s \in C} \sum\limits_{x \in s}
    x$.} Furthermore, \emph{there exists a local, kindred machine $R$ that
    transitioned to the \textsc{open} state after the last time control was
    obtained by one of $P$'s kindred machines and before $P$ transitioned to the
    \textsc{open} state, such that $R$ obtained $c_2' = c_{\mathrm{virt}} -
    c_1'$ coins during its last activation.} (In other words, $P$ and $R$ broke
    even on aggregate by first supporting the opening and then the cooperative
    closing of a virtual channel.)
    \item If $P$ receives (\textsc{coop close sig comm funder}, $\dots$) by
    $\texttt{host}_P$, subsequently transitions back to \textsc{open} (therefore
    moving to history $(F, C')$ where $C' = C + [c_1']$) and finally receives
    (\textsc{forceClose}) by \environment and (\textsc{closed}) by
    $\texttt{host}_P$ before any further change to its history, then
    \emph{eventually $P$'s \ledger state will contain $h$ transaction outputs
    each of value $c_i$ exclusively spendable or already spent by $\pk{P,
    \mathrm{out}}$ that are descendants of an output with spending method
    $2/\{\pk{P, F}, \pk{\bar{P}, F}\}$ such that $\sum\limits_{i=1}^h c_i \geq
    \sum\limits_{s \in C} \sum\limits_{x \in s} x$.}
    \item If $P$ receives (\textsc{check coop close fundee}, $\dots$) by
    $\texttt{host}_P$, subsequently transitions back to \textsc{open} (therefore
    moving to history $(F, C')$ where $C' = C + [c_2']$) and finally receives
    (\textsc{forceClose}) by \environment and (\textsc{closed}) by
    $\texttt{host}_P$ before any further change to its history, then
    \emph{eventually $P$'s \ledger state will contain $h$ transaction outputs
    each of value $c_i$ exclusively spendable or already spent by $\pk{P,
    \mathrm{out}}$ that are descendants of an output with spending method
    $2/\{\pk{P, F}, \pk{\bar{P}, F}\}$ such that $\sum\limits_{i=1}^h c_i \geq
    \sum\limits_{s \in C} \sum\limits_{x \in s} x$.}
    \item If $P$ receives (\textsc{pay}, $d$) by \environment, subsequently
    transitions back to \textsc{open} (therefore moving to history $(F, C')$
    where $C'$ is $C$ with $-d$ appended to the last list of $C$) and finally
    receives (\textsc{forceClose}) by \environment and (\textsc{closed}) by
    $\texttt{host}_P$ (the latter only if $\texttt{host}_P \neq$ ``\texttt{ledger}'' or
    equivalently $F \neq []$) before any further change to its history, then
    \emph{eventually $P$'s \ledger state will contain $h$ transaction outputs
    each of value $c_i$ exclusively spendable or already spent by $\pk{P,
    \mathrm{out}}$ that are descendants of an output with a $2/\{\pk{P, F},
    \pk{\bar{P}, F}\}$ spending method such that $\sum\limits_{i=1}^h c_i \geq
    \sum\limits_{s \in C'} \sum\limits_{x \in s} x$}.
    \item If $P$ receives (\textsc{get paid}, $e$) by \environment, subsequently
    transitions back to \textsc{open} (therefore moving to history $(F, C')$
    where $C'$ is $C$ with $e$ appended to the last list of $C$) and finally
    receives (\textsc{forceClose}) by \environment and (\textsc{closed}) by
    $\texttt{host}_P$ (the latter only if $\texttt{host}_P \neq$ ``\texttt{ledger}'' or
    equivalently $F = []$) before any further change to its history, then
    \emph{eventually $P$'s \ledger state will contain $h$ transaction outputs
    each of value $c_i$ exclusively spendable or already spent by $\pk{P,
    \mathrm{out}}$ that are descendants of an output with a $2/\{\pk{P, F},
    \pk{\bar{P}, F}\}$ spending method such that $\sum\limits_{i=1}^h c_i \geq
    \sum\limits_{s \in C'} \sum\limits_{x \in s} x$}.
  \end{itemize}

  Consider the first bullet.
  By the induction hypothesis, before the funding procedure started $P$ could
  close the channel and end up with on-chain transaction outputs exclusively
  spendable or already spent by $\pk{P, \mathrm{out}}$ with a sum value of
  $c_P$. When $P$ is in the \textsc{open} state and receives (\textsc{fund me},
  $f$, $\dots$), it can only move again to the \textsc{open} state after doing
  the following state transitions: \textsc{open} $\rightarrow$
  \textsc{virtualising} $\rightarrow$ \textsc{waiting for revocation}
  $\rightarrow$ \textsc{waiting for inbound revocation} $\rightarrow$
  \textsc{waiting for hosts ready} $\rightarrow$ \textsc{open}. During this
  sequence of events, a new $\texttt{host}_P$ is defined
  (Fig.~\ref{code:ln:virtualise:start-end},
  l.~\ref{code:ln:virtualise:start-end:define}), new commitment transactions are
  negotiated with $\bar{P}$ (Fig.~\ref{code:ln:virtualise:start-end},
  l.~\ref{code:ln:virtualise:start-end:virtual-update}), control of the old
  funding output is handed over to $\texttt{host}_P$
  (Fig.~\ref{code:ln:virtualise:start-end},
  l.~\ref{code:ln:virtualise:start-end:host-me}), $\texttt{host}_P$ negotiates
  with its counterparty a new set of transactions and signatures that spend the
  aforementioned funding output and make available a new funding output with the
  keys $\pk{P, F}', \pk{\bar{P}, F}'$ as $P$ instructed
  (Fig.~\ref{code:virtual-layer:funder-sigs}
  and~\ref{code:virtual-layer:funding-sigs}) and the previous valid commitment
  transactions of both $P$ and $\bar{P}$ are invalidated
  (Fig.~\ref{code:ln:methods-for-virt},
  l.~\ref{code:ln:methods-for-virt:revoke-previous} and
  l.~\ref{code:ln:methods-for-virt:process-remote-revocation} respectively). We
  note that the use of the \texttt{ANYPREVOUT} flag in all signatures that
  correspond to transaction inputs that may spend various different transaction
  outputs ensures that this is possible, as it avoids tying each input to a
  specific, predefined output. When $P$ receives (\textsc{forceClose}) by
  \environment, it inputs (\textsc{forceClose}) to $\texttt{host}_P$
  (Fig.~\ref{code:ln:close}, l.~\ref{code:ln:close:relay}). As per the Lemma
  conditions, $\texttt{host}_P$ will output (\textsc{closed}). This can happen
  only when \ledger contains a suitable output for both $P$'s and $R$'s channel
  (Fig.~\ref{code:virtual-layer:check-chain-close},
  l.~\ref{code:virtual-layer:check-chain-close:funder:output-funder} and
  l.~\ref{code:virtual-layer:check-chain-close:funder:output-virt}
  respectively).

  If the \texttt{host} of $\texttt{host}_P$ is ``\texttt{ledger}'', then the funding output
  $o_{1, 2} = (c_P + c_{\bar{P}}, 2/\{\pk{P, F}, \pk{\bar{P}, F}\})$ for the
  $P, \bar{P}$ channel is already on-chain. Regarding the case in which
  $\texttt{host}_P \neq$ ``\texttt{ledger}'', after the funding procedure is complete, the
  new $\texttt{host}_P$ will have as its \texttt{host} the old $\texttt{host}_P$
  of $P$. If the (\textsc{forceClose}) sequence is initiated, the new
  $\texttt{host}_P$ will follow the same steps that will be described below once
  the old $\texttt{host}_P$ succeeds in closing the lower layer
  (Fig.~\ref{code:virtual-layer:close},
  l.~\ref{code:virtual-layer:close:if-nested-host}). The old $\texttt{host}_P$
  however will see no difference in its interface compared to what would happen
  if $P$ had received (\textsc{forceClose}) before the funding procedure, therefore
  it will successfully close by the induction hypothesis. Thereafter the process
  is identical to the one when the old $\texttt{host}_P =$ ``\texttt{ledger}''.

  Moving on, $\texttt{host}_P$ is either able to publish its $\mathrm{TX}_{1,
  1}$ (it has necessarily received a valid signature
  $\mathrm{sig}(\mathrm{TX}_{1, 1}, \pk{\bar{P}, F})$
  (Fig.~\ref{code:virtual-layer:funding-sigs},
  l.~\ref{code:virtual-layer:funding-sigs:funder-check-sig}) by its counterparty
  before it moved to the \textsc{open} state for the first time), or the output
  $(c_P + c_{\bar{P}}, 2/\{\pk{P, F}, \pk{\bar{P}, F}\})$ needed to publish
  $\mathrm{TX}_{1, 1}$ has already been spent. The only other transactions that
  can spend it are $\mathrm{TX}_{2, 1}$ and any of $(\mathrm{TX}_{2, 2, k})_{k >
  2}$, since these are the only transactions that spend the aforementioned
  output and that $\texttt{host}_P$ has signed with $\sk{P, F}$
  (Fig.~\ref{code:virtual-layer:funding-sigs},
  ll.~\ref{code:virtual-layer:funding-sigs:funder-sign-first}-\ref{code:virtual-layer:funding-sigs:funder-sign-second-end}).
  The output can be also spent by old, revoked commitment transactions, but in
  that case $\texttt{host}_P$ would not have output (\textsc{closed}); $P$ would
  have instead detected this triggered by a (\textsc{check chain for closed})
  message by \environment (Fig.~\ref{code:ln:poll}) and would have moved to the
  \textsc{closed} state on its own accord (lack of such a message by
  \environment would lead $P$ to become \texttt{negligent}, something that
  cannot happen according to the Lemma conditions). Every transaction among
  $\mathrm{TX}_{1, 1}$, $\mathrm{TX}_{2, 1}$, $(\mathrm{TX}_{2, 2, k})_{k > 2}$
  has a ($c_P + c_{\bar{P}} - f$, $2/\{\pk{P, F}', \pk{\bar{P}, F}'\}$) output
  (Fig.~\ref{code:virtual-layer:endpoint-txs},
  l.~\ref{code:virtual-layer:endpoint-txs:new-fund} and
  Fig.~\ref{code:virtual-layer:mid-txs},
  ll.~\ref{code:virtual-layer:mid-txs:initiator:left-new-fund}
  and~\ref{code:virtual-layer:mid-txs:extend-interval-right:new-fund}) which
  will end up in \ledger{} -- call this output $o_P$. We will prove that at most
  $\sum\limits_{i=2}^{n-1}(t_i + p + s - 1)$ blocks after (\textsc{forceClose}) is
  received by $P$, an output $o_R$ with $c_{\mathrm{virt}}$ coins and a
  $2/\{\pk{R, F}, \pk{\bar{R}, F}\}$ spending condition without or with an
  expired timelock will be included in \ledger. In case party $\bar{P}$ is idle,
  then $o_{1, 2}$ is consumed by $\mathrm{TX}_{1, 1}$ and the timelock on its
  virtual output expires, therefore the required output $o_R$ is on-chain. In
  case $\bar{P}$ is active, exactly one of $\mathrm{TX}_{2, 1}$,
  $(\mathrm{TX}_{2, 2, k})_{k > 2}$ or $(\mathrm{TX}_{2, 3, 1, k})_{k > 2}$ is a
  descendant of $o_{1, 2}$; if the transaction belongs to one of the two last
  transaction groups then necessarily $\mathrm{TX}_{1, 1}$ is on-chain in some
  block height $h$ and given the timelock on the virtual output of
  $\mathrm{TX}_{1, 1}$, $\bar{P}$'s transaction can be at most at block height
  $h + t_2 + p + s - 1$. If $n=3$ or $k=n-1$, then $\bar{P}$'s unique
  transaction has the required output $o_R$ (without a timelock). The rest of
  the cases are covered by the following sequence of events:

  \begin{center}
    \begin{notitlebox}{Closing sequence}
      \begin{algorithmic}[1]
        \State $\texttt{maxDel} \gets t_2 + p + s - 1$ \Comment{$A_2$ is active
        and the virtual output of $\mathrm{TX}_{1, 1}$ has a timelock of $t_2$}
        \State $i \gets 3$
        \label{code:settling-process:init-i}
        \State \textbf{loop}
        \Indent
          \If{$A_i$ is idle}
            \State The timelock on the virtual output of the transaction
            published by $A_{i-1}$ expires and therefore the required $o_R$ is
            on-chain
          \Else \: \Comment{$A_i$ publishes a transaction that is a descendant
          of $o_{1, 2}$}
            \State $\texttt{maxDel} \gets \texttt{maxDel} + t_i + p + s - 1$
            \State The published transaction can be of the form $\mathrm{TX}_{i,
            2, 2}$ or $(\mathrm{TX}_{i, 3, 2, k})_{k > i}$ as it spends the
            virtual output which is encumbered with a public key controlled by
            $R$ and $R$ has only signed these transactions
            \If{$i = n-1$ or $k \geq n-1$} \Comment{The interval contains all
            intermediaries}
              \State The virtual output of the transaction is not timelocked and
              has only a $2/\{\pk{R, F}, \pk{\bar{R}, F}\}$ spending method,
              therefore it is the required $o_R$
            \Else \: \Comment{At least one intermediary is not in the interval}
              \IfThenElse{the transaction is $\mathrm{TX}_{i, 3, 2, k}$}{$i
              \gets k$}{$i \gets i+1$}
              \label{code:settling-process:increment}
            \EndIf
          \EndIf
        \EndIndent
        \State \textbf{end loop}
        \State \Comment{$\texttt{maxDel} \leq \sum\limits_{i=2}^{n-1}(t_i + p +
        s - 1)$}
      \end{algorithmic}
    \end{notitlebox}
    \captionof{figure}{}
    \label{code:settling-process}
  \end{center} \ \\

  In every case $o_P$ and $o_R$ end up on-chain in at most $s$ and
  $\sum\limits_{i=2}^{n-1}(t_i + p + s - 1)$ blocks respectively from the moment
  (\textsc{forceClose}) is received. The output $o_P$ an be spent either by $C_{P,
  i}$ or $C_{\bar{P}, i}$. Both these transactions have a $(c_P - f, \pk{P,
  \mathrm{out}})$ output. This output of $C_{P, i}$ is timelocked, but the
  alternative spending method cannot be used as $P$ never signed a transaction
  that uses it (as it is reserved for revocation, which has not taken place yet
  in this virtualisation layer). We have now proven that if $P$ completes the
  funding of a new channel then it can close its channel for a ($c_P - f$,
  $\pk{P, \mathrm{out}}$) output that is a descendant of an output with spending
  method $2/\{\pk{P, F}, \pk{\bar{P}, F}\}$ and that lower bound of value holds
  for the duration of the funding procedure, i.e.\ we have proven the first claim
  of the first bullet.

  We will now prove that the newly funded party $R$ can close its channel
  securely. After $R$ receives (\textsc{funded}, $\texttt{host}_P$, $\dots$) by
  $P$ and before moving to the \textsc{open} state, it receives
  $\mathrm{sig}_{\bar{R}, C, 0} =$ sig($C_{R, 0}$, $\pk{\bar{R}, F}$) and sends
  $\mathrm{sig}_{R, C, 0} =$ sig($C_{\bar{R}, 0}$, $\pk{R, F}$). Both these
  transactions spend $o_R$. As we showed before, if $R$ receives
  (\textsc{forceClose}) by \environment then $o_R$ eventually ends up on-chain. After
  receiving (\textsc{closed}) from $\texttt{host}_P$, $R$ attempts to add $C_{R,
  0}$ to \ledger, which may only fail if $C_{\bar{R}, 0}$ ends up on-chain
  instead. Similar to the case of $P$, both these transactions have an $(f,
  \pk{R, \mathrm{out}})$ output. This output of $C_{R, 0}$ is timelocked, but
  the alternative spending method cannot be used as $R$ never signed a
  transaction that uses it (as it is reserved for revocation, which has not
  taken place yet) so the timelock will expire and the desired spending method
  will be available. We have now proven that if $R$'s channel is funded to
  completion (i.e.\ $R$ moves to the \textsc{open} state for the first time) then
  it can close its channel for a ($f$, $\pk{R, \mathrm{out}}$) output that is a
  descendant of $o_R$. We have therefore proven the first bullet.

  We now move on to the second bullet. In case $P$ is the \texttt{fundee} (i.e.\
  $i=n$), then the same arguments as in the previous bullet hold here with
  ``\textsc{waiting for inbound revocation}'' replaced with ``\textsc{waiting
  for outbound revocation}'', $o_{1, 2}$ with $o_{n-1, n}$, $\mathrm{TX}_{1, 1}$
  with $\mathrm{TX}_{n, 1}$, $\mathrm{TX}_{2, 1}$ with $\mathrm{TX}_{n-1, 1}$,
  $(\mathrm{TX}_{2, 2, k})_{k > 2}$ with $(\mathrm{TX}_{n-1, 2, k})_{k < n-1}$,
  $(\mathrm{TX}_{2, 3, 1, k})_{k > 2}$ with $(\mathrm{TX}_{n-1, 3, n, k})_{k <
  n-1}$, $t_2$ with $t_{n-1}$, $\mathrm{TX}_{i, 3, 2, k}$ with $\mathrm{TX}_{i,
  3, n-1, k}$, $i$ is initialized to $n-2$ in
  l.~\ref{code:settling-process:init-i} of Fig.~\ref{code:settling-process}, $i$
  is decremented instead of incremented in
  l.~\ref{code:settling-process:increment} of the same Figure and $f$ is
  replaced with $0$. This is so because these two cases are symmetric.

  In case $P$ is not the \texttt{fundee} ($1<i<n$), then we only need to prove
  the first statement of the second bullet. By the induction hypothesis and
  since \texttt{sibling} is kindred, we know that both $P$'s and
  \texttt{sibling}'s funding outputs either are or can be eventually put
  on-chain and that $P$'s funding output has at least $c_P = \sum\limits_{s \in
  C} \sum\limits_{x \in s} x$ coins. If $P$ is on the ``left'' of its
  \texttt{sibling} (i.e.\ there is an untrusted party that sent the
  (\textsc{virtualising}, $\dots$) message to $P$ which triggered the latter to
  move to the \textsc{virtualising} state and to send a (\textsc{virtualising},
  $\dots$) message to its own \texttt{sibling}), the ``left'' funding output
  $o_{\mathrm{left}}$ (the one held with the untrusted party to the left) can be
  spent by one of $\mathrm{TX}_{i, 1}$, $(\mathrm{TX}_{i, 2, k})_{k > i}$,
  $\mathrm{TX}_{i-1, 1}$, or $(\mathrm{TX}_{i-1, 2, k})_{k < i-1}$, as these are
  the only transactions that $P$ has signed with $\sk{P, F}$. All these
  transactions have a ($c_P + c_{\bar{P}} - f$, $2/\{\pk{P, F'}, \pk{\bar{P},
  F'}\}$) output that can in turn be spent by either $C_{P, 0}$ or $C_{\bar{P},
  0}$, both of which have an output of value $c_P$ and a $\pk{P, \mathrm{out}}$
  spending method and no other spending method can be used (as $P$ has not
  signed the ``revocation'' spending method of $C_{P, 0}$).

  In the case that $P$ is to the right of its \texttt{sibling} (i.e.\ $P$
  receives by \texttt{sibling} the (\textsc{virtualising}, $\dots$) message that
  causes $P$'s transition to the \textsc{virtualising} state), the ``right''
  funding output $o_{\mathrm{right}}$ (the one held with the untrusted party to
  the right) can be spent by one of $\mathrm{TX}_{i, 1}$, $(\mathrm{TX}_{i, 2,
  k})_{k < i}$, $\mathrm{TX}_{i+1, 1}$, or $(\mathrm{TX}_{i+1, 2, k})_{k >
  i+1}$, as these are the only transactions that $P$ has signed with $\sk{P,
  F}$. All these transactions have a ($c_P + c_{\bar{P}} - f$, $2/\{\pk{P, F'},
  \pk{\bar{P}, F'}\}$) output that can in turn be spent by either $C_{P, 0}$ or
  $C_{\bar{P}, 0}$, both of which have an output of value $c_P-f$ and a $\pk{P,
  \mathrm{out}}$ spending method and no other spending method can be used (as
  $P$ has not signed the ``revocation'' spending method of $C_{P, 0}$). $P$ can
  get the remaining $f$ coins as follows: $\mathrm{TX}_{i, 1}$ and all of
  $(\mathrm{TX}_{i, 2, k})_{k < i}$ already have an ($f$, $\pk{P,
  \mathrm{out}}$) output (Note that this output is also
  encumbered with a timelock, but the alternative spending method cannot be used
  as $\texttt{host}_P$ has not signed the required revocation transaction). If
  instead $\mathrm{TX}_{i+1, 1}$ or one of
  $(\mathrm{TX}_{i+1, 2, k_2})_{k_2 > i+1}$ spends $o_{\mathrm{right}}$, then
  $P$ will publish $\mathrm{TX}_{i, 2, i+1}$ or $\mathrm{TX}_{i, 2, k_2}$
  respectively if $o_{\mathrm{left}}$ is unspent, otherwise $o_{\mathrm{left}}$
  is spent by one of $\mathrm{TX}_{i-1, 1}$ or $(\mathrm{TX}_{i-1, 2, k_1})_{k_1
  < i-1}$ in which case $P$ will publish one of $\mathrm{TX}_{i, 3, k_1, i+1}$,
  $\mathrm{TX}_{i, 3, i-1, k_2}$, $\mathrm{TX}_{i, 3, i-1, i+1}$ or
  $\mathrm{TX}_{i, 3, k_1, k_2}$. In particular, $\mathrm{TX}_{i, 3, k_1, i+1}$
  is published if $\mathrm{TX}_{i-1, 2, k_1}$ and $\mathrm{TX}_{i+1, 1}$ are
  on-chain, $\mathrm{TX}_{i, 3, i-1, k_2}$ is published if $\mathrm{TX}_{i-1,
  1}$ and $\mathrm{TX}_{i+1, 2, k_2}$ are on-chain, $\mathrm{TX}_{i, 3, i-1,
  i+1}$ is published if $\mathrm{TX}_{i-1, 1}$ and $\mathrm{TX}_{i+1, 1}$ are
  on-chain, or $\mathrm{TX}_{i, 3, k_1, k_2}$ is published if $\mathrm{TX}_{i-1,
  2, k_1}$ and $\mathrm{TX}_{i+1, 2, k_2}$ are on-chain.  All these transactions
  include an ($f$, $\pk{P, \mathrm{out}}$) output for which the revocation-based
  spending methd cannot be used since $\texttt{host}_P$ has not produced the
  corresponding signature for the revocation transaction. We have therefore
  covered all cases and proven the second bullet.

  We now focus on the third bullet. Once more the induction hypothesis
  guarantees that before (\textsc{check coop close}, $\dots$) was received, $P$
  could close the channel resulting in on-chain outputs exclusively spendable or
  already spent by $\pk{P, \mathrm{out}}$ that are descendants of an output
  $o_F$ with a $2/\{\pk{P, F}, \pk{\bar{P}, F}\}$ spending method that have a
  sum value of $c_P = \sum\limits_{s \in C} \sum\limits_{x \in s} x$. When $P$
  receives (\textsc{check coop close}, $\dots$), it moves to the \textsc{coop
  closing} state before returning to the \textsc{open} state. It verifies the
  counterparty's signature on the new commitment transaction $C_{P, i+1}$,
  (Fig.~\ref{code:virtual-layer:coop-close-intermediary},
  l.~\ref{code:virtual-layer:coop-close-intermediary:left-interm-verify-comm})
  which spends the latest old funding output
  (Fig.~\ref{code:virtual-layer:coop-close-intermediary},
  l.~\ref{code:virtual-layer:coop-close-intermediary:left-old-fund-keys}),
  effectively removing one virtualisation layer. In $C_{P, i+1}$ $P$ owns $c_2'$
  more coins than before that moment
  (Fig.~\ref{code:virtual-layer:coop-close-intermediary},
  l.~\ref{code:virtual-layer:coop-close-intermediary:left-interm-comm}). It then
  signs the corresponding commitment transaction for the counterparty
  (Fig.~\ref{code:virtual-layer:coop-close-intermediary},
  l.~\ref{code:virtual-layer:coop-close-intermediary:left-interm-sign-comm}) and
  expects a valid signature for the revocation transaction of the old commitment
  transaction of the counterparty
  (Fig.~\ref{code:virtual-layer:coop-close-intermediary},
  l.~\ref{code:virtual-layer:coop-close-intermediary:left-interm-verify-rev}).
  Once these are received, $P$ transitions to the \textsc{open} state. If the
  $o_F$ output is spent while $P$ is in the \textsc{coop closing} state, it can
  be spent by one of $C_{P, i+1}$ or some of $(C_{\bar{P}, j})_{0 \leq j \leq
  i+1}$. If it is spent by $C_{P, i+1}$ or $C_{\bar{P}, i+1}$, then these two
  transactions have a ($c_P + c_2'$, $\pk{P, \mathrm{out}}$) output. (Note that
  the former is encumbered with a timelock, but the alternative spending method
  cannot be used as $P$ has not signed $R_{\bar{P}, i+1}$.) If it is spent by
  $C_{\bar{P}, i}$ then a ($c_P$, $\pk{P, \mathrm{out}}$) output becomes
  available instead, therefore $P$ can still get the $c_P$ coins that correspond
  to the previous state. If any of $(C_{\bar{P}, j})_{0 \leq j < i}$ spends this
  or another of our past funding outputs then it makes available a $\pk{P,
  \mathrm{out}}$ output with the coins that $P$ had at state $j$ and
  additionally $P$ can publish $R_{P, j}$ that spends $\bar{P}$'s output of
  $C_{\bar{P}, j}$ and obtain the entirety of $\bar{P}$'s coins at state $j$ for
  a total of $c_P + c_{\bar{P}}$ coins. What is more, if $o_F$ is spent by any
  virtual transaction, then $\texttt{host}_P$ will punish the publisher of such
  transaction with the corresponding virtual revocation transaction
  (Fig.~\ref{code:virtual-layer:coop-close-intermediary},
  l.~\ref{code:virtual-layer:coop-close-intermediary:verify-right-virt-rev},
  l.~\ref{code:virtual-layer:coop-close-intermediary:verify-right-fund-rev},
  l.~\ref{code:virtual-layer:coop-close-intermediary:verify-left-virt-rev-end},
  l.~\ref{code:virtual-layer:coop-close-intermediary:verify-left-virt-rev-start},
  l.~\ref{code:virtual-layer:coop-close-intermediary:verify-left-virt-rev-left}
  and l.~\ref{code:virtual-layer:coop-close-intermediary:verify-left-fund-rev})
  at the latest when $P$ receives (\textsc{check chain for closed})
  (Fig.~\ref{code:ln:poll}, l.~\ref{code:ln:poll:hosts-poll}) -- note that the
  latter message is received periodically by $P$, since it is a non-negligent
  party. The virtual revocation transaction gives a sum equal to the entirety of
  the channel's funds to $P$. Therefore in every case $P$ can claim at least
  $c_P$ coins. In the case that $P$ instead
  subsequently receives a valid signature to $R_{P, i}$
  (Fig.~\ref{code:virtual-layer:coop-close-intermediary},
  l.~\ref{code:virtual-layer:coop-close-intermediary:left-interm-verify-rev})
  and moves to the \textsc{open} state, the above analysis of what can happen
  when $o_F$ is spent holds similarly, with the difference that if $\bar{P}$
  spends $o_F$ with $C_{\bar{P}, i}$ now $P$ can publish $R_{P, i}$ which gives
  $P$ the coins of $\bar{P}$. Therefore with this difference $P$ is now
  guaranteed to gain at least $c_P + c_2'$ coins upon channel closure. We have
  therefore proven the third bullet.

  We now focus on the fourth bullet. Once more the induction hypothesis
  guarantees that before (\textsc{coop close sign comm}, $\dots$) was received,
  $P$ could close the channel resulting in on-chain outputs exclusively
  spendable or already spent by $\pk{P, \mathrm{out}}$ that are descendants of
  an output $o_F$ with a $2/\{\pk{P, F}, \pk{\bar{P}, F}\}$ spending method that
  have a sum value of $c_P = \sum\limits_{s \in C} \sum\limits_{x \in s} x$.
  When $P$ receives (\textsc{coop close sign comm}, $\dots$), it moves to the
  \textsc{coop closing} state before returning to the \textsc{open} state. It
  signs the new commitment transaction for the counterparty
  (Fig.~\ref{code:virtual-layer:coop-close-intermediary},
  l.~\ref{code:virtual-layer:coop-close-intermediary:right-interm-sign-comm})
  which spends the latest old funding output
  (Fig.~\ref{code:virtual-layer:coop-close-intermediary},
  l.~\ref{code:virtual-layer:coop-close-intermediary:right-old-fund-keys}),
  effectively removing one virtualisation layer. In $C_{P, i+1}$ $P$ owns
  $c_{\mathrm{virt}} - c_1'$ less coins than before that moment
  (Fig.~\ref{code:virtual-layer:coop-close-intermediary},
  l.~\ref{code:virtual-layer:coop-close-intermediary:right-interm-comm}) -- note
  that $P$ now lost access to $c_{\mathrm{virt}}$ coins from the refund output
  of its virtual transactions. It then verifies the counterparty's signatures on
  the corresponding new local commitment transaction $C_{P, i+1}$,
  (Fig.~\ref{code:virtual-layer:coop-close-intermediary},
  l.~\ref{code:virtual-layer:coop-close-intermediary:right-interm-verify-comm})
  and on the revocation transaction of the old commitment transaction of the
  counterparty (Fig.~\ref{code:virtual-layer:coop-close-intermediary},
  l.~\ref{code:virtual-layer:coop-close-intermediary:right-interm-verify-rev}).
  Once these are received, $P$ transitions to the \textsc{open} state. If the
  $o_F$ output is spent while $P$ is in the \textsc{coop closing} state, it can
  be spent by one of $C_{P, i+1}$ or some of $(C_{\bar{P}, j})_{0 \leq j \leq
  i+1}$. If it is spent by $C_{P, i+1}$ or $C_{\bar{P}, i+1}$, then these two
  transactions have a ($c_P + c_1'$, $\pk{P, \mathrm{out}}$) output. (Note that
  the former is encumbered with a timelock, but the alternative spending method
  cannot be used as $P$ has not signed $R_{\bar{P}, i+1}$.) If it is spent by
  $C_{\bar{P}, i}$ then a ($c_P$, $\pk{P, \mathrm{out}}$) output becomes
  available instead, therefore $P$ can still get the $c_P$ coins that correspond
  to the previous state. If any of $(C_{\bar{P}, j})_{0 \leq j < i}$ spends this
  or another of our past funding outputs then it makes available a $\pk{P,
  \mathrm{out}}$ output with the coins that $P$ had at state $j$ and
  additionally $P$ can publish $R_{P, j}$ that spends $\bar{P}$'s output of
  $C_{\bar{P}, j}$ and obtain the entirety of $\bar{P}$'s coins at state $j$ for
  a total of $c_P + c_{\bar{P}}$ coins. Similarly to the previous bullet, if
  $o_F$ is spent by any virtual transaction, then $\texttt{host}_P$ will punish
  the publisher and $P$ will obtain a sum equal to the entirety of the channel's
  funds. Therefore in every case $P$ can claim at least $c_P$ coins. In the case
  that $P$ instead subsequently receives a valid signature to $R_{P, i}$
  (Fig.~\ref{code:virtual-layer:coop-close-intermediary},
  l.~\ref{code:virtual-layer:coop-close-intermediary:left-interm-verify-rev})
  and moves to the \textsc{open} state, the above analysis of what can happen
  when $o_F$ holds similarly, with the difference that if $\bar{P}$ spends $o_F$
  with $C_{\bar{P}, i}$ now $P$ can publish $R_{P, i}$ which gives $P$ the coins
  of $\bar{P}$. Therefore with this difference $P$ is now guaranteed to gain at
  least $c_P - c_{\mathrm{virt}} + c_1'$ coins upon channel closure. This proves
  the first claim of the fourth bullet.

  Regarding the second claim, we observe that $P$ can only move to the
  \textsc{open} state if previously a local kindred \textsc{ln} ITI $R$ moves to
  the \textsc{open} state as well. Via direct application of the previous claim
  of the currently analysed bullet, $R$ has gained $c_2'$ coins in the process,
  therefore guaranteeing that $P$ and $R$ have on aggregate access to the same
  number of coins as before the cooperative closing. What is more, throughout
  the cooperative closing process both parties had access to at least $c_P$ and
  $c_R$ coins respectively, thus ensuring that no loss of coins is possible. We
  have now proven the fourth bullet.

  Moving on to the fifth bullet, the same reasoning as that of the treatment of
  the previous bullet holds, albeit with the \texttt{guest}'s signature
  verifications as they appear in Fig.~\ref{code:ln:coop-close-funder}.

  The first claim of the sixth bullet holds due to an argument identical to that
  provided for the third bullet, since in both cases the relevant parts of the
  protocol execution are the same. Note that \texttt{funder}'s signature for the
  revocation of the lastt commitment transaction of the virtual channel has not
  been yet verified, but this is of no consequence for our balance as all other
  revocation signatures have been already verified and the connection with the
  \texttt{funder} has been severed due to the successful cooperative closing.

  Regarding now the seventh bullet, once again the induction hypothesis guarantees
  that before (\textsc{pay}, $d$) was received, $P$ could close the channel
  resulting in on-chain outputs exclusively spendable or already spent by
  $\pk{P, \mathrm{out}}$ that are descendants of an output with a $2/\{\pk{P,
  F}, \pk{\bar{P}, F}\}$ spending method that have a sum value of $c_P =
  \sum\limits_{s \in C} \sum\limits_{x \in s} x$. (Note that $\sum\limits_{s \in
  C'} \sum\limits_{x \in s} x = d + \sum\limits_{s \in C} \sum\limits_{x \in s}
  x$.) When $P$ receives (\textsc{pay}, $d$) while in the \textsc{open} state,
  it moves to the \textsc{waiting for commitment signed} state before returning
  to the \textsc{open} state. It signs (Fig.~\ref{code:ln:pay:signatures},
  l.~\ref{code:ln:pay:signatures:sign-new-comm}) the new commitment transaction
  $C_{\bar{P}, i+1}$ in which the counterparty owns $d$ more coins than before
  that moment (Fig.~\ref{code:ln:pay:signatures},
  l.~\ref{code:ln:pay:signatures:new-comm}), sends the signature to the
  counterparty (Fig.~\ref{code:ln:pay:signatures},
  l.~\ref{code:ln:pay:signatures:pay}) and expects valid signatures on its own
  updated commitment transaction (Fig.~\ref{code:ln:pay:revocations},
  l.~\ref{code:ln:pay:revocations:verify-comm}) and the revocation transaction
  for the old commitment transaction of the counterparty
  (Fig.~\ref{code:ln:pay:revocations},
  l.~\ref{code:ln:pay:revocations:verify-rev}). Upon verifying them, $P$
  transitions to the \textsc{open} state. Note that if the counterparty
  does not respond or if it responds with missing/invalid signatures, either $P$
  can close the channel with the old commitment transaction $C_{P, i}$ exactly
  like before the update started (as it has not yet sent the signature for the
  old revocation transaction), or the counterparty will close the channel either
  with the new or with the old commitment transaction. In all cases in which
  validation fails and the channel closes, there is an output with a $\pk{P,
  \mathrm{out}}$ spending method and no other useable spending method that
  carries at least $c_P - d$ coins. Only if the verification succeeds does $P$
  sign (Fig.~\ref{code:ln:pay:revocations},
  l.~\ref{code:ln:pay:revocations:sign-rev}) and send
  (Fig.~\ref{code:ln:pay:revocations},
  l.~\ref{code:ln:pay:revocations:send-rev}) the counterparty's revocation
  transaction for $P$'s previous commitment transaction.

  Similarly to previous bullets, if $\mathtt{host}_P \neq$ ``\texttt{ledger}'' the funding
  output can be put on-chain, otherwise the funding output is already on-chain.
  In both cases, since the closing procedure continues, one of $C_{P, i+1}$,
  $(C_{\bar{P}, j})_{0 \leq j \leq i+1}$ will end up on-chain. If $C_{\bar{P},
  j}$ for some $j < i+1$ is on-chain, then $P$ submits $R_{P, j}$ (we discussed
  how $P$ obtained $R_{P, i}$ and the rest of the cases are covered by
  induction) and takes the entire value of the channel which is at least $c_P -
  d$. If $C_{\bar{P}, i+1}$ is on-chain, it has a ($c_P - d$, $\pk{P,
  \mathrm{out}}$) output. If $C_{P, i+1}$ is on-chain, it has an output of value
  $c_P - d$, a timelocked $\pk{P, \mathrm{out}}$ spending method and a
  non-timelocked spending method that needs the signature made with $\sk{P, R}$
  on $R_{\bar{P}, i+1}$. $P$ however has not generated that signature, therefore
  this spending method cannot be used and the timelock will expire, therefore in
  all cases outputs that descend from the funding output, can be spent
  exclusively by $\pk{P, \mathrm{out}}$ and carry at least $c_P - d$ coins are
  put on-chain. We have proven the seventh bullet.

  For the eighth and last bullet, again by the induction hypothesis, before
  (\textsc{get paid}, $e$) was received $P$ could close the channel resulting in
  on-chain outputs exclusively spendable or already spent by $\pk{P,
  \mathrm{out}}$ that are descendants of an output $o_F$ with a $2/\{\pk{P, F},
  \pk{\bar{P}, F}\}$ spending method and have a sum value of $c_P =
  \sum\limits_{s \in C} \sum\limits_{x \in s} x$. (Note that $e + \sum\limits_{s
  \in C'} \sum\limits_{x \in s} x = \sum\limits_{s \in C} \sum\limits_{x \in s}
  x$ and that $o_F$ either is already on-chain or can be eventually put on-chain
  as we have argued in the previous bullets by the induction hypothesis.) When
  $P$ receives (\textsc{get paid}, $e$) while in the \textsc{open} state, if the
  balance of the counterparty is enough it moves to the \textsc{waiting to get
  paid} state (Fig.~\ref{code:ln:get-paid}, l.~\ref{code:ln:get-paid:state}). If
  subsequently it receives a valid signature for $C_{P, i+1}$
  (Fig.~\ref{code:ln:pay:signatures}, l.~\ref{code:ln:pay:signatures:verify})
  which is a commitment transaction that can spend the $o_F$ output and gives to
  $P$ an additional $e$ coins compared to $C_{P, i}$. Subsequently $P$'s state
  transitions to \textsc{waiting for pay revocation} and sends signatures for
  $C_{\bar{P}, i+1}$ and $R_{\bar{P}, i}$ to $\bar{P}$. If the $o_F$ output is
  spent while $P$ is in the latter state, it can be spent by one of $C_{P, i+1}$
  or $(C_{\bar{P}, j})_{0 \leq j \leq i+1}$. If it is spent by $C_{P, i+1}$ or
  $C_{\bar{P}, i+1}$, then these two transactions have a ($c_P + e$, $\pk{P,
  \mathrm{out}}$) output. (Note that the former is encumbered with a timelock,
  but the alternative spending method cannot be used as $P$ has not signed
  $R_{\bar{P}, i+1}$.) If it is spent by $C_{\bar{P}, i}$ then a ($c_P$, $\pk{P,
  \mathrm{out}}$) output becomes available instead, therefore $P$ can still get
  the $c_P$ coins that correspond to the previous state. If any of $(C_{\bar{P},
  j})_{0 \leq j < i}$ spends $o_F$ then it makes available a $\pk{P,
  \mathrm{out}}$ output with the coins that $P$ had at state $j$ and
  additionally $P$ can publish $R_{P, j}$ that spends $\bar{P}$'s output of
  $C_{\bar{P}, j}$ and obtain the entirety of $\bar{P}$'s coins at state $j$ for
  a total of $c_P + c_{\bar{P}}$ coins.  Therefore in every case $P$ can claim
  at least $c_P$ coins. In the case that $P$ instead subsequently receives a
  valid signature to $R_{P, i}$ (Fig.~\ref{code:ln:pay:revocations},
  l.~\ref{code:ln:pay:revocations:verify}) it finally moves to the \textsc{open}
  state once again. In this state the above analysis of what can happen when
  $o_F$ holds similarly, with the difference that if $\bar{P}$ spends $o_F$ with
  $C_{\bar{P}, i}$ now $P$ can publish $R_{P, i}$ which gives $P$ the coins of
  $\bar{P}$. Therefore with this difference $P$ is now guaranteed to gain at
  least $c_P + e$ coins upon channel closure. We have therefore proven the
  eighth bullet and with it the first bullet of the Lemma.

  We now turn to proving the second bullet of the Lemma. We will take advantage
  of the results that have been derived earlier in this proof. If $P$ is
  the \texttt{funder} of the virtual channel in process
  of cooperatively closing, it ensures that $c_1' = c_P \wedge c_2' =
  c_{\bar{P}}$ (Fig.~\ref{code:ln:coop-close-funder},
  l.~\ref{code:ln:coop-close-funder:verify-balance}). If $P$ is the
  \texttt{fundee}, it requests that the virtual channel be closed with the
  current honest coin balance (Fig.~\ref{code:ln:coop-close-fundee},
  l.~\ref{code:ln:coop-close-fundee:balance-sign}), in which case it is $c_1' =
  c_{\bar{P}} \wedge c_2' = c_P$. Due to the arguments proving
  the first Lemma bullet, we know that
  \begin{equation}
    \label{eq:virt-balance}
    c_P = \sum\limits_{s \in C} \sum\limits_{x \in s} x \geq \phi \cdot c -
    \sum\limits_{i=1}^n f_i - \sum\limits_{i=1}^m d_i + \sum\limits_{i=1}^l e_i
    + \sum\limits_{i=1}^j r_i + \sum\limits_{i=1}^k l_i \enspace.
  \end{equation}
  Just before the splitting of the two alternative scenarios, party $S$ is
  entitled to $c_b$ coins, since (i) in the first scenario all other parties
  honestly follow the protocol and thus they do not lose any coins to $S$ and
  (ii) no action during the first scenario causes any transfer of coins. As we
  saw previously, if $P$ transitions to the \textsc{coop closed} state, then $S$
  has also transitioned from the \textsc{coop closing} to the \textsc{open}
  state and benefitted from an increase of the coins it can exclusively spend by
  $c_P$. It therefore holds that the difference of the coins $c_t - c_b$ that
  $P$ owns at the end of the two scenarios is exactly $c_P$ and due
  to~(\ref{eq:virt-balance}) we can directly derive the
  required~(\ref{eq:real-balance-coop-close}). The Lemma has now been proven.
\end{proof}
