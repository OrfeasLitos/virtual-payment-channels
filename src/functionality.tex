\TODO{Add support for cooperative adding multiple virtuals to single channel as
future work (needs cooperation by all hops of all existing virtuals of current
channel)}
\TODO{Add support for cooperative closing as future work}

\begin{figure}[H]
  \begin{systembox}{\fchan{} -- general message handling rules}
    \begin{itemize}
      \item On receiving input (\texttt{msg}) by \environment to $P \in
      \{\alice, \bob\}$, handle it according to the corresponding rule in
      Fig~\ref{code:functionality:state-machine} (if any) and subsequently send
      (\textsc{relay}, \texttt{msg}, $P$, \environment, input) \adversary.
      \Comment{all messages by \environment are relayed to \adversary}
      \item On receiving (\texttt{msg}) by $R \neq \environment$ to $P \in
      \{\alice, \bob\}$ by means of $\texttt{mode} \in \{\mathrm{input},
      \mathrm{output}, \mathrm{network}\}$, send (\textsc{relay}, \texttt{msg},
      $P$, $R$, \texttt{mode}) to \adversary.  \Comment{all messages by machines
      other than \environment are relayed to \adversary}
      \item On receiving (\textsc{relay}, \texttt{msg}, $P$, $R$, \texttt{mode})
      by \adversary ($\texttt{mode} \in \{\mathrm{input}, \mathrm{output},
      \mathrm{network}\}$, $P \in \{\alice, \bob\}$), relay \texttt{msg} to $R$
      as $P$ by means of \texttt{mode}. \Comment{\adversary fully controls
      outgoing messages by \fchan}
      \item On receiving (\textsc{info}, \texttt{msg}) by \adversary, handle
      (\texttt{msg}) according to the corresponding rule in
      Fig~\ref{code:functionality:state-machine} (if any). After handling the
      message or after an ``ensure'' fails, send (\textsc{handled},
      \texttt{msg}) to \adversary. \Comment{(\textsc{info}, \texttt{msg})
      messages by \simulator always return control to \simulator without any
      side-effect to any other ITI, except if \fchan halts}
    \end{itemize}
  \end{systembox}
  \caption{}
  \label{code:functionality:rules}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{\fchan{} -- state machine}
    \begin{algorithmic}[1]
      \State On initalisation:
      \label{code:functionality:state-machine:boot}
      \Indent
        \State $\pk{A} \gets \bot$; $\pk{B} \gets \bot$
        \State $\balance{A} \gets 0$; $\balance{B} \gets 0$
        \State $\texttt{ignore}_A \gets$ False;
        $\texttt{ignore}_B \gets$ False;
        \State $\itistate \gets \textsc{uninit}$
      \EndIndent
      \Statex

      \State On (\textsc{became corrupted or negligent}, $P$) by \adversary when
      in any $\itistate$ or on output (\textsc{used revocation}) by
      $\texttt{host}_P$ when $\itistate = \textsc{open}$:
      \Indent
        \State $\texttt{ignore}_P \gets$ True
        \IfThen{$\texttt{ignore}_{\bar{P}} = \mathrm{True}$}{$\itistate \gets
        \textsc{both ignored}$} \Comment{sink state}
      \EndIndent
      \Statex

      \State On (\textsc{init}, $\pk{}$) to $P$ by \environment when $\itistate
      = \textsc{uninit}$:
      \Indent
        \IfThen{$\pk{P} = \bot$}{$\pk{P} \gets \pk{}$}
        \IfThen{$\bigwedge\limits_{P \in \{A, B\}} (\pk{P} \neq \bot \vee
        \texttt{ignore}_P = \mathrm{True}$)}{$\itistate \gets \textsc{init}$}
      \EndIndent
      \Statex

      \State On (\textsc{open}, $x$, $\texttt{host}_A$, $\texttt{host}_B$) by
      \adversary when $\itistate = \textsc{init}$:
      \label{code:functionality:state-machine:when-open}
      \Indent
        \State $\balance{A} \gets x$; store $\texttt{host}_A, \texttt{host}_B$
        \State $\itistate \gets \textsc{open}$
      \EndIndent
      \Statex

      \State On (\textsc{pay}, $x$, $P$, $\bar{P}$) by \adversary when
      $\itistate = \textsc{open}$: \Comment{$P$ pays $\bar{P}$}
      \label{code:functionality:state-machine:when-pay}
      \Indent
        \State $\balance{P} \gets \balance{P} - x$; $\balance{\bar{P}} \gets
        \balance{\bar{P}} + x$
      \EndIndent
      \Statex

      \State On (\textsc{fund}, $x$, $P$, $\texttt{host}_A$, $\texttt{host}_B$)
      by \adversary when $\itistate = \textsc{open}$:
      \label{code:functionality:state-machine:when-fund}
      \Indent
        \State $\balance{P} \gets \balance{P} - x$; update $\texttt{host}_A,
        \texttt{host}_B$
      \EndIndent
      \Statex

      \State On (\textsc{close}, $P$) by \adversary when $\itistate =
      \textsc{open}$:
      \label{code:functionality:state-machine:close:prev-state}
      \Indent
        \State input (\textsc{read}) to \ledger as $P$ and assign ouput to
        $\Sigma$
        \State \Comment{$P$'s state surely contains correct balances, so use it
        for both parties. This is secure as, given how \ledger works, eventually
        $\bar{P}$'s state will catch up}
        \For{$S \in \{A, B\}$}
          \If{$\texttt{ignore}_S =$ False}
            \State $\coins{S} \gets$ sum of coins exclusively spendable by
            $\pk{S}$ in $\Sigma$
            \label{code:functionality:state-machine:close:coins}
          \EndIf
          \State $\texttt{check}_S \gets \texttt{ignore}_S \vee \coins{S} \geq
          \balance{S}$
        \EndFor
        \If{$\texttt{check}_A \wedge \texttt{check}_B$}
          \State $\itistate \gets \textsc{closed}$
        \Else \: \Comment{balance security is broken}
          \State halt
          \label{code:functionality:state-machine:halt}
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:state-machine}
\end{figure}
