\begin{center} % \captionof hinders page break if not in an environment
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State On every activation, before handling the message:
      \Indent
        \If{$\texttt{last\_poll} \neq \bot$} \Comment{virtual layer is ready}
          \State input (\textsc{read}) to \ledger and assign ouput to $\Sigma$
          \If{$\texttt{last\_poll} + p < |\Sigma|$}
            \For{$P \in \{\texttt{guest}, \texttt{funder}, \texttt{fundee}\}$}
            \Comment{at most 1 of \texttt{funder}, \texttt{fundee} is defined}
              \State ensure $P$.\textsc{negligent}() returns (\textsc{ok})
            \EndFor
          \EndIf
        \EndIf
      \EndIndent
      \Statex

      \State \Comment {\texttt{guest} is trusted to give sane inputs, therefore
      a state machine and input verification are redundant}
      \State On input (\textsc{init}, $\texttt{host}_P$, $\bar{P}$,
      \texttt{sibling}, \texttt{fundee}, ($\sk{\mathrm{loc}, \mathrm{fund},
      \mathrm{new}}$, $\pk{\mathrm{loc}, \mathrm{fund}, \mathrm{new}}$),
      $\pk{\mathrm{rem}, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{sib},
      \mathrm{rem}, \mathrm{fund}, \mathrm{new}}$, ($\sk{\mathrm{loc},
      \mathrm{fund}, \mathrm{old}}$, $\pk{\mathrm{loc}, \mathrm{fund},
      \mathrm{old}}$), $\pk{\mathrm{rem}, \mathrm{fund}, \mathrm{old}}$,
      $\pk{\mathrm{loc}, \mathrm{out}}$, $c_P$, $c_{\bar{P}}$,
      $c_{\mathrm{virt}}$, $t_P$, $i$, \texttt{side}, $n$) by \texttt{guest}:
      \label{code:virtual-layer:keys:init}
      \Indent
        \State ensure $1 < i \leq n$ \Comment{\texttt{host\_funder} ($i = 1$) is
        initialised with \textsc{host me}}
        \label{code:virtual-layer:keys:init:check-i}
        \State ensure $\texttt{side} \in \{\text{``left''},
        \text{``right''}\}$
        \State store message contents and \texttt{guest}
        \Comment{\texttt{sibling}, $\pk{\mathrm{sib}, \bar{P}, F}$ are missing
        for endpoints, \texttt{fundee} is present only in last node}
        \State $(\sk{i, \mathrm{fund}, \mathrm{new}}, \pk{i, \mathrm{fund},
        \mathrm{new}}) \gets (\sk{\mathrm{loc}, \mathrm{fund}, \mathrm{new}},
        \pk{\mathrm{loc}, \mathrm{fund}, \mathrm{new}})$
        \State $\pk{\texttt{myRem}, \mathrm{fund}, \mathrm{new}} \gets
        \pk{\mathrm{rem}, \mathrm{fund}, \mathrm{new}}$
        \If{$i < n$} \Comment{we are not last hop}
          \State $\pk{\texttt{sibRem}, \mathrm{fund}, \mathrm{new}} \gets
          \pk{\mathrm{sib}, \mathrm{rem}, \mathrm{fund}, \mathrm{new}}$
        \EndIf
        \If{$\texttt{side} = \text{``left''}$}
          \State $\texttt{side}' \gets \text{``right''}$; $\texttt{myRem}
          \gets i-1$; $\texttt{sibRem} \gets i+1$
        \Else \: \Comment{$\texttt{side} = \text{``right''}$}
          \State $\texttt{side}' \gets \text{``left''}$; $\texttt{myRem} \gets
          i+1$; $\texttt{sibRem} \gets i-1$
        \EndIf
        \State $(\sk{i, \texttt{side}, \mathrm{fund}, \mathrm{old}}, \pk{i,
        \texttt{side}, \mathrm{fund}, \mathrm{old}}) \gets (\sk{\mathrm{loc},
        \mathrm{fund}, \mathrm{old}}, \pk{\mathrm{loc}, \mathrm{fund},
        \mathrm{old}})$
        \State $\pk{\mathrm{myRem}, \texttt{side}', \mathrm{fund}, \mathrm{old}}
        \gets \pk{\mathrm{rem}, \mathrm{fund}, \mathrm{old}}$
        \If{\texttt{side} = ``left''}
          \State $\pk{i, \mathrm{out}} \gets \pk{\mathrm{loc}, \mathrm{out}}$
        \EndIf \: \Comment{otherwise \texttt{sibling} will send $\pk{i,
        \mathrm{out}}$ in \textsc{keys and coins forward}}
        \State $(c_{i, \texttt{side}}, c_{\texttt{myRem}, \texttt{side}'}, t_{i,
        \texttt{side}}) \gets (c_P, c_{\bar{P}}, t_P)$
        \State $\texttt{last\_poll} \gets \bot$
        \If{$\texttt{side} = \text{``left''} \wedge i \neq n$}
          \State $(\sk{i, j, k}, \pk{i, j, k})_{j \in \{2, \dots, n-1\}, k \in
          [n] \setminus \{j\}} \gets \textsc{keyGen}()^{(n-2)(n-1)}$
        \EndIf
        \State output (\textsc{host init ok}) to \texttt{guest}
      \EndIndent
      \Statex

      \State On input (\textsc{host me}, \texttt{funder}, \texttt{fundee},
      $\bar{P}$, $\texttt{host}_P$, $c_P$, $c_{\bar{P}}$, $c_{\mathrm{virt}}$,
      $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$,
      ($\sk{1, \mathrm{fund}, \mathrm{new}}$, $\pk{1, \mathrm{fund},
      \mathrm{new}}$), ($\sk{1, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$,
      $\pk{1, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$), $\pk{2,
      \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{2, \mathrm{left},
      \mathrm{fund}, \mathrm{new}}$, $\pk{1, \mathrm{out}}$, $n$) by
      \texttt{guest}:
      \Indent
        \State $\texttt{last\_poll} \gets \bot$
        \State $i \gets 1$
        \State $c_{1, \mathrm{right}} \gets c_P$; $c_{2, \mathrm{left}} \gets
        c_{\bar{P}}$
        \label{code:virtual-layer:keys:host-me:set-i}
        \State $(\sk{1, j, k}, \pk{1, j, k})_{j \in \{2, \dots, n-1\}, k \in [n]
        \setminus \{j\}} \gets \textsc{keyGen}()^{(n-2)(n-1)}$
        \State ensure \textsc{virt.circulateKeysCoinsTimes}() returns
        (\textsc{ok})
        \State ensure \textsc{virt.circulateVirtualSigs}() returns (\textsc{ok})
        \State ensure \textsc{virt.circulateFundingSigs}() returns (\textsc{ok})
        \State ensure \textsc{virt.circulateRevocations}() returns (\textsc{ok})
        \State output (\textsc{hosts ready}, $p + \sum\limits_{j = 2}^{n-1}(s -
        1 + t_j)$) to \texttt{guest} \Comment{$p$ is every how many blocks we
        have to check the chain}
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:keys}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt}.\textsc{circulateKeysCoinsTimes}(\texttt{left\_data}):}
    \begin{algorithmic}[1]
      \If{\texttt{left\_data} is given as argument} \Comment{we are not
      \texttt{host\_funder}}
        \State parse \texttt{left\_data} as ($(\pk{j, \mathrm{fund},
        \mathrm{new}})_{j \in [i-1]}$, $(\pk{j, \mathrm{left}, \mathrm{fund},
        \mathrm{old}})_{j \in \{2, \dots, i-1\}}$, $(\pk{j, \mathrm{right},
        \mathrm{fund}, \mathrm{old}})_{j \in [i-1]}$, $(\pk{j, \mathrm{out}})_{j
        \in [i-1]}$, $(c_{j, \mathrm{left}})_{j \in \{2, \dots, i-1\}}$, $(c_{j,
        \mathrm{right}})_{j \in [i-1]}$, $(t_j)_{j \in [i-1]}$,
        $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right},
        \mathrm{virt}}$, $(\pk{h, j, k})_{h \in [i-1], j \in \{2, \dots, n-1\},
        k \in [n] \setminus \{j\}}$)
        \If{we have a \texttt{sibling}} \Comment{we are not
        \texttt{host\_fundee}}
          \State input (\textsc{keys and coins forward}, (\texttt{left\_data},
          ($\sk{i, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{i,
          \mathrm{left}, \mathrm{fund}, \mathrm{old}}$), $\pk{i, \mathrm{out}}$,
          $c_{i, \mathrm{left}}$, $t_{i, \mathrm{left}}$, $(\sk{i, j, k}, \pk{i,
          j, k})_{j \in \{2, \dots, n-1\}, k \in [n] \setminus \{j\}}$) to
          \texttt{sibling}
          \State \trustedcode{store input as \texttt{left\_data} and parse it as
          ($(\pk{j, \mathrm{fund}, \mathrm{new}})_{j \in [i-1]}$, $(\pk{j,
          \mathrm{left}, \mathrm{fund}, \mathrm{old}})_{j \in \{2, \dots, i\}}$,
          $(\pk{j, \mathrm{right}, \mathrm{fund}, \mathrm{old}})_{j \in [i-1]}$,
          $(\pk{j, \mathrm{out}})_{j \in [i]}$, $(c_{j, \mathrm{left}})_{j \in
          \{2, \dots, i\}}$, $(c_{j, \mathrm{right}})_{j \in [i-1]}$, $(t_j)_{j
          \in [i-1]}$, $\sk{i, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
          $t_{i, \mathrm{left}}$, $\pk{\mathrm{left}, \mathrm{virt}}$,
          $\pk{\mathrm{right}, \mathrm{virt}}$, $(\pk{h, j, k})_{h \in [i], j
          \in \{2, \dots, n-1\}, k \in [n] \setminus \{j\}}$, $(\sk{i, j, k})_{j
          \in \{2, \dots, n-1\}, k \in [n] \setminus \{j\}}$}
          \State \trustedcode{$t_i \gets \max{(t_{i, \mathrm{left}}, t_{i,
          \mathrm{right}})}$}
          \State \trustedcode{replace $t_{i, \mathrm{left}}$ in
          \texttt{left\_data} with $t_i$}
          \State \trustedcode{remove $\sk{i, \mathrm{left}, \mathrm{fund},
          \mathrm{old}}$ and $(\sk{i, j, k})_{j \in \{2, \dots, n-1\}, k \in [n]
          \setminus \{j\}}$ from \texttt{left\_data}}
          \State \trustedcode{call
          \textsc{virt.circulateKeysCoinsTimes}(\texttt{left\_data}) of
          $\bar{P}$ and assign returned value to \texttt{right\_data}}
          \State \trustedcode{parse \texttt{right\_data} as ($(\pk{j,
          \mathrm{fund}, \mathrm{new}})_{j\in \{i+1, \dots, n\}}$, $(\pk{j,
          \mathrm{left}, \mathrm{fund}, \mathrm{old}})_{j \in \{i+1, \dots,
          n\}}$, $(\pk{j, \mathrm{right}, \mathrm{fund}, \mathrm{old}})_{j \in
          \{i+1, \dots, n-1\}}$, $(\pk{j, \mathrm{out}})_{j \in \{i+1, \dots,
          n\}}$, $(c_{j, \mathrm{left}})_{j \in \{i+1, \dots, n\}}$, $(c_{j,
          \mathrm{right}})_{j \in \{i+1, \dots, n-1\}}$, $(t_j)_{j \in \{i+1,
          \dots, n\}}$, $(\pk{h, j, k})_{h \in \{i+1, \dots, n\}, j
          \in \{2, \dots, n-1\}, k \in [n] \setminus \{j\}}$}
          \State \trustedcode{output (\textsc{keys and coins back},
          \texttt{right\_data}, ($\sk{i, \mathrm{right}, \mathrm{fund},
          \mathrm{old}}$, $\pk{i, \mathrm{right}, \mathrm{fund},
          \mathrm{old}})$, $c_{i, \mathrm{right}}$, $t_i$)}
          \State store output as \texttt{right\_data} and parse it as ($(\pk{j,
          \mathrm{fund}, \mathrm{new}})_{j \in \{i+1, \dots, n\}}$, $(\pk{j,
          \mathrm{left}, \mathrm{fund}, \mathrm{old}})_{j \in \{i+1, \dots,
          n\}}$, $(\pk{j, \mathrm{right}, \mathrm{fund}, \mathrm{old}})_{j \in
          \{i, \dots, n-1\}}$, $(\pk{j, \mathrm{out}})_{j \in \{i+1, \dots,
          n\}}$, $(c_{j, \mathrm{left}})_{j \in \{i+1, \dots, n\}}$, $(c_{j,
          \mathrm{right}})_{j \in \{i, \dots, n-1\}}$, $(t_j)_{j \in \{i, \dots,
          n\}}$, $(\pk{h, j, k})_{h \in \{i+1, \dots, n\}, j \in \{2, \dots,
          n-1\}, k \in [n] \setminus \{j\}}$, $\sk{i, \mathrm{right},
          \mathrm{fund}, \mathrm{old}}$)
          \State remove $\sk{i, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$
          from \texttt{right\_data}
          \State \Return (\texttt{right\_data}, $\pk{i, \mathrm{fund},
          \mathrm{new}}$, $\pk{i, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
          $\pk{i, \mathrm{out}}$, $c_{i, \mathrm{left}}$)
        \Else \: \Comment{we are \texttt{host\_fundee}}
          \State output (\textsc{check keys}, ($\pk{\mathrm{left},
          \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$)) to
          \texttt{fundee} and expect reply (\textsc{keys ok})
          \State \Return ($\pk{n, \mathrm{fund}, \mathrm{new}}$, $\pk{n,
          \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{n, \mathrm{out}}$,
          $c_{n, \mathrm{left}}$, $t_n$)
        \EndIf
      \Else \: \Comment{we are \texttt{host\_funder}}
        \State call \textsc{virt.circulateKeysCoinsTimes}($\pk{1, \mathrm{fund},
        \mathrm{new}}$, $\pk{1, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$,
        $\pk{1, \mathrm{out}}$, $c_{1, \mathrm{right}}$, $t_1$,
        $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right},
        \mathrm{virt}}$, $(\pk{1, j, k})_{j \in \{2, \dots, n-1\}, k \in [n]
        \setminus \{j\}}$) of $\bar{P}$ and assign returned value to
        \texttt{right\_data}
        \State parse \texttt{right\_data} as ($(\pk{j, \mathrm{fund},
        \mathrm{new}})_{j \in \{2, \dots, n\}}$, $(\pk{j, \mathrm{left},
        \mathrm{fund}, \mathrm{old}})_{j \in \{2, \dots, n\}}$, $(\pk{j,
        \mathrm{right}, \mathrm{fund}, \mathrm{old}})_{j \in \{2, \dots,
        n-1\}}$, $(\pk{j, \mathrm{out}})_{j \in \{2, \dots, n\}}$, $(c_{j,
        \mathrm{left}})_{j \in \{2, \dots, n\}}$, $(c_{j, \mathrm{right}})_{j
        \in \{2, \dots, n-1\}}$, $(t_j)_{j \in \{2, \dots, n\}}$, $(\pk{h, j,
        k})_{h \in \{2, \dots, n\}, j \in \{2, \dots, n-1\}, k \in [n] \setminus
        \{j\}}$)
        \State \Return (\textsc{ok})
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:circulate-keys-and-coins}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State \textsc{getMidTXs}($i$, $n$, $c_{\mathrm{virt}}$, $c_{\mathrm{rem},
      \mathrm{left}}$, $c_{\mathrm{loc}, \mathrm{left}}$, $c_{\mathrm{loc},
      \mathrm{right}}$, $c_{\mathrm{rem}, \mathrm{right}}$, $\pk{\mathrm{rem},
      \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{\mathrm{loc},
      \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{\mathrm{loc},
      \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{\mathrm{rem},
      \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{\mathrm{rem},
      \mathrm{left}, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{loc},
      \mathrm{left}, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{loc},
      \mathrm{right}, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{rem},
      \mathrm{right}, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{left},
      \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$, $\pk{\mathrm{loc},
      \mathrm{out}}$, $(\pk{p,j,k})_{p \in [n], j \in [n-1] \setminus \{1\}, k
      \in [n-1] \setminus \{1, j\}}$, $(\pk{p, 2, 1})_{p \in [n]}$, $(\pk{p,
      n-1, n})_{p \in [n]}$, $(t_j)_{j \in [n-1] \setminus \{1\}}$):
      \Indent
        \State ensure $1 < i < n$
        \State ensure $c_{\mathrm{rem}, \mathrm{left}} \geq c_{\mathrm{virt}}
        \wedge c_{\mathrm{loc}, \mathrm{left}} \geq c_{\mathrm{virt}}$
        \Comment{left parties fund virtual channel}
        \State ensure $c_{\mathrm{rem}, \mathrm{left}} \geq c_{\mathrm{loc},
        \mathrm{right}} \wedge c_{\mathrm{rem}, \mathrm{right}} \geq
        c_{\mathrm{loc}, \mathrm{left}}$ \Comment{avoid griefing attack}
        \State $c_{\mathrm{left}} \gets c_{\mathrm{rem}, \mathrm{left}} +
        c_{\mathrm{loc}, \mathrm{left}}$; $c_{\mathrm{right}} \gets
        c_{\mathrm{loc}, \mathrm{right}} + c_{\mathrm{rem}, \mathrm{right}}$
        \State $\texttt{left\_old\_fund} \gets 2/\{\pk{\mathrm{rem},
        \mathrm{left}, \mathrm{fund}, \mathrm{old}}, \pk{\mathrm{loc},
        \mathrm{left}, \mathrm{fund}, \mathrm{old}}\}$
        \State $\texttt{right\_old\_fund} \gets 2/\{\pk{\mathrm{loc},
        \mathrm{right}, \mathrm{fund}, \mathrm{old}}, \pk{\mathrm{rem},
        \mathrm{right}, \mathrm{fund}, \mathrm{old}}\}$
        \State $\texttt{left\_new\_fund} \gets 2/\{\pk{\mathrm{rem},
        \mathrm{left}, \mathrm{fund}, \mathrm{new}}, \pk{\mathrm{loc},
        \mathrm{left}, \mathrm{fund}, \mathrm{new}}\}$
        \State $\texttt{right\_new\_fund} \gets 2/\{\pk{\mathrm{loc},
        \mathrm{right}, \mathrm{fund}, \mathrm{new}}, \pk{\mathrm{rem},
        \mathrm{right}, \mathrm{fund}, \mathrm{new}}\}$
        \State $\texttt{virt\_fund} \gets 2/\{\pk{\mathrm{left}, \mathrm{virt}},
        \pk{\mathrm{right}, \mathrm{virt}}\}$

        \ForAll{$j \in [n-1] \setminus \{1\}, k \in [n-1] \setminus \{1, j\}$}
          \State $\mathit{all}_{j, k} \gets n/\{\pk{1, j, k}, \dots,
          \pk{n, j, k}\} \wedge \texttt{"}k\texttt{"}$
        \EndFor
        \If{$i = 2$}
          \State $\mathit{all}_{2, 1} \gets n/\{\pk{1, 2, 1}, \dots, \pk{n, 2,
          1}\} \wedge \texttt{"1"}$
        \EndIf
        \If{$i = n-1$}
          \State $\mathit{all}_{n-1, n} \gets n/\{\pk{1, n-1, n}, \dots, \pk{n,
          n-1, n}\} \wedge \texttt{"}n\texttt{"}$
        \EndIf
        \State \Comment{After funding is complete, $A_j$ has the signature of
        all other parties for all $\mathit{all}_{j, k}$ inputs, but other
        parties do not have $A_j$'s signature for this input, therefore only
        $A_j$ can publish it.}
        \State \Comment{$\mathrm{TX}_{i, j, k} :=$ $i$-th move, $j, k$ input
        interval start and end. $j, k$ unneeded for $i = 1$, $k$ unneeded for $i
        = 2$.}
        \State $\mathrm{TX}_1 \gets \mathrm{TX}$:
        \Indent
          \State inputs:
          \Indent
            \State ($c_{\mathrm{left}}$, \texttt{left\_old\_fund}),
            \State ($c_{\mathrm{right}}$, \texttt{right\_old\_fund})
          \EndIndent
          \State outputs:
          \Indent
            \State ($c_{\mathrm{left}} - c_{\mathrm{virt}}$,
            \texttt{left\_new\_fund}),
            \label{code:virtual-layer:mid-txs:initiator:left-new-fund}
            \State ($c_{\mathrm{right}} - c_{\mathrm{virt}}$,
            \texttt{right\_new\_fund}),
            \State ($c_{\mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{out}}$),
            \State ($c_{\mathrm{virt}}$,
            \Indent
              \State (if $(i-1 > 1)$ then $\mathit{all}_{i-1, i}$ else False)
              \label{code:virtual-layer:mid-txs:initiator:left-all}
              \State $\vee$ (if $(i+1 < n)$ then $\mathit{all}_{i+1, i}$ else
              False)
              \label{code:virtual-layer:mid-txs:initiator:right-all}
              \State $\vee$ (
              \Indent
                \State if $(i-1 = 1 \wedge i+1 = n)$ then \texttt{virt\_fund}
                \label{code:virtual-layer:mid-txs:initiator:i-is-2:n-is-3}
                \State else if $(i-1 > 1 \wedge i+1 = n)$ then
                $\texttt{virt\_fund} + t_{i-1}$
                \State else if $(i-1 = 1 \wedge i+1 < n)$ then
                $\texttt{virt\_fund} + t_{i+1}$
                \State else \StarComment{$i-1 > 1 \wedge i+1 < n$}
                $\texttt{virt\_fund} + \max{(t_{i-1}, t_{i+1})}$
              \EndIndent
              \State )
            \EndIndent
            \State )
            \label{code:virtual-layer:mid-txs:initiator:virt-out}
          \EndIndent
        \EndIndent

        \If{$i = 2$}
          \State $\mathrm{TX}_{2, 1} \gets \mathrm{TX}$:
          \Indent
            \State inputs:
            \Indent
              \State ($c_{\mathrm{virt}}$, $\mathit{all}_{2, 1}$),
              \label{code:virtual-layer:mid-txs:i-is-2:extend-interval-left:virt}
              \State ($c_{\mathrm{right}}$, \texttt{right\_old\_fund})
            \EndIndent
            \State outputs:
            \Indent
              \State ($c_{\mathrm{right}} - c_{\mathrm{virt}}$,
              \texttt{right\_new\_fund}),
              \State ($c_{\mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{out}}$),
              \State ($c_{\mathrm{virt}}$,
              \Indent
                \State if $(n > 3)$ then $(\mathit{all}_{3, 2}
                \vee (\texttt{virt\_fund} + t_3))$
                \State else \texttt{virt\_fund}
              \EndIndent
              \State )
            \EndIndent
          \EndIndent
        \EndIf

        \If{$i = n-1$}
          \State $\mathrm{TX}_{2, n} \gets \mathrm{TX}$:
          \Indent
            \State inputs:
            \Indent
              \State ($c_{\mathrm{left}}$, \texttt{left\_old\_fund}),
              \State ($c_{\mathrm{virt}}$, $\mathit{all}_{n-1, n}$)
            \EndIndent
            \State outputs:
            \Indent
              \State ($c_{\mathrm{left}} - c_{\mathrm{virt}}$,
              \texttt{left\_new\_fund}),
              \State ($c_{\mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{out}}$),
              \State ($c_{\mathrm{virt}}$,
              \Indent
                \State if $(n-2 > 1)$ then $(\mathit{all}_{n-2, n-1} \vee
                (\texttt{virt\_fund} + t_{n-2}))$
                \State else \texttt{virt\_fund}
              \EndIndent
              \State )
            \EndIndent
          \EndIndent
        \EndIf

        \ForAll{$k \in \{2, \dots, i-1\}$} \Comment{$i-2$ txs}
          \State $\mathrm{TX}_{2, k} \gets \mathrm{TX}$:
          \Indent
            \State inputs:
            \Indent
              \State ($c_{\mathrm{virt}}$, $\mathit{all}_{i, k}$),
              \label{code:virtual-layer:mid-txs:extend-interval-left:virt}
              \State ($c_{\mathrm{right}}$, \texttt{right\_old\_fund})
            \EndIndent
            \State outputs:
            \Indent
              \State ($c_{\mathrm{right}} - c_{\mathrm{virt}}$,
              \texttt{right\_new\_fund}),
              \State ($c_{\mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{out}}$),
              \State ($c_{\mathrm{virt}}$,
              \Indent
                \State (if $(k-1 > 1)$ then $\mathit{all}_{k-1, i}$ else False)
                \State $\vee$ (if $(i+1 < n)$ then $\mathit{all}_{i+1, k}$ else
                False)
                \State $\vee$ (
                \Indent
                  \State if $(k-1 = 1 \wedge i+1 = n)$ then \texttt{virt\_fund}
                  \State else if $(k-1 > 1 \wedge i+1 = n)$ then
                  $\texttt{virt\_fund} + t_{k-1}$
                  \State else if $(k-1 = 1 \wedge i+1 < n)$ then
                  $\texttt{virt\_fund} + t_{i+1}$
                  \State else \StarComment{$k-1 > 1 \wedge i+1 < n$}
                  $\texttt{virt\_fund} + \max{(t_{k-1}, t_{i+1})}$
                \EndIndent
                \State )
              \EndIndent
              \State )
            \EndIndent
          \EndIndent
        \EndFor

        \ForAll{$k \in \{i+1, \dots, n-1\}$} \Comment{$n-i-1$ txs}
          \State $\mathrm{TX}_{2, k} \gets \mathrm{TX}$:
          \Indent
            \State inputs:
            \Indent
              \State ($c_{\mathrm{left}}$, \texttt{left\_old\_fund})
              \State ($c_{\mathrm{virt}}$, $\mathit{all}_{i, k}$),
            \EndIndent
            \State outputs:
            \Indent
              \State ($c_{\mathrm{left}} - c_{\mathrm{virt}}$,
              \texttt{left\_new\_fund}),
              \label{code:virtual-layer:mid-txs:extend-interval-right:new-fund}
              \State ($c_{\mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{out}}$),
              \State ($c_{\mathrm{virt}}$,
              \Indent
                \State (if $(i-1 > 1)$ then $\mathit{all}_{i-1, k}$ else False)
                \State $\vee$ (if $(k+1 < n)$ then $\mathit{all}_{k+1, i}$ else
                False)
                \State $\vee$ (
                \Indent
                  \State if $(i-1 = 1 \wedge k+1 = n)$ then \texttt{virt\_fund}
                  \State else if $(i-1 > 1 \wedge k+1 = n)$ then
                  $\texttt{virt\_fund} + t_{i-1}$
                  \State else if $(i-1 = 1 \wedge k+1 < n)$ then
                  $\texttt{virt\_fund} + t_{k+1}$
                  \State else \StarComment{$i-1 > 1 \wedge k+1 < n$}
                  $\texttt{virt\_fund} + \max{(t_{i-1}, t_{k+1})}$
                \EndIndent
                \State )
              \EndIndent
              \State )
            \EndIndent
          \EndIndent
        \EndFor

        \IfThenElse{$i = 2$}{$m \gets 1$}{$m \gets 2$}
        \IfThenElse{$i = n-1$}{$l \gets n$}{$l \gets n-1$}
        \ForAll{$(k_1, k_2) \in \{m, \dots, i-1\} \times \{i+1, \dots, l\}$}
        \Comment{$(i-m) \cdot (l-i)$ txs}
          \State $\mathrm{TX}_{3, k_1, k_2} \gets \mathrm{TX}$:
          \Indent
            \State inputs:
            \Indent
              \State ($c_{\mathrm{virt}}$, $\mathit{all}_{i, k_1}$),
              \label{code:virtual-layer:mid-txs:merge-intervals:left-virt-input}
              \State ($c_{\mathrm{virt}}$, $\mathit{all}_{i, k_2}$)
            \EndIndent
            \State outputs:
            \Indent
              \State ($c_{\mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{out}}$),
              \State ($c_{\mathrm{virt}}$,
              \Indent
                \State (if $(k_1-1 > 1)$ then $\mathit{all}_{k_1-1, \min{(k_2,
                n-1)}}$ else False)
                \State $\vee$ (if $(k_2+1 < n)$ then $\mathit{all}_{k_2+1,
                \max{(k_1, 2)}}$ else False)
                \State $\vee$ (
                \Indent
                  \State if $(k_1-1 \leq 1 \wedge k_2+1 \geq n)$ then
                  \texttt{virt\_fund}
                  \State else if $(k_1-1 > 1 \wedge k_2+1 \geq n)$ then
                  $\texttt{virt\_fund} + t_{k_1-1}$
                  \State else if $(k_1-1 \leq 1 \wedge k_2+1 < n)$ then
                  $\texttt{virt\_fund} + t_{k_2+1}$
                  \State else \StarComment{$k_1-1 > 1 \wedge k_2+1 < n$}
                  \Indent
                    \State $\texttt{virt\_fund} + \max{(t_{k_1-1}, t_{k_2+1})}$
                  \EndIndent
                \EndIndent
                \State )
              \EndIndent
              \State )
            \EndIndent
          \EndIndent
        \EndFor

        \State \Return (
        \Indent
          \State $\mathrm{TX}_1$,
          \State $(\mathrm{TX}_{2, k})_{k \in \{m, \dots, l\} \setminus \{i\}}$,
          \State $(\mathrm{TX}_{3, k_1, k_2})_{(k_1, k_2) \in \{m, \dots, i-1\}
          \times \{i+1, \dots, l\}}$
        \EndIndent
        \State )
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:mid-txs}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State \Comment{left and right refer to the two counterparties, with left
      being the one closer to the funder. Note difference with left/right
      meaning in \textsc{virt.getMidTXs}.}
      \State \textsc{getEndpointTX}($i$, $n$, $c_{\mathrm{virt}}$,
      $c_{\mathrm{left}}$, $c_{\mathrm{right}}$, $\pk{\mathrm{left},
      \mathrm{fund}, \mathrm{old}}$, $\pk{\mathrm{right}, \mathrm{fund},
      \mathrm{old}}$, $\pk{\mathrm{left}, \mathrm{fund}, \mathrm{new}}$,
      $\pk{\mathrm{right}, \mathrm{fund}, \mathrm{new}}$ $\pk{\mathrm{left},
      \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$, $(\pk{\mathrm{all},
      j})_{j \in [n]}$, $t$):
      \Indent
        \State ensure $i \in \{1, n\}$
        \State ensure $c_{\mathrm{left}} \geq c_{\mathrm{virt}}$ \Comment{left
        party funds virtual channel}
        \State $c_{\mathrm{tot}} \gets c_{\mathrm{left}} + c_{\mathrm{right}}$
        \State $\texttt{old\_fund} \gets 2/\{\pk{\mathrm{left}, \mathrm{fund},
        \mathrm{old}}, \pk{\mathrm{right}, \mathrm{fund}, \mathrm{old}}\}$
        \State $\texttt{new\_fund} \gets 2/\{\pk{\mathrm{left}, \mathrm{fund},
        \mathrm{new}}, \pk{\mathrm{right}, \mathrm{fund}, \mathrm{new}}\}$
        \State $\texttt{virt\_fund} \gets 2/\{\pk{\mathrm{left},
        \mathrm{virt}}, \pk{\mathrm{right}, \mathrm{virt}}\}$
        \If{$i = 1$} \Comment{funder's tx}
          \State $\mathit{all} \gets n/\{\pk{\mathrm{all}, 1}, \dots,
          \pk{\mathrm{all}, n}\} \wedge \texttt{"1"}$
        \Else \: \Comment{fundee's tx}
          \State $\mathit{all} \gets n/\{\pk{\mathrm{all}, 1}, \dots,
          \pk{\mathrm{all}, n}\} \wedge \texttt{"}n\texttt{"}$
        \EndIf
        \State $\mathrm{TX}_1 \gets \mathrm{TX}$: \Comment{endpoints only have
        an ``initiator'' tx}
        \Indent
          \State inputs:
          \Indent
            \State $(c_{\mathrm{tot}}, \texttt{old\_fund})$
          \EndIndent
          \State outputs:
          \Indent
            \State $(c_{\mathrm{tot}} - c_{\mathrm{virt}}, \texttt{new\_fund})$,
            \label{code:virtual-layer:endpoint-txs:new-fund}
            \State $(c_{\mathrm{virt}}, \mathit{all} \vee (\texttt{virt\_fund} +
            t))$
            \label{code:virtual-layer:endpoint-txs:virt}
          \EndIndent
        \EndIndent
        \State \Return $\mathrm{TX}_1$
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:endpoint-txs}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt.siblingSigs}()}
    \begin{algorithmic}[1]
      \State parse input as $\mathrm{sigs}_{\mathrm{byLeft}}$
      \IfThenElse{$i = 2$}{$m \gets 1$}{$m \gets 2$}
      \IfThenElse{$i = n-1$}{$l \gets n$}{$l \gets n-1$}
      \State ($\mathrm{TX}_{i, 1}$, $(\mathrm{TX}_{i, 2, k})_{k \in \{m, \dots,
      l\} \setminus \{i\}}$, $(\mathrm{TX}_{i, 3, k_1, k_2})_{(k_1, k_2) \in
      \{m, \dots, i-1\} \{i+1, \dots, l\}}$) $\gets$
      \textsc{virt.getMidTXs}($i$, $n$, $c_{\mathrm{virt}}$, $c_{i-1,
      \mathrm{right}}$, $c_{i, \mathrm{left}}$, $c_{i, \mathrm{right}}$,
      $c_{i+1, \mathrm{left}}$, $\pk{i-1, \mathrm{right}, \mathrm{fund},
      \mathrm{old}}$, $\pk{i, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
      $\pk{i, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{i+1,
      \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{i-1, \mathrm{fund},
      \mathrm{new}}$, $\pk{i, \mathrm{fund}, \mathrm{new}}$, $\pk{i,
      \mathrm{fund}, \mathrm{new}}$, $\pk{i+1, \mathrm{fund}, \mathrm{new}}$,
      $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$,
      $\pk{i, \mathrm{out}}$, $(\pk{i,j,k})_{i \in [n], j \in [n-1] \setminus
      \{1\}, k \in [n-1] \setminus \{1, j\}}$, $(\pk{i, 2, 1})_{i \in [n]}$,
      $(\pk{i, n-1, n})_{i \in [n]}$, $(t_i)_{i \in [n-1] \setminus \{1\}}$)
      \Statex
      \State \Comment{notation: $\mathrm{sig}(\mathrm{TX}, \pk{}) :=$ sig with
      \texttt{ANYPREVOUT} flag such that $\textsc{verify}(\mathrm{TX},
      \mathrm{sig}, \pk{}) =$ True}
      \State ensure that the following signatures are present in
      $\mathrm{sigs}_{\mathrm{byLeft}}$ and store them:
      \begin{itemize}
        \item \Comment{$(l-m) \cdot (i-1)$ signatures}
      \end{itemize}
      \Indent
        \State $\forall k \in \{m, \dots, l\} \setminus \{i\}, \forall j \in
        [i-1]:$
        \Indent
          \State sig($\mathrm{TX}_{i, 2, k}, \pk{j, i, k}$)
        \EndIndent
      \EndIndent
      \begin{itemize}
        \item \Comment{$2 \cdot (i-m) \cdot (l-i) \cdot
        (i-1)$ signatures}
      \end{itemize}
      \Indent
        \State $\forall k_1 \in \{m, \dots, i-1\}, \forall k_2 \in \{i+1, \dots,
        l\}, \forall j \in [i-1]:$
        \Indent
          \State sig($\mathrm{TX}_{i, 3, k_1, k_2}, \pk{j, i, k_1}$),
          sig($\mathrm{TX}_{i, 3, k_1, k_2}, \pk{j, i, k_2}$)
        \EndIndent
      \EndIndent
      \State $\mathrm{sigs}_{\mathrm{toRight}} \gets
      \mathrm{sigs}_{\mathrm{byLeft}}$
      \Statex
      \ForAll{$j \in \{2, \dots, n-1\} \setminus \{i\}$}
        \IfThenElse{$j = 2$}{$m' \gets 1$}{$m' \gets 2$}
        \IfThenElse{$j = n-1$}{$l' \gets n$}{$l' \gets n-1$}
        \State ($\mathrm{TX}_{j, 1}$, $(\mathrm{TX}_{j, 2, k})_{k \in \{m',
        \dots, l'\} \setminus \{i\}}$, $(\mathrm{TX}_{j, 3, k_1, k_2})_{(k_1,
        k_2) \in \{m', \dots, i-1\} \{i+1, \dots, l'\}}$) $\gets$
        \textsc{getMidTXs}($j$, $n$, $c_{\mathrm{virt}}$, $c_{j-1,
        \mathrm{right}}$, $c_{j, \mathrm{left}}$, $c_{j, \mathrm{right}}$,
        $c_{j+1, \mathrm{left}}$, $\pk{j-1, \mathrm{right}, \mathrm{fund},
        \mathrm{old}}$, $\pk{j, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
        $\pk{j, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{j+1,
        \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{j-1, \mathrm{fund},
        \mathrm{new}}$, $\pk{j, \mathrm{fund}, \mathrm{new}}$, $\pk{j,
        \mathrm{fund}, \mathrm{new}}$, $\pk{j+1, \mathrm{fund}, \mathrm{new}}$,
        $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right},
        \mathrm{virt}}$, $\pk{j, \mathrm{out}}$, $(\pk{k, p,
        s})_{k \in [n], p \in [n-1] \setminus \{1\}, s \in [n-1] \setminus \{1,
        p\}}$, $(\pk{k, 2, 1})_{k \in [n]}$, $(\pk{k, n-1, n})_{k \in [n]}$,
        $(t_k)_{k \in [n-1] \setminus \{1\}}$)
        \IfThenElse{$j < i$}{$\mathrm{sigs} \gets
        \mathrm{sigs}_{\mathrm{toLeft}}$}{$\mathrm{sigs} \gets
        \mathrm{sigs}_{\mathrm{toRight}}$}
        \ForAll{$k \in \{m', \dots, l'\} \setminus \{j\}$}
          \State add \textsc{sign}($\mathrm{TX}_{j, 2, k}$, $\sk{i, j, k}$,
          \texttt{ANYPREVOUT}) to sigs
        \EndFor
        \ForAll{$k_1 \in \{m', \dots, j-1\}, k_2 \in \{j+1, \dots, l'\}$}
          \State add \textsc{sign}($\mathrm{TX}_{j, 3, k_1, k_2}$, $\sk{i, j,
          k_1}$, \texttt{ANYPREVOUT}) to sigs
          \State add \textsc{sign}($\mathrm{TX}_{j, 3, k_1, k_2}$, $\sk{i, j,
          k_2}$, \texttt{ANYPREVOUT}) to sigs
        \EndFor
      \EndFor
      \If{$i+1 = n$} \Comment{next hop is \texttt{host\_fundee}}
        \State $\mathrm{TX}_{n, 1}$ $\gets$ \textsc{virt.getEndpointTX}($n$,
        $n$, $c_{\mathrm{virt}}$, $c_{n-1, \mathrm{right}}$, $c_{n,
        \mathrm{left}}$, $\pk{n-1, \mathrm{right}, \mathrm{fund},
        \mathrm{old}}$, $\pk{n, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
        $\pk{n-1, \mathrm{fund}, \mathrm{new}}$, $\pk{n, \mathrm{fund},
        \mathrm{new}}$, $\pk{\mathrm{left}, \mathrm{virt}}$,
        $\pk{\mathrm{right}, \mathrm{virt}}$, $(\pk{j, n-1, n})_{j \in [n]}$,
        $t_{n-1}$)
      \EndIf
      \Statex
      \State call
      $\bar{P}$.\textsc{circulateVirtualSigs}($\mathrm{sigs}_{\mathrm{toRight}}$)
      and assign returned value to $\mathrm{sigs}_{\mathrm{byRight}}$
      \State ensure that the following signatures are present in
      $\mathrm{sigs}_{\mathrm{byRight}}$ and store them:
      \begin{itemize}
        \item \Comment{$(l-m) \cdot (n-i)$ signatures}
      \end{itemize}
      \Indent
        \State $\forall k \in \{m, \dots, l\} \setminus \{i\}, \forall j \in
        \{i+1, \dots, n\}:$
        \Indent
          \State sig($\mathrm{TX}_{i, 2, k}, \pk{j, i, k}$)
        \EndIndent
      \EndIndent
      \begin{itemize}
        \item \Comment{$2 \cdot (i-m) \cdot (l-i) \cdot
        (n-i)$ signatures}
      \end{itemize}
      \Indent
        \State $\forall k_1 \in \{m, \dots, i-1\}, \forall k_2 \in \{i+1, \dots,
        l\}, \forall j \in \{i+1, \dots, n\}:$
        \Indent
          \State sig($\mathrm{TX}_{i, 3, k_1, k_2}, \pk{j, i, k_1}$),
          sig($\mathrm{TX}_{i, 3, k_1, k_2}, \pk{j, i, k_2}$)
        \EndIndent
      \EndIndent
      \State output (\textsc{virtualSigsBack},
      $\mathrm{sigs}_{\mathrm{toLeft}}$, $\mathrm{sigs}_{\mathrm{byRight}}$)
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:sibling-sigs}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt.intermediarySigs}()}
    \begin{algorithmic}[1]
      \IfThenElse{$i = 2$}{$m \gets 1$}{$m \gets 2$}
      \IfThenElse{$i = n-1$}{$l \gets n$}{$l \gets n-1$}
      \State ($\mathrm{TX}_{i, 1}$, $(\mathrm{TX}_{i, 2, k})_{k \in \{m, \dots,
      l\} \setminus \{i\}}$, $(\mathrm{TX}_{i, 3, k_1, k_2})_{(k_1, k_2) \in
      \{m, \dots, i-1\} \{i+1, \dots, l\}}$) $\gets$
      \textsc{virt.getMidTXs}($i$, $n$, $c_{\mathrm{virt}}$, $c_{i-1,
      \mathrm{right}}$, $c_{i, \mathrm{left}}$, $c_{i, \mathrm{right}}$,
      $c_{i+1, \mathrm{left}}$, $\pk{i-1, \mathrm{right}, \mathrm{fund},
      \mathrm{old}}$, $\pk{i, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
      $\pk{i, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{i+1,
      \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{i-1, \mathrm{fund},
      \mathrm{new}}$, $\pk{i, \mathrm{fund}, \mathrm{new}}$, $\pk{i,
      \mathrm{fund}, \mathrm{new}}$, $\pk{i+1, \mathrm{fund}, \mathrm{new}}$,
      $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$,
      $\pk{i, \mathrm{out}}$, $(\pk{i,j,k})_{i \in [n], j \in [n-1] \setminus
      \{1\}, k \in [n-1] \setminus \{1, j\}}$, $(\pk{i, 2, 1})_{i \in [n]}$,
      $(\pk{i, n-1, n})_{i \in [n]}$, $(t_i)_{i \in [n-1] \setminus \{1\}}$)
      \State \Comment{not verifying our signatures in
      $\mathrm{sigs}_{\mathrm{byLeft}}$, our (trusted) \texttt{sibling} will do
      that}
      \State input (\textsc{virtual sigs forward},
      $\mathrm{sigs}_{\mathrm{byLeft}}$) to \texttt{sibling}
      \State \trustedcode{\textsc{virt.siblingSigs}()}
      \State $\mathrm{sigs}_{\mathrm{toLeft}} \gets
      \mathrm{sigs}_{\mathrm{byRight}} + \mathrm{sigs}_{\mathrm{toLeft}}$
      \If{$i = 2$} \Comment{previous hop is \texttt{host\_funder}}
        \State $\mathrm{TX}_{1, 1}$ $\gets$ \textsc{virt.getEndpointTX}($1$,
        $n$, $c_{\mathrm{virt}}$, $c_{1, \mathrm{right}}$, $c_{2,
        \mathrm{left}}$, $\pk{1, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$,
        $\pk{2, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{1,
        \mathrm{fund}, \mathrm{new}}$, $\pk{2, \mathrm{fund}, \mathrm{new}}$,
        $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right},
        \mathrm{virt}}$, $(\pk{j, 2, 1})_{j \in [n]}$, $t_2$)
      \EndIf
      \State \Return $\mathrm{sigs}_{\mathrm{toLeft}}$
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:intermediary-sigs}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt.hostFundeeSigs}()}
    \begin{algorithmic}[1]
      \State $\mathrm{TX}_{n, 1} \gets$
      \textsc{virt}.\textsc{getEndpointTX}($n$, $n$, $c_{\mathrm{virt}}$,
      $c_{n-1, \mathrm{right}}$, $c_{n, \mathrm{left}}$, $\pk{n-1,
      \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{n, \mathrm{right},
      \mathrm{fund}, \mathrm{old}}$, $\pk{n-1, \mathrm{fund}, \mathrm{new}}$,
      $\pk{n, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{left},
      \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$, $(\pk{j, n-1,
      n})_{j \in [n]}$, $t_{n-1}$)
      \label{code:virtual-layer:fundee-sigs:tx}
      \ForAll{$j \in [n-1] \setminus \{1\}$}
        \IfThenElse{$j = 2$}{$m \gets 1$}{$m \gets 2$}
        \IfThenElse{$j = n-1$}{$l \gets n$}{$l \gets n-1$}
        \State ($\mathrm{TX}_{j, 1}$, $(\mathrm{TX}_{j, 2, k})_{k \in \{m,
        \dots, l\} \setminus \{j\}}$, $(\mathrm{TX}_{i, 3, k_1, k_2})_{(k_1,
        k_2) \in \{m, \dots, i-1\} \{i+1, \dots, l\}}$) $\gets$
        \textsc{virt.getMidTXs}($j$, $n$, $c_{\mathrm{virt}}$, $c_{j-1,
        \mathrm{right}}$, $c_{j, \mathrm{left}}$, $c_{j, \mathrm{right}}$,
        $c_{j+1, \mathrm{left}}$, $\pk{j-1, \mathrm{right}, \mathrm{fund},
        \mathrm{old}}$, $\pk{j, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
        $\pk{j, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{j+1,
        \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{j-1, \mathrm{fund},
        \mathrm{new}}$, $\pk{j, \mathrm{fund}, \mathrm{new}}$, $\pk{j,
        \mathrm{fund}, \mathrm{new}}$, $\pk{j+1, \mathrm{fund}, \mathrm{new}}$,
        $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right},
        \mathrm{virt}}$, $\pk{j, \mathrm{out}}$, $(\pk{j,s,k})_{j \in [n], s \in
        [n-1] \setminus \{1\}, k \in [n-1] \setminus \{1, s\}}$, $(\pk{j, 2,
        1})_{j \in [n]}$, $(\pk{j, n-1, n})_{j \in [n]}$, $(t_j)_{j \in [n-1]
        \setminus \{1\}}$)
        \State $\mathrm{sigs}_{\mathrm{toLeft}} \gets \emptyset$
        \ForAll{$k \in \{m, \dots, l\} \setminus \{j\}$}
          \State add \textsc{sign}($\mathrm{TX}_{j, 2, k}$, $\sk{n, j, k}$,
          \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toLeft}}$
        \EndFor
        \ForAll{$k_1 \in \{m, \dots, j-1\}, k_2 \in \{j+1, \dots, l\}$}
          \State add \textsc{sign}($\mathrm{TX}_{j, 3, k_1, k_2}$, $\sk{n, j,
          k_1}$, \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toLeft}}$
          \State add \textsc{sign}($\mathrm{TX}_{j, 3, k_1, k_2}$, $\sk{n, j,
          k_2}$, \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toLeft}}$
        \EndFor
      \EndFor
      \State \Return $\mathrm{sigs}_{\mathrm{toLeft}}$
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:fundee-sigs}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt.hostFunderSigs}()}
    \begin{algorithmic}[1]
      \ForAll{$j \in [n-1] \setminus \{1\}$}
        \IfThenElse{$j = 2$}{$m \gets 1$}{$m \gets 2$}
        \IfThenElse{$j = n-1$}{$l \gets n$}{$l \gets n-1$}
        \State ($\mathrm{TX}_{j, 1}$, $(\mathrm{TX}_{j, 2, k})_{k \in \{m,
        \dots, l\} \setminus \{j\}}$, $(\mathrm{TX}_{i, 3, k_1, k_2})_{(k_1,
        k_2) \in \{m, \dots, i-1\} \{i+1, \dots, l\}}$) $\gets$
        \textsc{virt.getMidTXs}($j$, $n$, $c_{\mathrm{virt}}$, $c_{j-1,
        \mathrm{right}}$, $c_{j, \mathrm{left}}$, $c_{j, \mathrm{right}}$,
        $c_{j+1, \mathrm{left}}$, $\pk{j-1, \mathrm{right}, \mathrm{fund},
        \mathrm{old}}$, $\pk{j, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
        $\pk{j, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{j+1,
        \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{j-1, \mathrm{fund},
        \mathrm{new}}$, $\pk{j, \mathrm{fund}, \mathrm{new}}$, $\pk{j,
        \mathrm{fund}, \mathrm{new}}$, $\pk{j+1, \mathrm{fund}, \mathrm{new}}$,
        $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right},
        \mathrm{virt}}$, $\pk{j, \mathrm{out}}$, $(\pk{j,s,k})_{j \in [n], s \in
        [n-1] \setminus \{1\}, k \in [n-1] \setminus \{1, s\}}$, $(\pk{j, 2,
        1})_{j \in [n]}$, $(\pk{j, n-1, n})_{j \in [n]}$, $(t_j)_{j \in [n-1]
        \setminus \{1\}}$)
        \State $\mathrm{sigs}_{\mathrm{toRight}} \gets \emptyset$
        \ForAll{$k \in \{m, \dots, l\} \setminus \{j\}$}
          \State add \textsc{sign}($\mathrm{TX}_{j, 2, k}$, $\sk{1, j, k}$,
          \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toRight}}$
        \EndFor
        \ForAll{$k_1 \in \{m, \dots, j-1\}, k_2 \in \{j+1, \dots, l\}$}
          \State add \textsc{sign}($\mathrm{TX}_{j, 3, k_1, k_2}$, $\sk{1, j,
          k_1}$, \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toRight}}$
          \State add \textsc{sign}($\mathrm{TX}_{j, 3, k_1, k_2}$, $\sk{1, j,
          k_2}$, \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toRight}}$
        \EndFor
      \EndFor
      \State call
      \textsc{virt.circulateVirtualSigs}($\mathrm{sigs}_{\mathrm{toRight}}$)
      of $\bar{P}$ and assign output to $\mathrm{sigs}_{\mathrm{byRight}}$
      \State $\mathrm{TX}_{1, 1} \gets$
      \textsc{virt}.\textsc{getEndpointTX}($1$, $n$, $c_{\mathrm{virt}}$,
      $c_{1, \mathrm{right}}$, $c_{2, \mathrm{left}}$, $\pk{1,
      \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{2, \mathrm{left},
      \mathrm{fund}, \mathrm{old}}$, $\pk{1, \mathrm{fund}, \mathrm{new}}$,
      $\pk{2, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{left},
      \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$, $(\pk{j, 2,
      1})_{j \in [n]}$, $t_2$)
      \label{code:virtual-layer:fundee-sigs:tx}
      \label{code:virtual-layer:funder-sigs:tx-none}
      \State \Return (\textsc{ok})
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:funder-sigs}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt.circulateVirtualSigs}($\mathrm{sigs}_{\mathrm{byLeft}}$)}
    \begin{algorithmic}[1]
      \If{$1 < i < n$} \Comment{we are not \texttt{host\_funder} nor
      \texttt{host\_fundee}}
        \State \Return \textsc{virt.intermediarySigs}()
      \ElsIf{$i = 1$} \Comment{we are \texttt{host\_funder}}
        \State \Return \textsc{virt.hostFunderSigs}()
      \ElsIf{$i = n$} \Comment{we are \texttt{host\_fundee}}
        \State \Return \textsc{virt.hostFundeeSigs}()
      \EndIf \: \Comment{it is always $1 \leq i \leq n$ -- c.f.
      Fig.~\ref{code:virtual-layer:keys},
      l.~\ref{code:virtual-layer:keys:init:check-i} and
      l.~\ref{code:virtual-layer:keys:host-me:set-i}}
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:virtual-sigs}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt.circulateFundingSigs}($\mathrm{sigs}_{\mathrm{byLeft}}$)}
    \begin{algorithmic}[1]
      \If{$1 < i < n$} \Comment{we are not endpoint}
        \IfThenElse{$i = 2$}{$m \gets 1$}{$m \gets 2$}
        \IfThenElse{$i = n-1$}{$l \gets n$}{$l \gets n-1$}
        \State ensure that the following signatures are present in
        $\mathrm{sigs}_{\mathrm{byLeft}}$ and store them:
        \begin{itemize}
          \item \Comment{1 signature}
        \end{itemize}
        \Indent
          \State sig($\mathrm{TX}_{i, 1}, \pk{i-1, \mathrm{right},
          \mathrm{fund}, \mathrm{old}}$)
        \EndIndent
        \begin{itemize}
          \item \Comment{$n-3 + \chi_{i=2} + \chi_{i=n-1}$ signatures}
        \end{itemize}
        \Indent
          \State $\forall k \in \{m, \dots, l\} \setminus \{i\}$
          \Indent
            \State sig($\mathrm{TX}_{i, 2, k}, \pk{i-1, \mathrm{right},
            \mathrm{fund}, \mathrm{old}}$)
          \EndIndent
        \EndIndent
        \State input (\textsc{virtual base sig forward},
        $\mathrm{sigs}_{\mathrm{byLeft}}$) to \texttt{sibling}
        \State \trustedcode{extract and store sig($\mathrm{TX}_{i, 1}, \pk{i-1,
        \mathrm{right}, \mathrm{fund}, \mathrm{old}}$) and $\forall k \in \{m,
        \dots, l\} \setminus \{i\}$ sig($\mathrm{TX}_{i, 2, k}, \pk{i-1,
        \mathrm{right}, \mathrm{fund}, \mathrm{old}}$) from
        $\mathrm{sigs}_{\mathrm{byLeft}}$} \Comment{same signatures as
        \texttt{sibling}}
        \State \trustedcode{$\mathrm{sigs}_{\mathrm{toRight}} \gets
        \{\textsc{sign}(\mathrm{TX}_{i+1, 1}, \sk{i, \mathrm{right},
        \mathrm{fund}, \mathrm{old}}, \texttt{ANYPREVOUT})\}$}
        \If{\trustedcode{$i+1 < n$}}
          \IfThenElse{\trustedcode{$i+1 = n-1$}}{\trustedcode{$l' \gets
          n$}}{\trustedcode{$l' \gets n-1$}}
          \ForAll{\trustedcode{$k \in \{2, \dots, l'\}$}}
            \State \trustedcode{add \textsc{sign}($\mathrm{TX}_{i+1, 2, k}$,
            $\sk{i, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$,
            \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toRight}}$}
          \EndFor
        \EndIf
        \State \trustedcode{call
        \textsc{virt.circulateFundingSigs}($\mathrm{sigs}_{\mathrm{toRight}}$)
        of $\bar{P}$ and assign returned values to
        $\mathrm{sigs}_{\mathrm{byRight}}$}
        \State \trustedcode{ensure that the following signatures are present in
        $\mathrm{sigs}_{\mathrm{byRight}}$ and store them:}
        \begin{itemize}
          \item \Comment{1 signature}
        \end{itemize}
        \Indent
          \State \trustedcode{sig($\mathrm{TX}_{i, 1}, \pk{i+1, \mathrm{left},
          \mathrm{fund}, \mathrm{old}}$)}
        \EndIndent
        \begin{itemize}
          \item \Comment{$n-3 + \chi_{i=2} + \chi_{i=n-1}$ signatures}
        \end{itemize}
        \Indent
          \State \trustedcode{$\forall k \in \{m, \dots, l\} \setminus \{i\}$}
          \Indent
            \State \trustedcode{sig($\mathrm{TX}_{i, 2, k}, \pk{i+1,
            \mathrm{right}, \mathrm{fund}, \mathrm{old}}$)}
          \EndIndent
        \EndIndent
        \State \trustedcode{output (\textsc{virtual base sig back},
        $\mathrm{sigs}_{\mathrm{byRight}}$)}
        \State extract and store sig($\mathrm{TX}_{i, 1}, \pk{i+1,
        \mathrm{right}, \mathrm{fund}, \mathrm{old}}$) and $\forall k \in \{m,
        \dots, l\} \setminus \{i\}$ sig($\mathrm{TX}_{i, 2, k}, \pk{i+1,
        \mathrm{right}, \mathrm{fund}, \mathrm{old}}$) from
        $\mathrm{sigs}_{\mathrm{byRight}}$ \Comment{same signatures as
        \texttt{sibling}}
        \State $\mathrm{sig}_{\mathrm{toLeft}} \gets
        \{\textsc{sign}(\mathrm{TX}_{i-1, 1}, \sk{i, \mathrm{left},
        \mathrm{fund}, \mathrm{old}}, \texttt{ANYPREVOUT})\}$
        \If{$i-1 > 1$}
          \IfThenElse{$i-1 = 2$}{$m' \gets
          1$}{$m' \gets 2$}
          \ForAll{$k \in \{m', \dots, n-1\}$}
            \State add \textsc{sign}($\mathrm{TX}_{i-1, 2, k}$,
            $\sk{i, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
            \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toLeft}}$
          \EndFor
        \EndIf
        \State \Return $\mathrm{sigs}_{\mathrm{toLeft}}$
      \ElsIf{$i = 1$} \Comment{we are \texttt{host\_funder}}
        \State $\mathrm{sigs}_{\mathrm{toRight}} \gets
        \{\textsc{sign}(\mathrm{TX}_{2, 1}, \sk{1, \mathrm{right},
        \mathrm{fund}, \mathrm{old}}, \texttt{ANYPREVOUT})\}$
        \label{code:virtual-layer:funding-sigs:funder-sign-first}
        \IfThenElse{$2 = n-1$}{$l' \gets n$}{$l' \gets n-1$}
        \ForAll{$k \in \{3, \dots, l'\}$}
          \State add \textsc{sign}($\mathrm{TX}_{2, 2, k}$, $\sk{1,
          \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, \texttt{ANYPREVOUT})
          to $\mathrm{sigs}_{\mathrm{toRight}}$
        \EndFor
        \label{code:virtual-layer:funding-sigs:funder-sign-second-end}
        \State call
        \textsc{virt.circulateFundingSigs}($\mathrm{sigs}_{\mathrm{toRight}}$)
        of $\bar{P}$ and assign returned value to
        $\mathrm{sigs}_{\mathrm{byRight}}$
        \State ensure that sig($\mathrm{TX}_{1, 1}$, $\pk{2, \mathrm{left},
        \mathrm{fund}, \mathrm{old}}$) is present in
        $\mathrm{sigs}_{\mathrm{byRight}}$ and store it
        \label{code:virtual-layer:funding-sigs:funder-check-sig}
        \State \Return (\textsc{ok})
      \ElsIf{$i = n$} \Comment{we are \texttt{host\_fundee}}
        \State ensure sig($\mathrm{TX}_{n, 1}$, $\pk{n-1, \mathrm{right},
        \mathrm{fund}, \mathrm{old}}$) is present in
        $\mathrm{sigs}_{\mathrm{byLeft}}$ and store it
        \State $\mathrm{sigs}_{\mathrm{toLeft}} \gets
        \{\textsc{sign}(\mathrm{TX}_{n-1, 1}, \sk{n, \mathrm{left},
        \mathrm{fund}, \mathrm{old}}, \texttt{ANYPREVOUT})\}$
        \IfThenElse{$n-1 = 2$}{$m' \gets 1$}{$m' \gets 2$}
        \ForAll{$k \in \{m', \dots, n-2\}$}
          \State add \textsc{sign}($\mathrm{TX}_{n-1, 2, k}$, $\sk{n,
          \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, \texttt{ANYPREVOUT}) to
          $\mathrm{sigs}_{\mathrm{toLeft}}$
        \EndFor
        \State \Return $\mathrm{sigs}_{\mathrm{toLeft}}$
      \EndIf \: \Comment{it is always $1 \leq i \leq n$ -- c.f.
      Fig.~\ref{code:virtual-layer:keys},
      l.~\ref{code:virtual-layer:keys:init:check-i} and
      l.~\ref{code:virtual-layer:keys:host-me:set-i}}
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:funding-sigs}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt.circulateRevocations}(\texttt{revoc\_by\_prev})}
    \begin{algorithmic}[1]
      \If{\texttt{revoc\_by\_prev} is given as argument} \Comment{we are not
      \texttt{host\_funder}}
        \State ensure
        \texttt{guest}.\textsc{processRemoteRevocation}(\texttt{revoc\_by\_prev})
        returns (\textsc{ok})
        \label{code:virtual-layer:revocation:non-funder:proc-remote}
      \Else \: \Comment{we are \texttt{host\_funder}}
        \State $\texttt{revoc\_for\_next} \gets
        \texttt{guest}.\textsc{revokePrevious}()$
        \State input (\textsc{read}) to \ledger and assign ouput to $\Sigma$
        \State $\texttt{last\_poll} \gets |\Sigma|$
        \State call
        \textsc{virt.circulateRevocations}(\texttt{revoc\_for\_next}) of
        $\bar{P}$ and assign returned value to \texttt{revoc\_by\_next}
        \label{code:virtual-layer:revocation:revoc-by-next}
        \State ensure
        \texttt{guest}.\textsc{processRemoteRevocation}(\texttt{revoc\_by\_next})
        returns (\textsc{ok}) \Comment{If the ``ensure'' fails, the opening
        process freezes, this is intentional. The channel can still close via
        (\textsc{close})}
        \label{code:virtual-layer:revocation:funder:proc-remote}
        \State \Return (\textsc{ok})
      \EndIf
      \If{we have a \texttt{sibling}} \Comment{we are not \texttt{host\_fundee}
      nor \texttt{host\_funder}}
        \State input (\textsc{virtual revocation forward}) to \texttt{sibling}
        \State \trustedcode{$\texttt{revoc\_for\_next} \gets
        \texttt{guest}.\textsc{revokePrevious}()$}
        \State \trustedcode{input (\textsc{read}) to \ledger and assign ouput to
        $\Sigma$}
        \State \trustedcode{$\texttt{last\_poll} \gets |\Sigma|$}
        \State \trustedcode{call
        \textsc{virt.circulateRevocations}(\texttt{revoc\_for\_next}) of
        $\bar{P}$ and assign output to \texttt{revoc\_by\_next}}
        \State \trustedcode{ensure
        \texttt{guest}.\textsc{processRemoteRevocation}(\texttt{revoc\_by\_next})
        returns (\textsc{ok})}
        \State \trustedcode{output (\textsc{hosts ready}, $t_i$) to
        \texttt{guest} and expect reply (\textsc{host ack})}
        \State \trustedcode{output (\textsc{virtual revocation back})}
      \EndIf
      \State $\texttt{revoc\_for\_prev} \gets
      \texttt{guest}.\textsc{revokePrevious}()$
      \If{$1 < i < n$} \Comment{we are intermediary}
        \State output (\textsc{hosts ready}, $t_i$) to \texttt{guest} and expect
        reply (\textsc{host ack})
        \Comment{$p$ is every how many blocks we have to check the chain}
        \label{code:virtual-layer:revocation:hosts-ready}
      \Else \: \Comment{we are \texttt{host\_fundee}, case of
      \texttt{host\_funder} covered earlier}
        \State output (\textsc{hosts ready}, $p + \sum\limits_{j = 2}^{n-1}(s -
        1 + t_j)$) to \texttt{guest} and expect reply (\textsc{host ack})
      \EndIf
      \State \Return \texttt{revoc\_for\_prev}
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:revocation}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt} -- poll}
    \begin{algorithmic}[1]
      \State On input (\textsc{check for lateral close}) by $R \in$
      \{\texttt{guest}, \texttt{funder}, \texttt{fundee}\}:
      \Indent
        \State input (\textsc{read}) to \ledger and assign output to $\Sigma$
        \State $k_1 \gets 0$
        \If{$\mathrm{TX}_{i-1, 1}$ is defined and $\mathrm{TX}_{i-1, 1} \in
        \Sigma$}
          \State $k_1 \gets i-1$
        \EndIf
        \ForAll{$k \in [i-2]$}
          \If{$\mathrm{TX}_{i-1, 2, k}$ is defined and $\mathrm{TX}_{i-1, 2, k}
          \in \Sigma$}
            \State $k_1 \gets k$
          \EndIf
        \EndFor
        \State $k_2 \gets 0$
        \If{$\mathrm{TX}_{i+1, 1}$ is defined and $\mathrm{TX}_{i+1, 1} \in
        \Sigma$}
          \State $k_2 \gets i+1$
        \EndIf
        \ForAll{$k \in \{i+2, \dots, n\}$}
          \If{$\mathrm{TX}_{i+1, 2, k}$ is defined and $\mathrm{TX}_{i+1, 2, k}
          \in \Sigma$}
            \State $k_2 \gets k$
          \EndIf
        \EndFor
        \State $\texttt{last\_poll} \gets |\Sigma|$
        \If{$k_1 > 0 \vee k_2 > 0$} \Comment{at least one neighbour has
        published its TX}
          \State ignore all messages except for (\textsc{check if closing}) by
          $R$
          \State $\textit{State} \gets \textsc{closing}$
          \State $\mathrm{sigs} \gets \emptyset$
        \EndIf
        \If{$k_1 > 0 \wedge k_2 > 0$} \Comment{both neighbours have published
        their TXs}
          \State add $(\mathrm{sig}(\mathrm{TX}_{i, 3, k_1, k_2}, \pk{p, i,
          k_1}))_{p \in [n] \setminus \{i\}}$ to sigs
          \State add $(\mathrm{sig}(\mathrm{TX}_{i, 3, k_1, k_2}, \pk{p, i,
          k_2}))_{p \in [n] \setminus \{i\}}$ to sigs
          \State add \textsc{sign}($\mathrm{TX}_{i, 3, k_1, k_2}$, $\sk{i, i,
          k_1}$, \texttt{ANYPREVOUT}) to sigs
          \State add \textsc{sign}($\mathrm{TX}_{i, 3, k_1, k_2}$, $\sk{i, i,
          k_2}$, \texttt{ANYPREVOUT}) to sigs
          \State input (\textsc{submit}, $\mathrm{TX}_{i, 3, k_1, k_2}$, sigs)
          to \ledger
        \ElsIf{$k_1 > 0$} \Comment{only left neighbour has published its TX}
          \State add $(\mathrm{sig}(\mathrm{TX}_{i, 2, k_1}, \pk{p, i, k_1}))_{p
          \in [n] \setminus \{i\}}$ to sigs
          \State add \textsc{sign}($\mathrm{TX}_{i, 2, k_1}$, $\sk{i, i, k_1}$,
          \texttt{ANYPREVOUT}) to sigs
          \State add \textsc{sign}($\mathrm{TX}_{i, 2, k_1}$, $\sk{i,
          \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, \texttt{ANYPREVOUT}) to
          sigs
          \State input (\textsc{submit}, $\mathrm{TX}_{i, 2, k_1}$, sigs) to
          \ledger
        \ElsIf{$k_2 > 0$} \Comment{only right neighbour has published its TX}
          \State add $(\mathrm{sig}(\mathrm{TX}_{i, 2, k_2}, \pk{p, i, k_2}))_{p
          \in [n] \setminus \{i\}}$ to sigs
          \State add \textsc{sign}($\mathrm{TX}_{i, 2, k_2}$, $\sk{i, i, k_2}$,
          \texttt{ANYPREVOUT}) to sigs
          \State add \textsc{sign}($\mathrm{TX}_{i, 2, k_2}$, $\sk{i,
          \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, \texttt{ANYPREVOUT}) to
          sigs
          \State input (\textsc{submit}, $\mathrm{TX}_{i, 2, k_2}$, sigs) to
          \ledger
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:poll}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt} -- On input (\textsc{close}) by $R \in
  \{\texttt{guest}, \texttt{funder}, \texttt{fundee}\}$:}
    \begin{algorithmic}[1]
      \State \Comment{At most one of \texttt{funder}, \texttt{fundee} is
      defined}
      \IfThen{\textit{State} = \textsc{closed}}{output (\textsc{closed}) to
      $R$}
      \IfThen{\textit{State} = \textsc{guest punished}}{output (\textsc{guest
      punished}) to $R$}
      \label{code:virtual-layer:close:output-guest-punished}
      \State ensure \textit{State} = \textsc{open}
      \If{$\texttt{host}_P \neq \ledger$} \Comment{$\texttt{host}_P$ is a
      \textsc{virt}}
      \label{code:virtual-layer:close:if-nested-host}
        \State ignore all messages except for output (\textsc{closed}) by
        $\texttt{host}_P$. Also relay to $\texttt{host}_P$ any (\textsc{check if
        closing}) input received
        \State input (\textsc{close}) to $\texttt{host}_P$
      \EndIf
      \State \Comment{if we have a $\texttt{host}_P$, continue from here on
      output (\textsc{closed}) by it}
      \State send (\textsc{read}) to \ledger as $R$ and assign reply to
      $\Sigma$
      \If{$i \in \{1, n\} \wedge (\mathrm{TX}_{(i-1) + \frac{2}{n-1}(n-i), 1}
      \in \Sigma \vee \exists k \in [n]: \mathrm{TX}_{(i-1) +
      \frac{2}{n-1}(n-i), 2, k} \in \Sigma)$} \Comment{we are an endpoint and
      our counterparty has closed -- 1st subscript of TX is $2$ if $i=1$ and
      $n-1$ if $i=n$}
        \State ignore all messages except for (\textsc{check if closing}) by $R$
        \State $\textit{State} \gets \textsc{closing}$
        \State give up execution token \Comment{control goes to \environment}
      \EndIf
      \State let \texttt{tx} be the unique TX among $\mathrm{TX}_{i, 1}$,
      $(\mathrm{TX}_{i, 2, k})_{k \in [n]}$, $(\mathrm{TX}_{i, 3, k_1,
      k_2})_{k_1, k_2 \in [n]}$ that can be appended to $\Sigma$ in a valid way
      \Comment{ignore invalid subscript combinations}
      \label{code:virtual-layer:close:tx}
      \State let \texttt{sigs} be the set of stored signatures that sign
      \texttt{tx}
      \State add \textsc{sign}(\texttt{tx}, $\sk{i, \mathrm{left},
      \mathrm{fund}, \mathrm{old}}$, \texttt{ANYPREVOUT}),
      \textsc{sign}(\texttt{tx}, $\sk{i, \mathrm{right}, \mathrm{fund},
      \mathrm{old}}$, \texttt{ANYPREVOUT}), $(\textsc{sign}(\texttt{tx}, \sk{i,
      j, k}, \texttt{ANYPREVOUT}))_{j, k \in [n]}$ to \texttt{sigs}
      \Comment{ignore invalid signatures}
      \State ignore all messages except for (\textsc{check if closing}) by $R$
      \State $\textit{State} \gets \textsc{closing}$
      \State send (\textsc{submit}, \texttt{tx}, \texttt{sigs}) to \ledger
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:close}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt} -- On input (\textsc{check if closing}) by
  $R \in \{\texttt{guest}, \texttt{funder}, \texttt{fundee}\}$:}
    \begin{algorithmic}[1]
      \State ensure \textit{State} = \textsc{closing}
      \State send (\textsc{read}) to \ledger as $R$ and assign reply to $\Sigma$
      \If{$i = 1$} \Comment{we are \texttt{host\_funder}}
        \State ensure that there exists an output with $c_P + c_{\bar{P}} -
        c_{\mathrm{virt}}$ coins and a $2/\{\pk{1, \mathrm{fund}, \mathrm{new}},
        \pk{2, \mathrm{fund}, \mathrm{new}}\}$ spending method with
        expired/non-existent timelock in $\Sigma$ \Comment{new base funding
        output}
        \label{code:virtual-layer:check-chain-close:funder:output-funder}
        \State ensure that there exists an output with $c_{\mathrm{virt}}$ coins
        and a $2/\{\pk{\mathrm{left}, \mathrm{virt}}, \pk{\mathrm{right},
        \mathrm{virt}}\}$ spending method with expired/non-existent timelock in
        $\Sigma$ \Comment{virtual funding output}
        \label{code:virtual-layer:check-chain-close:funder:output-virt}
      \ElsIf{$i = n$} \Comment{we are \texttt{host\_fundee}}
        \State ensure that there exists an output with $c_P + c_{\bar{P}} -
        c_{\mathrm{virt}}$ coins and a $2/\{\pk{n-1, \mathrm{fund},
        \mathrm{new}}, \pk{n, \mathrm{fund}, \mathrm{new}}\}$ spending method
        with expired/non-existent timelock in $\Sigma$ \Comment{new base funding
        output}
        \State ensure that there exists an output with $c_{\mathrm{virt}}$ coins
        and a $2/\{\pk{\mathrm{left}, \mathrm{virt}}, \pk{\mathrm{right},
        \mathrm{virt}}\}$ spending method with expired/non-existent timelock in
        $\Sigma$ \Comment{virtual funding output}
      \Else \: \Comment{we are intermediary}
        \IfThenElse{$\mathtt{side} = \text{``left''}$}{$j \gets i-1$}{$j \gets
        i+1$} \Comment{\texttt{side} is defined for all intermediaries -- c.f.
        Fig.~\ref{code:virtual-layer:keys},
        l.~\ref{code:virtual-layer:keys:init}}
        \State ensure that there exists an output with $c_P + c_{\bar{P}} -
        c_{\mathrm{virt}}$ coins and a $2/\{\pk{i, \mathrm{fund}, \mathrm{new}},
        \pk{j, \mathrm{fund}, \mathrm{new}}\}$ spending method with
        expired/non-existent timelock and an output with $c_{\mathrm{virt}}$
        coins and a $\pk{i, \mathrm{out}}$ spending method with
        expired/non-existent timelock in $\Sigma$
      \EndIf
      \State $\textit{State} \gets \textsc{closed}$
      \State output (\textsc{closed}) to $R$
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:check-chain-close}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt} -- punishment handling}
    \begin{algorithmic}[1]
      \State On input (\textsc{used revocation}) by \texttt{guest}:
      \Comment{(\textsc{used revocation}) by \texttt{funder}/\texttt{fundee} is
      ignored}
      \label{code:virtual-layer:punishment:when-punished-1}
      \Indent
        \State $\textit{State} \gets \textsc{guest punished}$
        \State input (\textsc{used revocation}) to $\texttt{host}_P$, expect
        reply (\textsc{used revocation ok})
        \If{\texttt{funder} or \texttt{fundee} is defined}
          \State output (\textsc{enabler used revocation}) to it
        \Else \: \Comment{\texttt{sibling} is defined}
          \State output (\textsc{enabler used revocation}) to \texttt{sibling}
        \EndIf
      \EndIndent
      \Statex

      \State On input (\textsc{enabler used revocation}) by \texttt{sibling}:
      \Indent
        \State $\textit{State} \gets \textsc{guest punished}$
        \State output (\textsc{enabler used revocation}) to \texttt{guest}
      \EndIndent
      \Statex

      \State On output (\textsc{used revocation}) by $\texttt{host}_P$:
      \label{code:virtual-layer:punishment:when-punished-2}
      \Indent
        \State $\itistate \gets \textsc{guest punished}$
        \If{\texttt{funder} or \texttt{fundee} is defined}
          \State output (\textsc{enabler used revocation}) to it
        \Else \: \Comment{\texttt{sibling} is defined}
          \State output (\textsc{enabler used revocation}) to \texttt{sibling}
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:punishment}
\end{center}
