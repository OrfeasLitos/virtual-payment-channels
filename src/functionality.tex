\TODO{Add support for cooperative adding multiple virtuals to single channel
(needs cooperation by all hops of all existing virtuals of current channel)}
\TODO{Add support for cooperative closing (for virtual it also needs cooperation
with all hops of all existing virtuals, we should definitely find another way)}

\fchan is parametrized by the (stateful) processes \textsc{pcn} (payment channel
network) and \textsc{virt} (virtual layer). \TODO{if the 2 processes share too
much state, merge into 1 process}

If:
\begin{itemize}
  \item \fchan is activated by $\dave \in \{\alice, \bob\}$,
  \item \fchan then calls a method of either process (expecting some value to be
  returned by it),
  \item and subsequently the method gives up the execution token to another ITI
  (before it returns),
\end{itemize}
then \fchan repeatedly relays any input by \dave to the method until the latter
returns.

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- init \& top up}
    \begin{algorithmic}[1]
      \State $\mathrm{locked}_D$ for $D \in \{\alice, \bob\}$:
      \Indent
        \State $\mathrm{res} \gets 0$
        \For{$((c_1, c_2), \_, \_, (D, \_), \_) \in \texttt{virtuals}$}
          \State $\mathrm{res} \gets \mathrm{res} + c_1 + c_2$
        \EndFor
        \State \Return res
      \EndIndent
      \Statex

      \State Initialisation: \Comment{runs on first activation}
      \Indent
        \State $(c_A, c_B, \mathrm{locked}_A, \mathrm{locked}_B) \gets (0, 0, 0,
        0)$
        \State $\texttt{virtuals} \gets \emptyset$
        \State $(\texttt{funder}, \texttt{fundee}, \texttt{outer\_funder},
        \texttt{outer\_fundee}) \gets (\bot, \bot, \bot, \bot)$
        \State ensure \textsc{pcn.init}() returns (\textsc{ok})
        \State $\mathit{State} \gets \textsc{init}$
      \EndIndent
      \Statex

      \State On (\textsc{top up}, \texttt{fundee}) by \texttt{funder}:
      \label{code:functionality:chan:skeleton:init:top_up:start}
      \Indent
        \State ensure $\mathit{State} = \textsc{init}$
        \State $\bob \gets \texttt{fundee}$
        \State ensure \textsc{pcn.topUp}(\texttt{funder}) returns (\textsc{ok})
        \State $\mathit{State} \gets \textsc{topped up}$
        \State output (\textsc{topped up}) to \texttt{funder}
        \label{code:functionality:chan:skeleton:init:top_up:end}
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:init}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- base}
    \begin{algorithmic}[1]
      \State On (\textsc{open base}, \texttt{keys}) by \alice:
      \Indent
        \State ensure $\mathit{State} = \textsc{topped up} \wedge
        \mathtt{funder} = \alice$
        \State ensure \textsc{pcn.openBase}(\texttt{keys}, \bob) returns
        (\textsc{ok}, $c$)
        \State $c_A \gets c$; $c_B \gets 0$
        \State $\mathit{State} \gets \textsc{open base}$
        \State output (\textsc{opened base}) to \alice
      \EndIndent
      \Statex

      \State On (\textsc{pay}, $x$) by $\dave \in \{\alice, \bob\}$:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure $c_D - \mathrm{locked}_D \geq x$
        \State send (\textsc{pay}, $x$, \dave) to \adversary and expect reply
        (\textsc{ok}) \TODO{decide if \textsc{pcn.pay}() needed -- probably not}
        \State $c_D \gets c_D - x; c_{\bar{D}} \gets c_{\bar{D}} + x$
        \Comment{$\bar{D}$ is \alice if $D$ is \bob and vice-versa}
        \State output (\textsc{pay success}) to \dave
      \EndIndent
      \Statex

      \State On (\textsc{balance}) by $\dave \in \{\alice, \bob\}$:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State output (\textsc{balance}, $c_A, c_B, \mathrm{locked}_A,
        \mathrm{locked}_B$) to \dave
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:base}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- close Pt. 1}
    \begin{algorithmic}[1]
      \State On (\textsc{close}) by \alice:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure \textsc{virt.close}(\alice) returns (\textsc{ok},
        $(\mathrm{tx}_i, (\sigma_{ij})_j)_i$) \Comment{\textsc{virt} doesn't
        need to know if we are base or virtual}
        \If{\textit{State} = \textsc{open base}}
          \State ensure \textsc{pcn.close}(\alice, $(\mathrm{tx}_i,
          (\sigma_{ij})_j)_i$) returns (\textsc{ok})
          \State $\mathit{State} \gets \textsc{closed}$
          \State output (\textsc{ok}) to \alice
        \Else \: \Comment{\textit{State} = \textsc{open virtual}}
          \State $\mathit{State} \gets \textsc{closed}$
          \State output (\textsc{closed virtual}, $(\mathrm{tx}_i,
          (\sigma_{ij})_j)_i$) to \texttt{host\_alice} as \alice
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:close:pt1}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- close Pt. 2}
    \begin{algorithmic}[1]
      \State On (\textsc{(peer) closed virtual}, $(V', \mathrm{sig}_{A, V'},
      \mathrm{sig}_{B, V'})$, $(C, \mathrm{sig}_{A, C}, \mathrm{sig}_{B, C})$)
      by \charlie:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure (($c_L$, $c_R$), hops, (\charlie, \dave), (\frank,
        \george), $pk_{A, V}$, $pk_{B, V}$, id) $\in$ \texttt{virtuals}
        with $\frank \in \{\alice, \bob\}$ \Comment{no stored commitment TX in
        entry yet}
        \If{second tuple of message is empty}
          \State ensure \textsc{verify}($C$, $\mathrm{sig}_{A, C}$, $pk_{A, V}$)
          = \textsc{verify}($C$, $\mathrm{sig}_{B, C}$, $pk_{B, V}$) = True
        \Else
          \State ensure \textsc{verify}($V'$, $\mathrm{sig}_{A, V'}$, $pk_{A,
          V}$) = \textsc{verify}($V'$, $\mathrm{sig}_{B, V'}$, $pk_{B, V}$) =
          \textsc{verify}($C$, $\mathrm{sig}_{A, C}$, $pk_{A, V'}$) =
          \textsc{verify}($C$, $\mathrm{sig}_{B, C}$, $pk_{B, V'}$) = True
        \EndIf
        \State $c_{\mathrm{left}} \gets C\text{.outputs.(the timelocked
        output).coins}$
        \State $c_{\mathrm{right}} \gets C\text{.outputs.(the other
        output).coins}$
        \State ensure $c_{\mathrm{left}} + c_{\mathrm{right}} = c_L + c_R$
        \State add message contents to \texttt{virtuals} entry
        \State output (\textsc{(peer) closed virtual}, $c_{\mathrm{left}}$, id) to
        \george if peer closed, to \frank else
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:close:pt2}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- fund virtual}
    \begin{algorithmic}[1]
      \State On (\textsc{fund}, $c$, \texttt{hops}, \texttt{inner\_parties} =
      (\texttt{inner\_fundee}, \texttt{inner\_peer}), \texttt{outer\_parties} =
      (\texttt{outer\_funder}, \texttt{outer\_peer}), \texttt{keys}) by \alice:
      \TODO{\texttt{keys} = $pk_{\mathit{VA}, out}$, $pk_{\mathit{VB},
      out}$, use this in \textsc{virt.fund}()}
      \Comment{we fund another channel}
      \label{code:functionality:chan:skeleton:virtual:fund}
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure $c_A - \mathrm{locked}_A \geq c$
        \State ensure \texttt{outer\_funder} = \alice
        \State input (\textsc{open virtual}, $c$, \texttt{inner\_peer},
        \texttt{outer\_peer}, \texttt{keys}) to \texttt{inner\_fundee} as
        \alice, ensure output is (\textsc{ok}, \texttt{in\_keys})
        \label{code:functionality:chan:skeleton:virtual:subfunc}
        \State generate unique \textit{vid}
        \label{code:functionality:chan:skeleton:virtual:id}
        \State ensure \textsc{virt.fund}($c$, \texttt{hops},
        \texttt{inner\_parties}, \texttt{outer\_parties}, \textit{vid}) returns
        (\textsc{ok})
        \label{code:functionality:chan:skeleton:virtual:fund:virt}
        \State add (($c$, 0), \texttt{hops}, \texttt{inner\_parties},
        \texttt{outer\_parties}, \textit{vid}) to \texttt{virtuals}
        \label{code:functionality:chan:skeleton:virtual:fund:store}
        \State output (\textsc{ok}) to \alice
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:virtual:fund:fig}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- virtual}
    \begin{algorithmic}[1]
      \State On input (\textsc{open virtual}, $c$, \texttt{local\_peer},
      \texttt{host\_bob}, \texttt{keys}) by $\charlie$ to \alice:
      \Comment{\alice is funded by \charlie}
      \label{code:functionality:chan:skeleton:virtual:fund-you}
      \Indent
        \State ensure $\mathit{State} = \textsc{init}$
        \State ensure \textsc{pcn.virtualOpen}($c$, \texttt{keys}) returns
        (\textsc{ok})
        \label{code:functionality:chan:skeleton:virtual:ln}
        \State $\bob \gets \texttt{local\_peer}$
        \State $\mathtt{opener}, \texttt{host\_alice} \gets \charlie$
        \State $c_A \gets c; c_B \gets 0$
        \State from now on, handle any (\textsc{relayed}, $m$) input by
        \{\texttt{opener}, \texttt{host\_bob}\} as if it were input ($m$) by
        $\{\alice, \bob\}$ respectively
        \State from now on, transform any output ($m$) to $\{\alice, \bob\}$ to
        output (\textsc{relay}, $m$) to $\{\texttt{host\_alice},
        \texttt{host\_bob}\}$ respectively
        \State $\mathit{State} \gets \textsc{open virtual}$
        \State output (\textsc{ok}, $pk_{A, V}$, $pk_{B, V}$) to \charlie
      \EndIndent
      \Statex

      \State On (\textsc{relay}, $m$, \charlie) by \alice:
      \Indent
        \State ensure there is an entry in \texttt{virtuals} with \alice as funder
        outer party and \charlie as fundee sub-party
        \label{code:functionality:chan:skeleton:virtual:relay:input:start}
        \State input (\textsc{relayed}, $m$) to \charlie
        \label{code:functionality:chan:skeleton:virtual:relay:input:end}
      \EndIndent
      \Statex

      \State On output (\textsc{relay}, $m$) by \charlie to \alice:
      \Indent
        \State ensure there is an entry in \texttt{virtuals} with \alice as funder
        outer party and \charlie as fundee sub-party \Comment{defensive check,
        may be redundant due to being subroutine respecting}
        \label{code:functionality:chan:skeleton:virtual:relay:output:start}
        \State output (\textsc{relayed}, $m$, \charlie) to \environment
        \label{code:functionality:chan:skeleton:virtual:relay:output:end}
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:virtual}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- corruption}
    \begin{algorithmic}[1]
      \State On (\textsc{corrupt}) by $P$, addressed to \alice:
      \Indent
        \State ensure $P \in \{\texttt{host\_alice}, \adversary\}$
        \State $\texttt{virtual\_secrets} \gets \emptyset$
        \ForAll{$(\_, \_, (\mathrm{fundee}, \_), (\alice, \_), \textit{vid}) \in
        \mathtt{virtuals}$}
          \State send (\textsc{corrupt}) to fundee and ensure reply is
          (\textsc{corrupted}, \texttt{secrets})
          \State append (\texttt{secrets}, \textit{vid}) to
          \texttt{virtual\_secrets}
        \EndFor
        \State from now on, allow \adversary to handle all \alice's messages,
        i.e. act as a relay
        \If{\bob is not corrupted}
          \State $\texttt{ln\_messages} \gets \{\textsc{open base}, \textsc{open
          virtual}, \textsc{top up}, \textsc{pay}, \textsc{balance}\}$
          \State $\texttt{virt\_messages} \gets \{\textsc{fund}\}$
          \State from now on, upon receiving any message $M$ of type $T \in
          \texttt{ln\_messages}, \texttt{virt\_messages}$ by \bob, do
          \textsc{pcn.call}($M$, \bob) or \textsc{virt.call}($M$, \bob)
          respectively
          \State from now on, upon receiving a message (\textsc{close}) by \bob
          do \textsc{pcn.close}(\bob, \textsc{virt.close}(\bob))
          \TODO{\textsc{pcn.close}() should know to just return its input
          (probably?) if we are \textsc{open virtual}}
        \EndIf
        \If{$P = \texttt{host\_alice}$}
          \State output (\textsc{corrupted}, (\textsc{ln.secrets}(\alice),
          \texttt{virtual\_secrets})) to \texttt{host\_alice}
        \Else \: \Comment{$P = \adversary$}
          \State send (\textsc{corrupted}, (\textsc{ln.secrets}(\alice),
          \texttt{virtual\_secrets})) to \adversary
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:corruption}
\end{figure}
