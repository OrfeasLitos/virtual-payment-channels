\begin{center} % \captionof hinders page break if not in an environment
  \begin{processbox}{\textsc{virt}}
    \ \\
    \begin{algorithmic}[1]
      \State On every activation, before handling the message:
      \Indent
        \If{$\texttt{last\_poll} \neq \bot$} \Comment{virtual layer is ready}
          \State input (\textsc{read}) to \ledger and assign ouput to $\Sigma$
          \If{$\texttt{last\_poll} + p < |\Sigma|$}
            \For{$P \in \{\texttt{guest}, \texttt{funder}, \texttt{fundee}\}$}
            \Comment{at most 1 of \texttt{funder}, \texttt{fundee} is defined}
              \State ensure $P$.\textsc{negligent}() returns (\textsc{ok})
            \EndFor
          \EndIf
        \EndIf
      \EndIndent
      \Statex

      \State \Comment {\texttt{guest} is trusted to give sane inputs, therefore
      a state machine and input verification are redundant}
      \State On input (\textsc{init}, $\texttt{host}_P$, $\bar{P}$,
      \texttt{sibling}, \texttt{fundee}, ($\sk{\mathrm{loc}, \mathrm{fund},
      \mathrm{new}}$, $\pk{\mathrm{loc}, \mathrm{fund}, \mathrm{new}}$),
      $\pk{\mathrm{rem}, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{sib},
      \mathrm{rem}, \mathrm{fund}, \mathrm{new}}$, ($\sk{\mathrm{loc},
      \mathrm{fund}, \mathrm{old}}$, $\pk{\mathrm{loc}, \mathrm{fund},
      \mathrm{old}}$), $\pk{\mathrm{rem}, \mathrm{fund}, \mathrm{old}}$,
      $\pk{\mathrm{loc}, \mathrm{out}}$, $c_P$, $c_{\bar{P}}$,
      $c_{\mathrm{virt}}$, $t_P$, $i$, \texttt{side}, $n$) by \texttt{guest}:
      \label{code:virtual-layer:keys:init}
      \Indent
        \State ensure $1 < i \leq n$ \Comment{\texttt{host\_funder} ($i = 1$) is
        initialised with \textsc{host me}}
        \label{code:virtual-layer:keys:init:check-i}
        \State ensure $\texttt{side} \in \{\text{``left''},
        \text{``right''}\}$
        \State store message contents and \texttt{guest}
        \Comment{\texttt{sibling}, $\pk{\mathrm{sib}, \bar{P}, F}$ are missing
        for endpoints, \texttt{fundee} is present only in last node}
        \State $(\sk{i, \mathrm{fund}, \mathrm{new}}, \pk{i, \mathrm{fund},
        \mathrm{new}}) \gets (\sk{\mathrm{loc}, \mathrm{fund}, \mathrm{new}},
        \pk{\mathrm{loc}, \mathrm{fund}, \mathrm{new}})$
        \State $\pk{\texttt{myRem}, \mathrm{fund}, \mathrm{new}} \gets
        \pk{\mathrm{rem}, \mathrm{fund}, \mathrm{new}}$
        \If{$i < n$} \Comment{we are not last hop}
          \State $\pk{\texttt{sibRem}, \mathrm{fund}, \mathrm{new}} \gets
          \pk{\mathrm{sib}, \mathrm{rem}, \mathrm{fund}, \mathrm{new}}$
        \EndIf
        \If{$\texttt{side} = \text{``left''}$}
          \State $\texttt{side}' \gets \text{``right''}$; $\texttt{myRem}
          \gets i-1$; $\texttt{sibRem} \gets i+1$
          \State $\pk{i, \mathrm{out}} \gets \pk{\mathrm{loc}, \mathrm{out}}$
          \State $(\sk{i, j, k}, \pk{i, j, k})_{j \in \{2, \dots, n-1\}, k \in
          [n] \setminus \{j\}} \gets \textsc{keyGen}()^{(n-2)(n-1)}$
          \State $(\sk{i, \mathrm{rev}}, \pk{i, \mathrm{rev}}) \gets
          \textsc{keyGen}()$
        \Else \: \Comment{$\texttt{side} = \text{``right''}$}
          \State $\texttt{side}' \gets \text{``left''}$; $\texttt{myRem} \gets
          i+1$; $\texttt{sibRem} \gets i-1$
          \State \Comment{\texttt{sibling} will send keys in \textsc{keys and
          coins forward}}
        \EndIf
        \State $(\sk{i, \texttt{side}, \mathrm{fund}, \mathrm{old}}, \pk{i,
        \texttt{side}, \mathrm{fund}, \mathrm{old}}) \gets (\sk{\mathrm{loc},
        \mathrm{fund}, \mathrm{old}}, \pk{\mathrm{loc}, \mathrm{fund},
        \mathrm{old}})$
        \State $\pk{\texttt{myRem}, \texttt{side}', \mathrm{fund}, \mathrm{old}}
        \gets \pk{\mathrm{rem}, \mathrm{fund}, \mathrm{old}}$
        \State $(c_{i, \texttt{side}}, c_{\texttt{myRem}, \texttt{side}'}, t_{i,
        \texttt{side}}) \gets (c_P, c_{\bar{P}}, t_P)$
        \State $\texttt{last\_poll} \gets \bot$
        \State output (\textsc{host init ok}) to \texttt{guest}
      \EndIndent
      \Statex

      \State On input (\textsc{host me}, \texttt{funder}, \texttt{fundee},
      $\bar{P}$, $\texttt{host}_P$, $c_P$, $c_{\bar{P}}$, $c_{\mathrm{virt}}$,
      $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$,
      ($\sk{1, \mathrm{fund}, \mathrm{new}}$, $\pk{1, \mathrm{fund},
      \mathrm{new}}$), ($\sk{1, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$,
      $\pk{1, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$), $\pk{2,
      \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{2, \mathrm{left},
      \mathrm{fund}, \mathrm{new}}$, $\pk{1, \mathrm{out}}$, $n$) by
      \texttt{guest}:
      \Indent
        \State $\texttt{last\_poll} \gets \bot$
        \State $i \gets 1$
        \State $c_{1, \mathrm{right}} \gets c_P$; $c_{2, \mathrm{left}} \gets
        c_{\bar{P}}$
        \label{code:virtual-layer:keys:host-me:set-i}
        \State $(\sk{1, j, k}, \pk{1, j, k})_{j \in \{2, \dots, n-1\}, k \in [n]
        \setminus \{j\}} \gets \textsc{keyGen}()^{(n-2)(n-1)}$
          \State $(\sk{1, \mathrm{rev}}, \pk{1, \mathrm{loc},
          \mathrm{rev}}) \gets \textsc{keyGen}()$
        \State ensure \textsc{virt.circulateKeysCoinsTimes}() returns
        (\textsc{ok})
        \State ensure \textsc{virt.circulateVirtualSigs}() returns (\textsc{ok})
        \State ensure \textsc{virt.circulateFundingSigs}() returns (\textsc{ok})
        \State ensure \textsc{virt.circulateRevocations}() returns (\textsc{ok})
        \State output (\textsc{hosts ready}, $p + \sum\limits_{j = 2}^{n-1}(s -
        1 + t_j)$) to \texttt{guest} \Comment{$p$ is every how many blocks we
        have to check the chain}
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:keys}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt}.\textsc{circulateKeysCoinsTimes}(\texttt{left\_data}):}
    \ \\
    \begin{algorithmic}[1]
      \If{\texttt{left\_data} is given as argument} \Comment{we are not
      \texttt{host\_funder}}
        \State parse \texttt{left\_data} as ($(\pk{j, \mathrm{fund},
        \mathrm{new}})_{j \in [i-1]}$, $(\pk{j, \mathrm{left}, \mathrm{fund},
        \mathrm{old}})_{j \in \{2, \dots, i-1\}}$, $(\pk{j, \mathrm{right},
        \mathrm{fund}, \mathrm{old}})_{j \in [i-1]}$, $(\pk{j, \mathrm{out}})_{j
        \in [i-1]}$, $(c_{j, \mathrm{left}})_{j \in \{2, \dots, i-1\}}$, $(c_{j,
        \mathrm{right}})_{j \in [i-1]}$, $(t_j)_{j \in [i-1]}$,
        $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right},
        \mathrm{virt}}$, $(\pk{h, j, k})_{h \in [i-1], j \in \{2, \dots, n-1\},
        k \in [n] \setminus \{j\}}$, $(\pk{h, \mathrm{loc}, \mathrm{rev}})_{h
        \in [i-1]}$, $(\pk{h, \mathrm{rem}, \mathrm{rev}})_{h \in [i-1]}$)
        \If{we have a \texttt{sibling}} \Comment{we are not
        \texttt{host\_fundee}}
          \State input (\textsc{keys and coins forward}, (\texttt{left\_data},
          ($\sk{i, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{i,
          \mathrm{left}, \mathrm{fund}, \mathrm{old}}$), $\pk{i, \mathrm{out}}$,
          $c_{i, \mathrm{left}}$, $t_{i, \mathrm{left}}$, $(\sk{i, j, k}, \pk{i,
          j, k})_{j \in \{2, \dots, n-1\}, k \in [n] \setminus \{j\}}$,
          $(\sk{i, \mathrm{rev}}, \pk{i, \mathrm{rev}})$) to \texttt{sibling}
          \State \trustedcode{store input as \texttt{left\_data} and parse it as
          ($(\pk{j, \mathrm{fund}, \mathrm{new}})_{j \in [i-1]}$, $(\pk{j,
          \mathrm{left}, \mathrm{fund}, \mathrm{old}})_{j \in \{2, \dots, i\}}$,
          $(\pk{j, \mathrm{right}, \mathrm{fund}, \mathrm{old}})_{j \in [i-1]}$,
          $(\pk{j, \mathrm{out}})_{j \in [i]}$, $(c_{j, \mathrm{left}})_{j \in
          \{2, \dots, i\}}$, $(c_{j, \mathrm{right}})_{j \in [i-1]}$, $(t_j)_{j
          \in [i-1]}$, $\sk{i, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
          $t_{i, \mathrm{left}}$, $\pk{\mathrm{left}, \mathrm{virt}}$,
          $\pk{\mathrm{right}, \mathrm{virt}}$, $(\pk{h, j, k})_{h \in [i], j
          \in \{2, \dots, n-1\}, k \in [n] \setminus \{j\}}$, $(\sk{i, j, k})_{j
          \in \{2, \dots, n-1\}, k \in [n] \setminus \{j\}}$, $(\pk{h,
          \mathrm{rev}})_{h \in [i]}$, $\sk{i, \mathrm{rev}}$}
          \State \trustedcode{$t_i \gets \max{(t_{i, \mathrm{left}}, t_{i,
          \mathrm{right}})}$}
          \State \trustedcode{replace $t_{i, \mathrm{left}}$ in
          \texttt{left\_data} with $t_i$}
          \State \trustedcode{remove $\sk{i, \mathrm{left}, \mathrm{fund},
          \mathrm{old}}$, $(\sk{i, j, k})_{j \in \{2, \dots, n-1\}, k \in [n]
          \setminus \{j\}}$, $\sk{i, \mathrm{loc}, \mathrm{rev}}$ and $\sk{i,
          \mathrm{rem}, \mathrm{rev}}$ from \texttt{left\_data}}
          \State \trustedcode{call
          \textsc{virt.circulateKeysCoinsTimes}(\texttt{left\_data}) of
          $\bar{P}$ and assign returned value to \texttt{right\_data}}
          \State \trustedcode{parse \texttt{right\_data} as ($(\pk{j,
          \mathrm{fund}, \mathrm{new}})_{j\in \{i+1, \dots, n\}}$, $(\pk{j,
          \mathrm{left}, \mathrm{fund}, \mathrm{old}})_{j \in \{i+1, \dots,
          n\}}$, $(\pk{j, \mathrm{right}, \mathrm{fund}, \mathrm{old}})_{j \in
          \{i+1, \dots, n-1\}}$, $(\pk{j, \mathrm{out}})_{j \in \{i+1, \dots,
          n\}}$, $(c_{j, \mathrm{left}})_{j \in \{i+1, \dots, n\}}$, $(c_{j,
          \mathrm{right}})_{j \in \{i+1, \dots, n-1\}}$, $(t_j)_{j \in \{i+1,
          \dots, n\}}$, $(\pk{h, j, k})_{h \in \{i+1, \dots, n\}, j
          \in \{2, \dots, n-1\}, k \in [n] \setminus \{j\}}$, $(\pk{h,
          \mathrm{rev}})_{h \in \{i+1, \dots, n\}}$)}
          \State \trustedcode{output (\textsc{keys and coins back},
          \texttt{right\_data}, ($\sk{i, \mathrm{right}, \mathrm{fund},
          \mathrm{old}}$, $\pk{i, \mathrm{right}, \mathrm{fund},
          \mathrm{old}})$, $c_{i, \mathrm{right}}$, $t_i$)}
          \State store output as \texttt{right\_data} and parse it as ($(\pk{j,
          \mathrm{fund}, \mathrm{new}})_{j \in \{i+1, \dots, n\}}$, $(\pk{j,
          \mathrm{left}, \mathrm{fund}, \mathrm{old}})_{j \in \{i+1, \dots,
          n\}}$, $(\pk{j, \mathrm{right}, \mathrm{fund}, \mathrm{old}})_{j \in
          \{i, \dots, n-1\}}$, $(\pk{j, \mathrm{out}})_{j \in \{i+1, \dots,
          n\}}$, $(c_{j, \mathrm{left}})_{j \in \{i+1, \dots, n\}}$, $(c_{j,
          \mathrm{right}})_{j \in \{i, \dots, n-1\}}$, $(t_j)_{j \in \{i, \dots,
          n\}}$, $(\pk{h, j, k})_{h \in \{i+1, \dots, n\}, j \in \{2, \dots,
          n-1\}, k \in [n] \setminus \{j\}}$, $(\pk{h, \mathrm{loc},
          \mathrm{rev}})_{h \in \{i+1, \dots, n\}}$, $(\pk{h, \mathrm{rem},
          \mathrm{rev}})_{h \in \{i+1, \dots, n\}}$, $\sk{i, \mathrm{right},
          \mathrm{fund}, \mathrm{old}}$)
          \State remove $\sk{i, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$
          from \texttt{right\_data}
          \State \Return (\texttt{right\_data}, $\pk{i, \mathrm{fund},
          \mathrm{new}}$, $\pk{i, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
          $\pk{i, \mathrm{out}}$, $c_{i, \mathrm{left}}$)
        \Else \: \Comment{we are \texttt{host\_fundee}}
          \State output (\textsc{check keys}, ($\pk{\mathrm{left},
          \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$)) to
          \texttt{fundee} and expect reply (\textsc{keys ok})
          \State \Return ($\pk{n, \mathrm{fund}, \mathrm{new}}$, $\pk{n,
          \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{n, \mathrm{out}}$,
          $c_{n, \mathrm{left}}$, $t_n$, $(\pk{n, j, k})_{j \in \{2, \dots,
          n-1\}, k \in [n] \setminus \{j\}}$, $\pk{n, \mathrm{loc},
          \mathrm{rev}}$, $\pk{n, \mathrm{rem}, \mathrm{rev}}$)
        \EndIf
      \Else \: \Comment{we are \texttt{host\_funder}}
        \State call \textsc{virt.circulateKeysCoinsTimes}($\pk{1, \mathrm{fund},
        \mathrm{new}}$, $\pk{1, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$,
        $\pk{1, \mathrm{out}}$, $c_{1, \mathrm{right}}$, $t_1$,
        $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right},
        \mathrm{virt}}$, $(\pk{1, j, k})_{j \in \{2, \dots, n-1\}, k \in [n]
        \setminus \{j\}}$, $\pk{1, \mathrm{loc}, \mathrm{rev}}$, $\pk{1,
        \mathrm{rem}, \mathrm{rev}}$) of $\bar{P}$ and assign returned value to
        \texttt{right\_data}
        \State parse \texttt{right\_data} as ($(\pk{j, \mathrm{fund},
        \mathrm{new}})_{j \in \{2, \dots, n\}}$, $(\pk{j, \mathrm{left},
        \mathrm{fund}, \mathrm{old}})_{j \in \{2, \dots, n\}}$, $(\pk{j,
        \mathrm{right}, \mathrm{fund}, \mathrm{old}})_{j \in \{2, \dots,
        n-1\}}$, $(\pk{j, \mathrm{out}})_{j \in \{2, \dots, n\}}$, $(c_{j,
        \mathrm{left}})_{j \in \{2, \dots, n\}}$, $(c_{j, \mathrm{right}})_{j
        \in \{2, \dots, n-1\}}$, $(t_j)_{j \in \{2, \dots, n\}}$, $(\pk{h, j,
        k})_{h \in \{2, \dots, n\}, j \in \{2, \dots, n-1\}, k \in [n] \setminus
        \{j\}}$, $(\pk{h, \mathrm{loc}, \mathrm{rev}})_{h \in \{2, \dots, n\}}$,
        $(\pk{h, \mathrm{rem}, \mathrm{rev}})_{h \in \{2, \dots, n\}}$)
        \State \Return (\textsc{ok})
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:circulate-keys-and-coins}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt}}
    \ \\
    \begin{algorithmic}[1]
      \State \textsc{getMidTXs}($i$, $n$, $c_{\mathrm{virt}}$, $c_{\mathrm{rem},
      \mathrm{left}}$, $c_{\mathrm{loc}, \mathrm{left}}$, $c_{\mathrm{loc},
      \mathrm{right}}$, $c_{\mathrm{rem}, \mathrm{right}}$, $\pk{\mathrm{rem},
      \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{\mathrm{loc},
      \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{\mathrm{loc},
      \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{\mathrm{rem},
      \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{\mathrm{rem},
      \mathrm{left}, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{loc},
      \mathrm{left}, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{loc},
      \mathrm{right}, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{rem},
      \mathrm{right}, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{left},
      \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$, $\pk{\mathrm{loc},
      \mathrm{out}}$, $\pk{\mathrm{funder}, \mathrm{rev}}$, $\pk{\mathrm{left},
      \mathrm{rev}}$, $\pk{\mathrm{loc}, \mathrm{rev}}$, $\pk{\mathrm{right},
      \mathrm{rev}}$, $\pk{\mathrm{fundee}, \mathrm{rev}}$, $(\pk{h,j,k})_{h \in
      [n], j \in [n-1] \setminus \{1\}, k \in [n-1] \setminus \{1, j\}}$,
      $(\pk{h, 2, 1})_{h \in [n]}$, $(\pk{h, n-1, n})_{h \in [n]}$, $(t_j)_{j
      \in [n-1] \setminus \{1\}}$):
      \Indent
        \State ensure $1 < i < n$
        \State ensure $c_{\mathrm{rem}, \mathrm{left}} \geq c_{\mathrm{virt}}
        \wedge c_{\mathrm{loc}, \mathrm{left}} \geq c_{\mathrm{virt}}$
        \Comment{left parties fund virtual channel}
        \State ensure $c_{\mathrm{rem}, \mathrm{left}} \geq c_{\mathrm{loc},
        \mathrm{right}} \wedge c_{\mathrm{rem}, \mathrm{right}} \geq
        c_{\mathrm{loc}, \mathrm{left}}$ \Comment{avoid griefing attack}
        \State $c_{\mathrm{left}} \gets c_{\mathrm{rem}, \mathrm{left}} +
        c_{\mathrm{loc}, \mathrm{left}}$; $c_{\mathrm{right}} \gets
        c_{\mathrm{loc}, \mathrm{right}} + c_{\mathrm{rem}, \mathrm{right}}$
        \State $\texttt{left\_old\_fund} \gets 2/\{\pk{\mathrm{rem},
        \mathrm{left}, \mathrm{fund}, \mathrm{old}}, \pk{\mathrm{loc},
        \mathrm{left}, \mathrm{fund}, \mathrm{old}}\}$
        \State $\texttt{right\_old\_fund} \gets 2/\{\pk{\mathrm{loc},
        \mathrm{right}, \mathrm{fund}, \mathrm{old}}, \pk{\mathrm{rem},
        \mathrm{right}, \mathrm{fund}, \mathrm{old}}\}$
        \State $\texttt{left\_new\_fund} \gets 2/\{\pk{\mathrm{rem},
        \mathrm{left}, \mathrm{fund}, \mathrm{new}}, \pk{\mathrm{loc},
        \mathrm{left}, \mathrm{fund}, \mathrm{new}}\} \vee
        2/\{\pk{\mathrm{left}, \mathrm{rev}}, \pk{\mathrm{loc},
        \mathrm{rev}}\}$
        \State $\texttt{right\_new\_fund} \gets 2/\{\pk{\mathrm{loc},
        \mathrm{right}, \mathrm{fund}, \mathrm{new}}, \pk{\mathrm{rem},
        \mathrm{right}, \mathrm{fund}, \mathrm{new}}\} \vee
        2/\{\pk{\mathrm{loc}, \mathrm{rev}}, \pk{\mathrm{right},
        \mathrm{rev}}\}$
        \State $\texttt{virt\_fund} \gets 2/\{\pk{\mathrm{left}, \mathrm{virt}},
        \pk{\mathrm{right}, \mathrm{virt}}\}$
        \State $\texttt{revocation} \gets 4/\{\pk{\mathrm{funder},
        \mathrm{rev}}, \pk{\mathrm{loc}, \mathrm{rev}}, \pk{\mathrm{right},
        \mathrm{rev}}, \pk{\mathrm{fundee}, \mathrm{rev}}\}$
        \State $\texttt{refund} \gets (\pk{\mathrm{loc}, \mathrm{out}} + (p +
        s)) \vee 2/\{\pk{\mathrm{left}, \mathrm{rev}}, \pk{\mathrm{loc},
        \mathrm{rev}}\}$

        \ForAll{$j \in [n-1] \setminus \{1\}, k \in [n-1] \setminus \{1, j\}$}
          \State $\mathit{all}_{j, k} \gets n/\{\pk{1, j, k}, \dots, \pk{n, j,
          k}\} \wedge \texttt{"}k\texttt{"}$
        \EndFor
        \If{$i = 2$}
          \State $\mathit{all}_{2, 1} \gets n/\{\pk{1, 2, 1}, \dots, \pk{n, 2,
          1}\} \wedge \texttt{"1"}$
        \EndIf
        \If{$i = n-1$}
          \State $\mathit{all}_{n-1, n} \gets n/\{\pk{1, n-1, n}, \dots, \pk{n,
          n-1, n}\} \wedge \texttt{"}n\texttt{"}$
        \EndIf

        \IfThenElse{$i = 2$}{$m \gets 1$}{$m \gets 2$}
        \IfThenElse{$i = n-1$}{$l \gets n$}{$l \gets n-1$}
        \State $\texttt{bridge}_1 \gets 4/\{\pk{1, 2, 1}, \pk{i-1, 2, 1},
        \pk{i+1, 2, 1}, \pk{n, 2, 1}\} \wedge \texttt{"1"}$ \Comment{We reuse
        the $\pk{j, 2, 1}$ keys for all \texttt{bridge}s to avoid new keys.
        $\pk{i, 2, 1}$ is not needed because $i$ is not a beneficiary of the
        bridge tx.}
        \State $\texttt{revocation}_1 \gets 4/\{\pk{\mathrm{funder},
        \mathrm{rev}}, \pk{\mathrm{loc}, \mathrm{rev}}, \pk{\mathrm{right},
        \mathrm{rev}}, \pk{\mathrm{fundee}, \mathrm{rev}}\} \wedge \texttt{"1"}$
        \ForAll{$k \in \{m, \dots, l\} \setminus \{i\}$}
          \State $\texttt{bridge}_{2, k} \gets 4/\{\pk{1, 2, 1}, \pk{i-1, 2, 1},
          \pk{i+1, 2, 1}, \pk{n, 2, 1}\} \wedge \texttt{"2,} k \texttt{"}$
          \State $\texttt{revocation}_{2, k} \gets 4/\{\pk{\mathrm{funder},
          \mathrm{rev}}, \pk{\mathrm{loc}, \mathrm{rev}}, \pk{\mathrm{right},
          \mathrm{rev}}, \pk{\mathrm{fundee}, \mathrm{rev}}\} \wedge
          \texttt{"2,} k \texttt{"}$
        \EndFor
        \ForAll{$(k_1, k_2) \in \{m, \dots, i-1\} \times \{i+1, \dots, l\}$}
          \State $\texttt{bridge}_{3, k_1, k_2} \gets 4/\{\pk{1, 2, 1}, \pk{i-1,
          2, 1}, \pk{i+1, 2, 1}, \pk{n, 2, 1}\} \wedge \texttt{"3,} k_1
          \texttt{,} k_2 \texttt{"}$
          \State $\texttt{revocation}_{3, k_1, k_2} \gets
          4/\{\pk{\mathrm{funder}, \mathrm{rev}}, \pk{\mathrm{loc},
          \mathrm{rev}}, \pk{\mathrm{right}, \mathrm{rev}}, \pk{\mathrm{fundee},
          \mathrm{rev}}\} \wedge \texttt{"3,} k_1 \texttt{,} k_2 \texttt{"}$
        \EndFor

        \State \Comment{After funding is complete, $A_j$ has the signature of
        all other parties for all $\mathit{all}_{j, k}$ and \texttt{bridge}
        inputs, but other parties do not have $A_j$'s signature for this input,
        therefore only $A_j$ can publish it.}
        \State \Comment{$\mathrm{TX}_{i, j, k} :=$ $i$-th move, $j, k$ input
        interval start and end. $j, k$ unneeded for $i = 1$, $k$ unneeded for $i
        = 2$.}
        \State $\mathrm{TX}_1 \gets \mathrm{TX}$:
        \Indent
          \State inputs:
          \Indent
            \State ($c_{\mathrm{left}}$, \texttt{left\_old\_fund}),
            \State ($c_{\mathrm{right}}$, \texttt{right\_old\_fund})
          \EndIndent
          \State outputs:
          \Indent
            \State ($c_{\mathrm{left}} - c_{\mathrm{virt}}$,
            \texttt{left\_new\_fund}),
            \label{code:virtual-layer:mid-txs:initiator:left-new-fund}
            \State ($c_{\mathrm{right}} - c_{\mathrm{virt}}$,
            \texttt{right\_new\_fund}),
            \State ($c_{\mathrm{virt}}$, \texttt{refund}),
            \State ($c_{\mathrm{virt}}$,
            \Indent
              \State (if $(i-1 > 1)$ then $\mathit{all}_{i-1, i}$ else False)
              \label{code:virtual-layer:mid-txs:initiator:left-all}
              \State $\vee$ (if $(i+1 < n)$ then $\mathit{all}_{i+1, i}$ else
              False)
              \label{code:virtual-layer:mid-txs:initiator:right-all}
              \State $\vee \texttt{revocation}_1$
              \State $\vee$ (
              \Indent
                \State if $(i-1 = 1 \wedge i+1 = n)$ then $\texttt{bridge}_1$
                \label{code:virtual-layer:mid-txs:initiator:i-is-2:n-is-3}
                \State else if $(i-1 > 1 \wedge i+1 = n)$ then
                $\texttt{bridge}_1 + t_{i-1}$
                \State else if $(i-1 = 1 \wedge i+1 < n)$ then
                $\texttt{bridge}_1 + t_{i+1}$
                \State else \StarComment{$i-1 > 1 \wedge i+1 < n$}
                $\texttt{bridge}_1 + \max{(t_{i-1}, t_{i+1})}$
              \EndIndent
              \State )
            \EndIndent
            \State )
            \label{code:virtual-layer:mid-txs:initiator:virt-out}
          \EndIndent
        \EndIndent

        \State $B_1 \gets \mathrm{TX}$:
        \Indent
          \State input:
          \Indent
            \State ($c_{\mathrm{virt}}$, $\texttt{bridge}_1$)
          \EndIndent
          \State output:
          \Indent
            \State ($c_{\mathrm{virt}}$, \texttt{revocation} $\vee$
            \texttt{virt\_fund})
          \EndIndent
        \EndIndent

        \If{$i = 2$}
          \State $\mathrm{TX}_{2, 1} \gets \mathrm{TX}$:
          \Indent
            \State inputs:
            \Indent
              \State ($c_{\mathrm{virt}}$, $\mathit{all}_{2, 1}$),
              \label{code:virtual-layer:mid-txs:i-is-2:extend-interval-left:virt}
              \State ($c_{\mathrm{right}}$, \texttt{right\_old\_fund})
            \EndIndent
            \State outputs:
            \Indent
              \State ($c_{\mathrm{right}} - c_{\mathrm{virt}}$,
              \texttt{right\_new\_fund}),
              \State ($c_{\mathrm{virt}}$, \texttt{refund}),
              \State ($c_{\mathrm{virt}}$,
              \Indent
                \State (if $(n > 3)$ then ($\mathit{all}_{3, 2} \vee
                \texttt{revocation}_{2, 1} \vee (\texttt{bridge}_{2, 1} + t_3))$
                \State else $\texttt{revocation}_{2, 1} \vee \texttt{bridge}_{2,
                1}$)
              \EndIndent
              \State )
            \EndIndent
          \EndIndent
          \State $B_{2, 1} \gets \mathrm{TX}$:
          \Indent
            \State input:
            \Indent
              \State ($c_{\mathrm{virt}}$, $\texttt{bridge}_{2, 1}$)
            \EndIndent
            \State output:
            \Indent
              \State ($c_{\mathrm{virt}}$, \texttt{revocation}
              $\vee$ \texttt{virt\_fund})
            \EndIndent
          \EndIndent
        \EndIf

        \If{$i = n-1$}
          \State $\mathrm{TX}_{2, n} \gets \mathrm{TX}$:
          \Indent
            \State inputs:
            \Indent
              \State ($c_{\mathrm{left}}$, \texttt{left\_old\_fund}),
              \State ($c_{\mathrm{virt}}$, $\mathit{all}_{n-1, n}$)
            \EndIndent
            \State outputs:
            \Indent
              \State ($c_{\mathrm{left}} - c_{\mathrm{virt}}$,
              \texttt{left\_new\_fund}),
              \State ($c_{\mathrm{virt}}$, \texttt{refund}),
              \State ($c_{\mathrm{virt}}$,
              \Indent
                \State (if $(n-2 > 1)$ then $(\mathit{all}_{n-2, n-1} \vee
                \texttt{revocation}_{2, n} \vee (\texttt{bridge}_{2, n} +
                t_{n-2}))$
                \State else $\texttt{revocation}_{2, n} \vee \texttt{bridge}_{2,
                n}$)
              \EndIndent
              \State )
            \EndIndent
          \EndIndent
          \State $B_{2, n} \gets \mathrm{TX}$:
          \Indent
            \State input:
            \Indent
              \State ($c_{\mathrm{virt}}$, $\texttt{bridge}_{2, n}$)
            \EndIndent
            \State output:
            \Indent
              \State ($c_{\mathrm{virt}}$, \texttt{revocation} $\vee$
              \texttt{virt\_fund})
            \EndIndent
          \EndIndent
        \EndIf

        \ForAll{$k \in \{2, \dots, i-1\}$} \Comment{$2(i-2)$ txs}
          \State $\mathrm{TX}_{2, k} \gets \mathrm{TX}$:
          \Indent
            \State inputs:
            \Indent
              \State ($c_{\mathrm{virt}}$, $\mathit{all}_{i, k}$),
              \label{code:virtual-layer:mid-txs:extend-interval-left:virt}
              \State ($c_{\mathrm{right}}$, \texttt{right\_old\_fund})
            \EndIndent
            \State outputs:
            \Indent
              \State ($c_{\mathrm{right}} - c_{\mathrm{virt}}$,
              \texttt{right\_new\_fund}),
              \State ($c_{\mathrm{virt}}$, \texttt{refund}),
              \State ($c_{\mathrm{virt}}$,
              \Indent
                \State (if $(k-1 > 1)$ then $\mathit{all}_{k-1, i}$ else False)
                \State $\vee$ (if $(i+1 < n)$ then $\mathit{all}_{i+1, k}$ else
                False)
                \State $\vee \texttt{revocation}_{2, k}$
                \State $\vee$ (
                \Indent
                  \State if $(k-1 = 1 \wedge i+1 = n)$ then $\texttt{bridge}_{2,
                  k}$
                  \State else if $(k-1 > 1 \wedge i+1 = n)$ then
                  $\texttt{bridge}_{2, k} + t_{k-1}$
                  \State else if $(k-1 = 1 \wedge i+1 < n)$ then
                  $\texttt{bridge}_{2, k} + t_{i+1}$
                  \State else \StarComment{$k-1 > 1 \wedge i+1 < n$}
                  \Indent
                    \State $\texttt{bridge}_{2, k} + \max{(t_{k-1}, t_{i+1})}$
                  \EndIndent
                \EndIndent
                \State )
              \EndIndent
              \State )
            \EndIndent
          \EndIndent
          \State $B_{2, k} \gets \mathrm{TX}$:
          \Indent
            \State input:
            \Indent
              \State ($c_{\mathrm{virt}}$, $\texttt{bridge}_{2, k}$)
            \EndIndent
            \State output:
            \Indent
              \State ($c_{\mathrm{virt}}$, \texttt{revocation} $\vee$
              \texttt{virt\_fund})
            \EndIndent
          \EndIndent
        \EndFor

        \ForAll{$k \in \{i+1, \dots, n-1\}$} \Comment{$2(n-i-1)$ txs}
          \State $\mathrm{TX}_{2, k} \gets \mathrm{TX}$:
          \Indent
            \State inputs:
            \Indent
              \State ($c_{\mathrm{left}}$, \texttt{left\_old\_fund})
              \State ($c_{\mathrm{virt}}$, $\mathit{all}_{i, k}$),
            \EndIndent
            \State outputs:
            \Indent
              \State ($c_{\mathrm{left}} - c_{\mathrm{virt}}$,
              \texttt{left\_new\_fund}),
              \label{code:virtual-layer:mid-txs:extend-interval-right:new-fund}
              \State ($c_{\mathrm{virt}}$, \texttt{refund}),
              \State ($c_{\mathrm{virt}}$,
              \Indent
                \State (if $(i-1 > 1)$ then $\mathit{all}_{i-1, k}$ else False)
                \State $\vee$ (if $(k+1 < n)$ then $\mathit{all}_{k+1, i}$ else
                False)
                \State $\vee \texttt{revocation}_{2, k}$
                \State $\vee$ (
                \Indent
                  \State if $(i-1 = 1 \wedge k+1 = n)$ then $\texttt{bridge}_{2,
                  k}$
                  \State else if $(i-1 > 1 \wedge k+1 = n)$ then
                  $\texttt{bridge}_{2, k} + t_{i-1}$
                  \State else if $(i-1 = 1 \wedge k+1 < n)$ then
                  $\texttt{bridge}_{2, k} + t_{k+1}$
                  \State else \StarComment{$i-1 > 1 \wedge k+1 < n$}
                  \Indent
                    \State $\texttt{bridge}_{2, k} + \max{(t_{i-1}, t_{k+1})}$
                  \EndIndent
                \EndIndent
                \State )

              \EndIndent
              \State )
            \EndIndent
          \EndIndent
          \State $B_{2, k} \gets \mathrm{TX}$:
          \Indent
            \State input:
            \Indent
              \State ($c_{\mathrm{virt}}$, $\texttt{bridge}_{2, k}$)
            \EndIndent
            \State output:
            \Indent
              \State ($c_{\mathrm{virt}}$, $\vee$ \texttt{revocation} $\vee$
              \texttt{virt\_fund})
            \EndIndent
          \EndIndent
        \EndFor

        \ForAll{$(k_1, k_2) \in \{m, \dots, i-1\} \times \{i+1, \dots, l\}$}
        \Comment{$(i-m) \cdot (l-i)$ txs}
          \State $\mathrm{TX}_{3, k_1, k_2} \gets \mathrm{TX}$:
          \Indent
            \State inputs:
            \Indent
              \State ($c_{\mathrm{virt}}$, $\mathit{all}_{i, k_1}$),
              \label{code:virtual-layer:mid-txs:merge-intervals:left-virt-input}
              \State ($c_{\mathrm{virt}}$, $\mathit{all}_{i, k_2}$)
            \EndIndent
            \State outputs:
            \Indent
              \State ($c_{\mathrm{virt}}$, \texttt{refund}),
              \State ($c_{\mathrm{virt}}$,
              \Indent
                \State (if $(k_1-1 > 1)$ then $\mathit{all}_{k_1-1, \min{(k_2,
                n-1)}}$ else False)
                \State $\vee$ (if $(k_2+1 < n)$ then $\mathit{all}_{k_2+1,
                \max{(k_1, 2)}}$ else False)
                \State $\vee \texttt{revocation}_{3, k_1, k_2}$
                \State $\vee$ (
                \Indent
                  \State if $(k_1-1 \leq 1 \wedge k_2+1 \geq n)$ then
                  $\texttt{bridge}_{3, k_1, k_2}$
                  \State else if $(k_1-1 > 1 \wedge k_2+1 \geq n)$ then
                  $\texttt{bridge}_{3, k_1, k_2} + t_{k_1-1}$
                  \State else if $(k_1-1 \leq 1 \wedge k_2+1 < n)$ then
                  $\texttt{bridge}_{3, k_1, k_2} + t_{k_2+1}$
                  \State else \StarComment{$k_1-1 > 1 \wedge k_2+1 < n$}
                  \Indent
                    \State $\texttt{bridge}_{3, k_1, k_2} + \max{(t_{k_1-1},
                    t_{k_2+1})}$
                  \EndIndent
                \EndIndent
                \State )
              \EndIndent
              \State )
            \EndIndent
          \EndIndent
          \State $B_{3, k_1, k_2} \gets \mathrm{TX}$:
          \Indent
            \State input:
            \Indent
              \State ($c_{\mathrm{virt}}$, $\texttt{bridge}_{3, k_1, k_2}$)
            \EndIndent
            \State output:
            \Indent
              \State ($c_{\mathrm{virt}}$, $\vee$ \texttt{revocation} $\vee$
              \texttt{virt\_fund})
            \EndIndent
          \EndIndent
        \EndFor

        \State \Return (
        \Indent
          \State $\mathrm{TX}_1, B_1$,
          \State $(\mathrm{TX}_{2, k}, B_{2, k})_{k \in \{m, \dots, l\}
          \setminus \{i\}}$,
          \State $(\mathrm{TX}_{3, k_1, k_2}, B_{3, k_1, k_2})_{(k_1, k_2) \in
          \{m, \dots, i-1\} \times \{i+1, \dots, l\}}$
        \EndIndent
        \State )
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:mid-txs}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt}}
    \ \\
    \begin{algorithmic}[1]
      \State \Comment{left and right refer to the two counterparties, with left
      being the one closer to the funder. Note difference with left/right
      meaning in \textsc{virt.getMidTXs}.}
      \State \textsc{getEndpointTX}($i$, $n$, $c_{\mathrm{virt}}$,
      $c_{\mathrm{left}}$, $c_{\mathrm{right}}$, $\pk{\mathrm{left},
      \mathrm{fund}, \mathrm{old}}$, $\pk{\mathrm{right}, \mathrm{fund},
      \mathrm{old}}$, $\pk{\mathrm{left}, \mathrm{fund}, \mathrm{new}}$,
      $\pk{\mathrm{right}, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{left},
      \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$,
      $\pk{\mathrm{interm}, \mathrm{rev}}$, $\pk{\mathrm{endpoint},
      \mathrm{rev}}$, $(\pk{\mathrm{all}, j})_{j \in [n]}$, $t$):
      \Indent
        \State ensure $i \in \{1, n\}$
        \State ensure $c_{\mathrm{left}} \geq c_{\mathrm{virt}}$ \Comment{left
        party funds virtual channel}
        \State $c_{\mathrm{tot}} \gets c_{\mathrm{left}} + c_{\mathrm{right}}$
        \State $\texttt{old\_fund} \gets 2/\{\pk{\mathrm{left}, \mathrm{fund},
        \mathrm{old}}, \pk{\mathrm{right}, \mathrm{fund}, \mathrm{old}}\}$
        \State $\texttt{new\_fund} \gets 2/\{\pk{\mathrm{left}, \mathrm{fund},
        \mathrm{new}}, \pk{\mathrm{right}, \mathrm{fund}, \mathrm{new}}\} \vee
        2/\{\pk{\mathrm{left}, \mathrm{rev}}, \pk{\mathrm{right},
        \mathrm{rev}}\}$
        \State $\texttt{virt\_fund} \gets 2/\{\pk{\mathrm{left},
        \mathrm{virt}}, \pk{\mathrm{right}, \mathrm{virt}}\}$
        \State $\texttt{revocation} \gets \texttt{revocation}_1 \gets
        2/\{\pk{\mathrm{interm}, \mathrm{rev}}, \pk{\mathrm{endpoint},
        \mathrm{rev}}\}$
        \If{$i = 1$} \Comment{funder's tx}
          \State $\mathit{all} \gets n/\{\pk{\mathrm{all}, 1}, \dots,
          \pk{\mathrm{all}, n}\} \wedge \texttt{"1"}$
          \State $\texttt{bridge} \gets 2/\{\pk{\mathit{all}, 2},
          \pk{\mathit{all}, n}\} \wedge \texttt{"1"}$ \Comment{We reuse the
          $\pk{\mathit{all}, j}$ keys to avoid new keys}
        \Else \: \Comment{$i = n$, fundee's tx}
          \State $\mathit{all} \gets n/\{\pk{\mathrm{all}, 1}, \dots,
          \pk{\mathrm{all}, n}\} \wedge \texttt{"}n\texttt{"}$
          \State $\texttt{bridge} \gets 2/\{\pk{\mathit{all}, 1},
          \pk{\mathit{all}, n-1}\} \wedge \texttt{"1"}$
        \EndIf
        \State $\mathrm{TX}_1 \gets \mathrm{TX}$: \Comment{endpoints only have
        an ``initiator'' tx}
        \Indent
          \State input:
          \Indent
            \State $(c_{\mathrm{tot}}, \texttt{old\_fund})$
          \EndIndent
          \State outputs:
          \Indent
            \State $(c_{\mathrm{tot}} - c_{\mathrm{virt}}, \texttt{new\_fund})$,
            \label{code:virtual-layer:endpoint-txs:new-fund}
            \State $(c_{\mathrm{virt}}, \mathit{all} \vee
            \texttt{revocation}_1 \vee (\texttt{bridge} + t))$
            \label{code:virtual-layer:endpoint-txs:virt}
          \EndIndent
        \EndIndent
        \State $B_1 \gets \mathrm{TX}$:
        \Indent
          \State input:
          \Indent
            \State $(c_{\mathrm{virt}}, \texttt{bridge})$
          \EndIndent
          \State output:
          \Indent
            \State $(c_{\mathrm{virt}}, \texttt{revocation} \vee
            \texttt{virt\_fund})$
          \EndIndent
        \EndIndent
        \State \Return $\mathrm{TX}_1$, $B_1$
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:endpoint-txs}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt.siblingSigs}()}
    \ \\
    \begin{algorithmic}[1]
      \State parse input as $\mathrm{sigs}_{\mathrm{byLeft}}$
      \IfThenElse{$i = 2$}{$m \gets 1$}{$m \gets 2$}
      \IfThenElse{$i = n-1$}{$l \gets n$}{$l \gets n-1$}
      \State ($\mathrm{TX}_{i, 1}$, $B_{i, 1}$, $(\mathrm{TX}_{i, 2, k}, B_{i,
      2, k})_{k \in \{m, \dots, l\} \setminus \{i\}}$, $(\mathrm{TX}_{i, 3, k_1,
      k_2}, B_{i, 3, k_1, k_2})_{(k_1, k_2) \in \{m, \dots, i-1\} \times \{i+1,
      \dots, l\}}$) $\gets$
      \textsc{virt.getMidTXs}($i$, $n$, $c_{\mathrm{virt}}$, $c_{i-1,
      \mathrm{right}}$, $c_{i, \mathrm{left}}$, $c_{i, \mathrm{right}}$,
      $c_{i+1, \mathrm{left}}$, $\pk{i-1, \mathrm{right}, \mathrm{fund},
      \mathrm{old}}$, $\pk{i, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
      $\pk{i, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{i+1,
      \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{i-1, \mathrm{fund},
      \mathrm{new}}$, $\pk{i, \mathrm{fund}, \mathrm{new}}$, $\pk{i,
      \mathrm{fund}, \mathrm{new}}$, $\pk{i+1, \mathrm{fund}, \mathrm{new}}$,
      $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$,
      $\pk{i, \mathrm{out}}$, $\pk{1, \mathrm{rev}}$, $\pk{i-1, \mathrm{rev}}$,
      $\pk{i, \mathrm{rev}}$, $\pk{i+1, \mathrm{rev}}$, $\pk{n, \mathrm{rev}}$,
      $(\pk{h,j,k})_{h \in [n], j \in [n-1] \setminus \{1\}, k \in [n-1]
      \setminus \{1, j\}}$, $(\pk{h, 2, 1})_{h \in [n]}$, $(\pk{h, n-1, n})_{h
      \in [n]}$, $(t_h)_{h \in [n-1] \setminus \{1\}}$)
      \Statex
      \State \Comment{notation: $\mathrm{sig}(\mathrm{TX}, \pk{}) :=$ sig with
      \texttt{ANYPREVOUT} flag such that $\textsc{verify}(\mathrm{TX},
      \mathrm{sig}, \pk{}) =$ True}
      \State ensure that the following signatures are present in
      $\mathrm{sigs}_{\mathrm{byLeft}}$ and store them:
      % TODO: I think we never check for sigs from the right. cf. ~~~~ mark
      \begin{itemize}
        \item \Comment{$(l-m) \cdot (i-1)$ signatures}
      \end{itemize}
      \Indent
        \State $\forall k \in \{m, \dots, l\} \setminus \{i\}, \forall j \in
        [i-1]:$
        \Indent
          \State sig($\mathrm{TX}_{i, 2, k}, \pk{j, i, k}$)
        \EndIndent
      \EndIndent
      \begin{itemize}
        \item \Comment{$2 \cdot (i-m) \cdot (l-i) \cdot
        (i-1)$ signatures}
      \end{itemize}
      \Indent
        \State $\forall k_1 \in \{m, \dots, i-1\}, \forall k_2 \in \{i+1, \dots,
        l\}, \forall j \in [i-1]:$
        \Indent
          \State sig($\mathrm{TX}_{i, 3, k_1, k_2}, \pk{j, i, k_1}$),
          sig($\mathrm{TX}_{i, 3, k_1, k_2}, \pk{j, i, k_2}$),
        \EndIndent
      \EndIndent
      \State $\mathrm{sigs}_{\mathrm{toRight}} \gets
      \mathrm{sigs}_{\mathrm{byLeft}}$
      \Statex
      \If{$i+1 = n$} \Comment{next hop is \texttt{host\_fundee}}
        \State $\mathrm{TX}_{n, 1}, B_{n, 1}$ $\gets$
        \textsc{virt.getEndpointTX}($n$,
        $n$, $c_{\mathrm{virt}}$, $c_{n-1, \mathrm{right}}$, $c_{n,
        \mathrm{left}}$, $\pk{n-1, \mathrm{right}, \mathrm{fund},
        \mathrm{old}}$, $\pk{n, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
        $\pk{n-1, \mathrm{fund}, \mathrm{new}}$, $\pk{n, \mathrm{fund},
        \mathrm{new}}$, $\pk{\mathrm{left}, \mathrm{virt}}$,
        $\pk{\mathrm{right}, \mathrm{virt}}$, $\pk{n-1, \mathrm{rev}}$, $\pk{n,
        \mathrm{rev}}$, $(\pk{j, n-1, n})_{j \in [n]}$, $t_{n-1}$)
        \State add \textsc{sign}($B_{n, 1}$, $\sk{i, 2, 1}$,
        \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toRight}}$
      \EndIf
      \ForAll{$j \in \{2, \dots, n-1\} \setminus \{i\}$}
        \IfThenElse{$j = 2$}{$m' \gets 1$}{$m' \gets 2$}
        \IfThenElse{$j = n-1$}{$l' \gets n$}{$l' \gets n-1$}
        \State ($\mathrm{TX}_{j, 1}$, $B_{j, 1}$, $(\mathrm{TX}_{j, 2, k}, B_{j,
        2, k})_{k \in \{m', \dots, l'\} \setminus \{i\}}$, $(\mathrm{TX}_{j, 3,
        k_1, k_2}, B_{j, 3, k_1, k_2})_{(k_1, k_2) \in \{m', \dots, i-1\} \times
        \{i+1, \dots, l'\}}$) $\gets$
        \textsc{getMidTXs}($j$, $n$, $c_{\mathrm{virt}}$, $c_{j-1,
        \mathrm{right}}$, $c_{j, \mathrm{left}}$, $c_{j, \mathrm{right}}$,
        $c_{j+1, \mathrm{left}}$, $\pk{j-1, \mathrm{right}, \mathrm{fund},
        \mathrm{old}}$, $\pk{j, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
        $\pk{j, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{j+1,
        \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{j-1, \mathrm{fund},
        \mathrm{new}}$, $\pk{j, \mathrm{fund}, \mathrm{new}}$, $\pk{j,
        \mathrm{fund}, \mathrm{new}}$, $\pk{j+1, \mathrm{fund}, \mathrm{new}}$,
        $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right},
        \mathrm{virt}}$, $\pk{j, \mathrm{out}}$, $\pk{1, \mathrm{rev}}$,
        $\pk{j-1, \mathrm{rev}}$, $\pk{j, \mathrm{rev}}$, $\pk{j+1,
        \mathrm{rev}}$, $\pk{n, \mathrm{rev}}$, $(\pk{k, p, s})_{k \in [n], p
        \in [n-1] \setminus \{1\}, s \in [n-1] \setminus \{1, p\}}$, $(\pk{k, 2,
        1})_{k \in [n]}$, $(\pk{k, n-1, n})_{k \in [n]}$, $(t_k)_{k \in [n-1]
        \setminus \{1\}}$)
        \If{$j = i - 1$}
          \State ensure that the following signatures are present in
          $\mathrm{sigs}_{\mathrm{byLeft}}$ and store them:
          \begin{itemize}
            \item \Comment{$2$ signatures}
          \end{itemize}
          \Indent
            \State sig($B_{i-1, 1}, \pk{1, 2, 1}$), sig($B_{i-1, 1}, \pk{i-1, 2,
            1}$)
          \EndIndent
          \begin{itemize}
            \item \Comment{$2(l'-m')$ signatures}
          \end{itemize}
          \Indent
            \State $\forall k \in \{m', \dots, l'\} \setminus \{i\}:$
            \Indent
              \State sig($B_{i-1, 2, k}, \pk{1, 2, 1}$), sig($B_{i-1, 2, k},
              \pk{i-1, 2, 1}$)
            \EndIndent
          \EndIndent
          \begin{itemize}
            \item \Comment{$2(i-m') \cdot (l'-i)$ signatures}
          \end{itemize}
          \Indent
            \State $\forall k_1 \in \{m', \dots, i-1\}, \forall k_2 \in \{i+1,
            \dots, l'\}:$
            \Indent
              \State sig($B_{i-1, 3, k_1, k_2}, \pk{1, 2, 1}$), sig($B_{i-1, 3,
              k_1, k_2}, \pk{i-1, 2, 1}$)
            \EndIndent
          \EndIndent
        \EndIf
        \IfThenElse{$j < i$}{$\mathrm{sigs} \gets
        \mathrm{sigs}_{\mathrm{toLeft}}$}{$\mathrm{sigs} \gets
        \mathrm{sigs}_{\mathrm{toRight}}$}
        \If{$j \in \{i-1, i+1\}$}
          \State add \textsc{sign}($B_{j, 1}$, $\sk{i, 2, 1}$,
          \texttt{ANYPREVOUT}) to sigs
        \EndIf
        \ForAll{$k \in \{m', \dots, l'\} \setminus \{j\}$}
          \State add \textsc{sign}($\mathrm{TX}_{j, 2, k}$, $\sk{i, j, k}$,
          \texttt{ANYPREVOUT}) to sigs
          \If{$j \in \{i-1, i+1\}$}
            \State add \textsc{sign}($B_{j, 2, k}$, $\sk{i, 2, 1}$,
            \texttt{ANYPREVOUT}) to sigs
          \EndIf
        \EndFor
        \ForAll{$k_1 \in \{m', \dots, j-1\}, k_2 \in \{j+1, \dots, l'\}$}
          \State add \textsc{sign}($\mathrm{TX}_{j, 3, k_1, k_2}$, $\sk{i, j,
          k_1}$, \texttt{ANYPREVOUT}) to sigs
          \State add \textsc{sign}($\mathrm{TX}_{j, 3, k_1, k_2}$, $\sk{i, j,
          k_2}$, \texttt{ANYPREVOUT}) to sigs
          \If{$j \in \{i-1, i+1\}$}
            \State add \textsc{sign}($B_{j, 3, k_1, k_2}$, $\sk{i, 2, 1}$,
            \texttt{ANYPREVOUT}) to sigs
          \EndIf
        \EndFor
      \EndFor
      \Statex
      \State call
      $\bar{P}$.\textsc{circulateVirtualSigs}($\mathrm{sigs}_{\mathrm{toRight}}$)
      and assign returned value to $\mathrm{sigs}_{\mathrm{byRight}}$
      % TODO: ~~~~ maybe we have to check for sigs byRight here
      \State output (\textsc{virtualSigsBack},
      $\mathrm{sigs}_{\mathrm{toLeft}}$, $\mathrm{sigs}_{\mathrm{byRight}}$)
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:sibling-sigs}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt.intermediarySigs}()}
    \ \\
    \begin{algorithmic}[1]
      \IfThenElse{$i = 2$}{$m \gets 1$}{$m \gets 2$}
      \IfThenElse{$i = n-1$}{$l \gets n$}{$l \gets n-1$}
      \State ($\mathrm{TX}_{i, 1}$, $B_{i, 1}$, $(\mathrm{TX}_{i, 2, k}, B_{i,
      2, k})_{k \in \{m, \dots, l\} \setminus \{i\}}$, $(\mathrm{TX}_{i, 3, k_1,
      k_2}, B_{i, 3, k_1, k_2})_{(k_1, k_2) \in \{m, \dots, i-1\} \times \{i+1,
      \dots, l\}}$) $\gets$
      \textsc{virt.getMidTXs}($i$, $n$, $c_{\mathrm{virt}}$, $c_{i-1,
      \mathrm{right}}$, $c_{i, \mathrm{left}}$, $c_{i, \mathrm{right}}$,
      $c_{i+1, \mathrm{left}}$, $\pk{i-1, \mathrm{right}, \mathrm{fund},
      \mathrm{old}}$, $\pk{i, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
      $\pk{i, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{i+1,
      \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{i-1, \mathrm{fund},
      \mathrm{new}}$, $\pk{i, \mathrm{fund}, \mathrm{new}}$, $\pk{i,
      \mathrm{fund}, \mathrm{new}}$, $\pk{i+1, \mathrm{fund}, \mathrm{new}}$,
      $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$,
      $\pk{i, \mathrm{out}}$, $\pk{1, \mathrm{rev}}$, $\pk{j-1, \mathrm{rev}}$,
      $\pk{j, \mathrm{rev}}$, $\pk{j+1, \mathrm{rev}}$, $\pk{n, \mathrm{rev}}$,
      $(\pk{h,j,k})_{h \in [n], j \in [n-1] \setminus \{1\}, k \in [n-1]
      \setminus \{1, j\}}$, $(\pk{h, 2, 1})_{h \in [n]}$, $(\pk{h, n-1, n})_{h
      \in [n]}$, $(t_h)_{h \in [n-1] \setminus \{1\}}$)
      \State \Comment{not verifying our signatures in
      $\mathrm{sigs}_{\mathrm{byLeft}}$, our (trusted) \texttt{sibling} will do
      that}
      \State input (\textsc{virtual sigs forward},
      $\mathrm{sigs}_{\mathrm{byLeft}}$) to \texttt{sibling}
      \State \trustedcode{\textsc{virt.siblingSigs}()}
      \State $\mathrm{sigs}_{\mathrm{toLeft}} \gets
      \mathrm{sigs}_{\mathrm{byRight}} + \mathrm{sigs}_{\mathrm{toLeft}}$
      \If{$i = 2$} \Comment{previous hop is \texttt{host\_funder}}
        \State $\mathrm{TX}_{1, 1}, B_{1, 1}$ $\gets$
        \textsc{virt.getEndpointTX}($1$,
        $n$, $c_{\mathrm{virt}}$, $c_{1, \mathrm{right}}$, $c_{2,
        \mathrm{left}}$, $\pk{1, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$,
        $\pk{2, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{1,
        \mathrm{fund}, \mathrm{new}}$, $\pk{2, \mathrm{fund}, \mathrm{new}}$,
        $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right},
        \mathrm{virt}}$, $\pk{2, \mathrm{rev}}$, $\pk{1, \mathrm{rev}}$,
        $(\pk{j, 2, 1})_{j \in [n]}$, $t_2$)
        \State add \textsc{sign}($B_{1, 1}$, $\sk{i, 2, 1}$,
        \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toLeft}}$
      \EndIf
      \State \Return $\mathrm{sigs}_{\mathrm{toLeft}}$
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:intermediary-sigs}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt.hostFundeeSigs}()}
    \ \\
    \begin{algorithmic}[1]
      \State $\mathrm{TX}_{n, 1}, B_{n, 1} \gets$
      \textsc{virt}.\textsc{getEndpointTX}($n$, $n$, $c_{\mathrm{virt}}$,
      $c_{n-1, \mathrm{right}}$, $c_{n, \mathrm{left}}$, $\pk{n-1,
      \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{n, \mathrm{right},
      \mathrm{fund}, \mathrm{old}}$, $\pk{n-1, \mathrm{fund}, \mathrm{new}}$,
      $\pk{n, \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{left},
      \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$, $\pk{n-1,
      \mathrm{rev}}$, $\pk{n, \mathrm{rev}}$, $(\pk{j, n-1, n})_{j \in [n]}$,
      $t_{n-1}$)
      \label{code:virtual-layer:fundee-sigs:tx}
      \State ensure that sig($B_{n, 1}, \pk{1, 2, 1}$), sig($B_{n, 1}, \pk{n-1,
      2, 1}$) are present in $\mathrm{sigs}_{\mathrm{byLeft}}$ and store them
      \State $\mathrm{sigs}_{\mathrm{toLeft}} \gets \emptyset$
      \ForAll{$j \in [n-1] \setminus \{1\}$}
        \IfThenElse{$j = 2$}{$m \gets 1$}{$m \gets 2$}
        \IfThenElse{$j = n-1$}{$l \gets n$}{$l \gets n-1$}
        \State ($\mathrm{TX}_{j, 1}$, $B_{j, 1}$, $(\mathrm{TX}_{j, 2, k}, B_{j,
        2, k})_{k \in \{m, \dots, l\} \setminus \{j\}}$, $(\mathrm{TX}_{j, 3,
        k_1, k_2}, B_{j, 3, k_1, k_2})_{(k_1, k_2) \in \{m, \dots, j-1\} \times
        \{j+1, \dots, l\}}$) $\gets$
        \textsc{virt.getMidTXs}($j$, $n$, $c_{\mathrm{virt}}$, $c_{j-1,
        \mathrm{right}}$, $c_{j, \mathrm{left}}$, $c_{j, \mathrm{right}}$,
        $c_{j+1, \mathrm{left}}$, $\pk{j-1, \mathrm{right}, \mathrm{fund},
        \mathrm{old}}$, $\pk{j, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
        $\pk{j, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{j+1,
        \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{j-1, \mathrm{fund},
        \mathrm{new}}$, $\pk{j, \mathrm{fund}, \mathrm{new}}$, $\pk{j,
        \mathrm{fund}, \mathrm{new}}$, $\pk{j+1, \mathrm{fund}, \mathrm{new}}$,
        $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right},
        \mathrm{virt}}$, $\pk{j, \mathrm{out}}$, $\pk{1, \mathrm{rev}}$,
        $\pk{j-1, \mathrm{rev}}$, $\pk{j, \mathrm{rev}}$, $\pk{j+1,
        \mathrm{rev}}$, $\pk{n, \mathrm{rev}}$, $(\pk{h,s,k})_{h \in [n], s \in
        [n-1] \setminus \{1\}, k \in [n-1] \setminus \{1, s\}}$, $(\pk{h, 2,
        1})_{h \in [n]}$, $(\pk{h, n-1, n})_{h \in [n]}$, $(t_h)_{h \in [n-1]
        \setminus \{1\}}$)
        \ForAll{$k \in \{m, \dots, l\} \setminus \{j\}$}
          \State ensure that sig($B_{j, 2, k}, \pk{1, 2, 1}$), sig($B_{j, 2, k},
          \pk{n-1, 2, 1}$) are present in $\mathrm{sigs}_{\mathrm{byLeft}}$ and
          store them
          \State add \textsc{sign}($\mathrm{TX}_{j, 2, k}$, $\sk{n, j, k}$,
          \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toLeft}}$
          \State add \textsc{sign}($B_{j, 2, k}$, $\sk{n, 2, 1}$,
          \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toLeft}}$
        \EndFor
        \ForAll{$k_1 \in \{m, \dots, j-1\}, k_2 \in \{j+1, \dots, l\}$}
          \State ensure that sig($B_{j, 3, k_1, k_2}, \pk{1, 2, 1}$), sig($B_{j,
          3, k_1, k_2}, \pk{n-1, 2, 1}$) are present in
          $\mathrm{sigs}_{\mathrm{byLeft}}$ and store them
          \State add \textsc{sign}($\mathrm{TX}_{j, 3, k_1, k_2}$, $\sk{n, j,
          k_1}$, \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toLeft}}$
          \State add \textsc{sign}($\mathrm{TX}_{j, 3, k_1, k_2}$, $\sk{n, j,
          k_2}$, \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toLeft}}$
          \State add \textsc{sign}($B_{j, 3, k_1, k_2}$, $\sk{n, 2, 1}$,
          \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toLeft}}$
        \EndFor
      \EndFor
      \State \Return $\mathrm{sigs}_{\mathrm{toLeft}}$
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:fundee-sigs}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt.hostFunderSigs}()}
    \ \\
    \begin{algorithmic}[1]
      \State $\mathrm{sigs}_{\mathrm{toRight}} \gets \emptyset$
      \ForAll{$j \in [n-1] \setminus \{1\}$}
        \IfThenElse{$j = 2$}{$m \gets 1$}{$m \gets 2$}
        \IfThenElse{$j = n-1$}{$l \gets n$}{$l \gets n-1$}
        \State ($\mathrm{TX}_{j, 1}$, $B_{j, 1}$, $(\mathrm{TX}_{j, 2, k}, B_{j,
        2, k})_{k \in \{m, \dots, l\} \setminus \{j\}}$, $(\mathrm{TX}_{j, 3,
        k_1, k_2}, B_{j, 3, k_1, k_2})_{(k_1, k_2) \in \{m, \dots, j-1\} \times
        \{j+1, \dots, l\}}$) $\gets$
        \textsc{virt.getMidTXs}($j$, $n$, $c_{\mathrm{virt}}$, $c_{j-1,
        \mathrm{right}}$, $c_{j, \mathrm{left}}$, $c_{j, \mathrm{right}}$,
        $c_{j+1, \mathrm{left}}$, $\pk{j-1, \mathrm{right}, \mathrm{fund},
        \mathrm{old}}$, $\pk{j, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
        $\pk{j, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, $\pk{j+1,
        \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, $\pk{j-1, \mathrm{fund},
        \mathrm{new}}$, $\pk{j, \mathrm{fund}, \mathrm{new}}$, $\pk{j,
        \mathrm{fund}, \mathrm{new}}$, $\pk{j+1, \mathrm{fund}, \mathrm{new}}$,
        $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{right},
        \mathrm{virt}}$, $\pk{j, \mathrm{out}}$, $\pk{1, \mathrm{rev}}$,
        $\pk{j-1, \mathrm{rev}}$, $\pk{j, \mathrm{rev}}$, $\pk{j+1,
        \mathrm{rev}}$, $\pk{n, \mathrm{rev}}$, $(\pk{h,s,k})_{h \in [n], s \in
        [n-1] \setminus \{1\}, k \in [n-1] \setminus \{1, s\}}$, $(\pk{h, 2,
        1})_{h \in [n]}$, $(\pk{h, n-1, n})_{h \in [n]}$, $(t_h)_{h \in [n-1]
        \setminus \{1\}}$)
        \ForAll{$k \in \{m, \dots, l\} \setminus \{j\}$}
          \State add \textsc{sign}($\mathrm{TX}_{j, 2, k}$, $\sk{1, j, k}$,
          \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toRight}}$
          \State add \textsc{sign}($B_{j, 2, k}$, $\sk{1, 2, 1}$,
          \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toRight}}$
        \EndFor
        \ForAll{$k_1 \in \{m, \dots, j-1\}, k_2 \in \{j+1, \dots, l\}$}
          \State add \textsc{sign}($\mathrm{TX}_{j, 3, k_1, k_2}$, $\sk{1, j,
          k_1}$, \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toRight}}$
          \State add \textsc{sign}($\mathrm{TX}_{j, 3, k_1, k_2}$, $\sk{1, j,
          k_2}$, \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toRight}}$
          \State add \textsc{sign}($B_{j, 3, k_1, k_2}$, $\sk{1, 2, 1}$,
          \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toRight}}$
        \EndFor
      \EndFor
      \State call
      \textsc{virt.circulateVirtualSigs}($\mathrm{sigs}_{\mathrm{toRight}}$)
      of $\bar{P}$ and assign output to $\mathrm{sigs}_{\mathrm{byRight}}$
      \State $\mathrm{TX}_{1, 1}, B_{1, 1} \gets$
      \textsc{virt}.\textsc{getEndpointTX}($1$, $n$, $c_{\mathrm{virt}}$, $c_{1,
      \mathrm{right}}$, $c_{2, \mathrm{left}}$, $\pk{1, \mathrm{right},
      \mathrm{fund}, \mathrm{old}}$, $\pk{2, \mathrm{left}, \mathrm{fund},
      \mathrm{old}}$, $\pk{1, \mathrm{fund}, \mathrm{new}}$, $\pk{2,
      \mathrm{fund}, \mathrm{new}}$, $\pk{\mathrm{left}, \mathrm{virt}}$,
      $\pk{\mathrm{right}, \mathrm{virt}}$, $\pk{2, \mathrm{rev}}$, $\pk{1,
      \mathrm{rev}}$, $(\pk{j, 2, 1})_{j \in [n]}$, $t_2$)
      \label{code:virtual-layer:fundee-sigs:tx}
      \label{code:virtual-layer:funder-sigs:tx-none}
      \State ensure that sig($B_{1, 1}, \pk{2, 2, 1}$), sig($B_{1, 1}, \pk{n, 2,
      1}$) are present in $\mathrm{sigs}_{\mathrm{byRight}}$ and store them
      \label{code:virtual-layer:funder-sigs:verify-bridge}
      \ForAll{$j \in [n-1] \setminus \{1\}$}
        \IfThenElse{$j = 2$}{$m \gets 1$}{$m \gets 2$}
        \IfThenElse{$j = n-1$}{$l \gets n$}{$l \gets n-1$}
        \ForAll{$k \in \{m, \dots, l\} \setminus \{j\}$}
          \State ensure that sig($B_{j, 2, k}, \pk{2, 2, 1}$), sig($B_{j, 2, k},
          \pk{n, 2, 1}$) are present in $\mathrm{sigs}_{\mathrm{byRight}}$ and
          store them
        \EndFor
        \ForAll{$k_1 \in \{m, \dots, j-1\}, k_2 \in \{j+1, \dots, l\}$}
          \State ensure that sig($B_{j, 3, k_1, k_2}, \pk{2, 2, 1}$), sig($B_{j,
          3, k_1, k_2}, \pk{n, 2, 1}$) are present in
          $\mathrm{sigs}_{\mathrm{byRight}}$ and store them
        \EndFor
      \EndFor
      \State \Return (\textsc{ok})
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:funder-sigs}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt.circulateVirtualSigs}($\mathrm{sigs}_{\mathrm{byLeft}}$)}
    \ \\
    \begin{algorithmic}[1]
      \If{$1 < i < n$} \Comment{we are not \texttt{host\_funder} nor
      \texttt{host\_fundee}}
        \State \Return \textsc{virt.intermediarySigs}()
      \ElsIf{$i = 1$} \Comment{we are \texttt{host\_funder}}
        \State \Return \textsc{virt.hostFunderSigs}()
      \ElsIf{$i = n$} \Comment{we are \texttt{host\_fundee}}
        \State \Return \textsc{virt.hostFundeeSigs}()
      \EndIf \: \Comment{it is always $1 \leq i \leq n$ -- cf.
      Fig.~\ref{code:virtual-layer:keys},
      l.~\ref{code:virtual-layer:keys:init:check-i} and
      l.~\ref{code:virtual-layer:keys:host-me:set-i}}
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:virtual-sigs}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt.circulateFundingSigs}($\mathrm{sigs}_{\mathrm{byLeft}}$)}
    \ \\
    \begin{algorithmic}[1]
      \If{$1 < i < n$} \Comment{we are not endpoint}
        \IfThenElse{$i = 2$}{$m \gets 1$}{$m \gets 2$}
        \IfThenElse{$i = n-1$}{$l \gets n$}{$l \gets n-1$}
        \State ensure that the following signatures are present in
        $\mathrm{sigs}_{\mathrm{byLeft}}$ and store them:
        \begin{itemize}
          \item \Comment{1 signature}
        \end{itemize}
        \Indent
          \State sig($\mathrm{TX}_{i, 1}, \pk{i-1, \mathrm{right},
          \mathrm{fund}, \mathrm{old}}$)
        \EndIndent
        \begin{itemize}
          \item \Comment{$n-3 + \chi_{i=2} + \chi_{i=n-1}$ signatures}
        \end{itemize}
        \Indent
          \State $\forall k \in \{m, \dots, l\} \setminus \{i\}$
          \Indent
            \State sig($\mathrm{TX}_{i, 2, k}, \pk{i-1, \mathrm{right},
            \mathrm{fund}, \mathrm{old}}$)
          \EndIndent
        \EndIndent
        \State input (\textsc{virtual base sig forward},
        $\mathrm{sigs}_{\mathrm{byLeft}}$) to \texttt{sibling}
        \State \trustedcode{extract and store sig($\mathrm{TX}_{i, 1}, \pk{i-1,
        \mathrm{right}, \mathrm{fund}, \mathrm{old}}$) and $\forall k \in \{m,
        \dots, l\} \setminus \{i\}$ sig($\mathrm{TX}_{i, 2, k}, \pk{i-1,
        \mathrm{right}, \mathrm{fund}, \mathrm{old}}$) from
        $\mathrm{sigs}_{\mathrm{byLeft}}$} \Comment{same signatures as
        \texttt{sibling}}
        \State \trustedcode{$\mathrm{sigs}_{\mathrm{toRight}} \gets
        \{\textsc{sign}(\mathrm{TX}_{i+1, 1}, \sk{i, \mathrm{right},
        \mathrm{fund}, \mathrm{old}}, \texttt{ANYPREVOUT})\}$}
        \If{\trustedcode{$i+1 < n$}}
          \IfThenElse{\trustedcode{$i+1 = n-1$}}{\trustedcode{$l' \gets
          n$}}{\trustedcode{$l' \gets n-1$}}
          \ForAll{\trustedcode{$k \in \{2, \dots, l'\}$}}
            \State \trustedcode{add \textsc{sign}($\mathrm{TX}_{i+1, 2, k}$,
            $\sk{i, \mathrm{right}, \mathrm{fund}, \mathrm{old}}$,
            \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toRight}}$}
          \EndFor
        \Else \: \trustedcode{\Comment{$i + 1 = n$}}
          \State \trustedcode{add \textsc{sign}($\mathrm{TX}_{n, 1}$, $\sk{i,
          \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, \texttt{ANYPREVOUT}) to
          $\mathrm{sigs}_{\mathrm{toRight}}$}
        \EndIf
        \State \trustedcode{call
        \textsc{virt.circulateFundingSigs}($\mathrm{sigs}_{\mathrm{toRight}}$)
        of $\bar{P}$ and assign returned values to
        $\mathrm{sigs}_{\mathrm{byRight}}$}
        \State \trustedcode{ensure that the following signatures are present in
        $\mathrm{sigs}_{\mathrm{byRight}}$ and store them:}
        \begin{itemize}
          \item \Comment{1 signature}
        \end{itemize}
        \Indent
          \State \trustedcode{sig($\mathrm{TX}_{i, 1}, \pk{i+1, \mathrm{left},
          \mathrm{fund}, \mathrm{old}}$)}
        \EndIndent
        \begin{itemize}
          \item \Comment{$n-3 + \chi_{i=2} + \chi_{i=n-1}$ signatures}
        \end{itemize}
        \Indent
          \State \trustedcode{$\forall k \in \{m, \dots, l\} \setminus \{i\}$}
          \Indent
            \State \trustedcode{sig($\mathrm{TX}_{i, 2, k}, \pk{i+1,
            \mathrm{right}, \mathrm{fund}, \mathrm{old}}$)}
          \EndIndent
        \EndIndent
        \State \trustedcode{output (\textsc{virtual base sig back},
        $\mathrm{sigs}_{\mathrm{byRight}}$)}
        \State extract and store sig($\mathrm{TX}_{i, 1}, \pk{i+1,
        \mathrm{right}, \mathrm{fund}, \mathrm{old}}$) and $\forall k \in \{m,
        \dots, l\} \setminus \{i\}$ sig($\mathrm{TX}_{i, 2, k}, \pk{i+1,
        \mathrm{right}, \mathrm{fund}, \mathrm{old}}$) from
        $\mathrm{sigs}_{\mathrm{byRight}}$ \Comment{same signatures as
        \texttt{sibling}}
        \State $\mathrm{sig}_{\mathrm{toLeft}} \gets
        \{\textsc{sign}(\mathrm{TX}_{i-1, 1}, \sk{i, \mathrm{left},
        \mathrm{fund}, \mathrm{old}}, \texttt{ANYPREVOUT})\}$
        \If{$i-1 > 1$}
          \IfThenElse{$i-1 = 2$}{$m' \gets
          1$}{$m' \gets 2$}
          \ForAll{$k \in \{m', \dots, n-1\}$}
            \State add \textsc{sign}($\mathrm{TX}_{i-1, 2, k}$,
            $\sk{i, \mathrm{left}, \mathrm{fund}, \mathrm{old}}$,
            \texttt{ANYPREVOUT}) to $\mathrm{sigs}_{\mathrm{toLeft}}$
          \EndFor
        \Else \: \Comment{$i - 1 = 1$}
          \State add \textsc{sign}($\mathrm{TX}_{1, 1}$, $\sk{i, \mathrm{left},
          \mathrm{fund}, \mathrm{old}}$, \texttt{ANYPREVOUT}) to
          $\mathrm{sigs}_{\mathrm{toLeft}}$
        \EndIf
        \State \Return $\mathrm{sigs}_{\mathrm{toLeft}}$
      \ElsIf{$i = 1$} \Comment{we are \texttt{host\_funder}}
        \State $\mathrm{sigs}_{\mathrm{toRight}} \gets
        \{\textsc{sign}(\mathrm{TX}_{2, 1}, \sk{1, \mathrm{right},
        \mathrm{fund}, \mathrm{old}}, \texttt{ANYPREVOUT})\}$
        \label{code:virtual-layer:funding-sigs:funder-sign-first}
        \IfThenElse{$2 = n-1$}{$l' \gets n$}{$l' \gets n-1$}
        \ForAll{$k \in \{3, \dots, l'\}$}
          \State add \textsc{sign}($\mathrm{TX}_{2, 2, k}$, $\sk{1,
          \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, \texttt{ANYPREVOUT})
          to $\mathrm{sigs}_{\mathrm{toRight}}$
        \EndFor
        \label{code:virtual-layer:funding-sigs:funder-sign-second-end}
        \State call
        \textsc{virt.circulateFundingSigs}($\mathrm{sigs}_{\mathrm{toRight}}$)
        of $\bar{P}$ and assign returned value to
        $\mathrm{sigs}_{\mathrm{byRight}}$
        \State ensure that sig($\mathrm{TX}_{1, 1}$, $\pk{2, \mathrm{left},
        \mathrm{fund}, \mathrm{old}}$) is present in
        $\mathrm{sigs}_{\mathrm{byRight}}$ and store it
        \label{code:virtual-layer:funding-sigs:funder-check-sig}
        \State \Return (\textsc{ok})
      \ElsIf{$i = n$} \Comment{we are \texttt{host\_fundee}}
        \State ensure sig($\mathrm{TX}_{n, 1}$, $\pk{n-1, \mathrm{right},
        \mathrm{fund}, \mathrm{old}}$) is present in
        $\mathrm{sigs}_{\mathrm{byLeft}}$ and store it
        \State $\mathrm{sigs}_{\mathrm{toLeft}} \gets
        \{\textsc{sign}(\mathrm{TX}_{n-1, 1}, \sk{n, \mathrm{left},
        \mathrm{fund}, \mathrm{old}}, \texttt{ANYPREVOUT})\}$
        \IfThenElse{$n-1 = 2$}{$m' \gets 1$}{$m' \gets 2$}
        \ForAll{$k \in \{m', \dots, n-2\}$}
          \State add \textsc{sign}($\mathrm{TX}_{n-1, 2, k}$, $\sk{n,
          \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, \texttt{ANYPREVOUT}) to
          $\mathrm{sigs}_{\mathrm{toLeft}}$
        \EndFor
        \State \Return $\mathrm{sigs}_{\mathrm{toLeft}}$
      \EndIf \: \Comment{it is always $1 \leq i \leq n$ -- cf.
      Fig.~\ref{code:virtual-layer:keys},
      l.~\ref{code:virtual-layer:keys:init:check-i} and
      l.~\ref{code:virtual-layer:keys:host-me:set-i}}
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:funding-sigs}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt.circulateRevocations}(\texttt{revoc\_by\_prev})}
    \ \\
    \begin{algorithmic}[1]
      \If{\texttt{revoc\_by\_prev} is given as argument} \Comment{we are not
      \texttt{host\_funder}}
        \State ensure
        \texttt{guest}.\textsc{processRemoteRevocation}(\texttt{revoc\_by\_prev})
        returns (\textsc{ok})
        \label{code:virtual-layer:revocation:non-funder:proc-remote}
      \Else \: \Comment{we are \texttt{host\_funder}}
        \State $\texttt{revoc\_for\_next} \gets
        \texttt{guest}.\textsc{revokePrevious}()$
        \State input (\textsc{read}) to \ledger and assign ouput to $\Sigma$
        \State $\texttt{last\_poll} \gets |\Sigma|$
        \State call
        \textsc{virt.circulateRevocations}(\texttt{revoc\_for\_next}) of
        $\bar{P}$ and assign returned value to \texttt{revoc\_by\_next}
        \label{code:virtual-layer:revocation:revoc-by-next}
        \State ensure
        \texttt{guest}.\textsc{processRemoteRevocation}(\texttt{revoc\_by\_next})
        returns (\textsc{ok}) \Comment{If the ``ensure'' fails, the opening
        process freezes, this is intentional. The channel can still close via
        (\textsc{forceClose})}
        \label{code:virtual-layer:revocation:funder:proc-remote}
        \State \Return (\textsc{ok})
      \EndIf
      \If{we have a \texttt{sibling}} \Comment{we are not \texttt{host\_fundee}
      nor \texttt{host\_funder}}
        \State input (\textsc{virtual revocation forward}) to \texttt{sibling}
        \State \trustedcode{$\texttt{revoc\_for\_next} \gets
        \texttt{guest}.\textsc{revokePrevious}()$}
        \State \trustedcode{input (\textsc{read}) to \ledger and assign ouput to
        $\Sigma$}
        \State \trustedcode{$\texttt{last\_poll} \gets |\Sigma|$}
        \State \trustedcode{call
        \textsc{virt.circulateRevocations}(\texttt{revoc\_for\_next}) of
        $\bar{P}$ and assign output to \texttt{revoc\_by\_next}}
        \State \trustedcode{ensure
        \texttt{guest}.\textsc{processRemoteRevocation}(\texttt{revoc\_by\_next})
        returns (\textsc{ok})}
        \State \trustedcode{output (\textsc{hosts ready}, $t_i$) to
        \texttt{guest} and expect reply (\textsc{host ack})}
        \State \trustedcode{output (\textsc{virtual revocation back})}
      \EndIf
      \State $\texttt{revoc\_for\_prev} \gets
      \texttt{guest}.\textsc{revokePrevious}()$
      \If{$1 < i < n$} \Comment{we are intermediary}
        \State output (\textsc{hosts ready}, $t_i$) to \texttt{guest} and expect
        reply (\textsc{host ack})
        \Comment{$p$ is every how many blocks we have to check the chain}
        \label{code:virtual-layer:revocation:hosts-ready}
      \Else \: \Comment{we are \texttt{host\_fundee}, case of
      \texttt{host\_funder} covered earlier}
        \State output (\textsc{hosts ready}, $p + \sum\limits_{j = 2}^{n-1}(s -
        1 + t_j)$) to \texttt{guest} and expect reply (\textsc{host ack})
      \EndIf
      \State \Return \texttt{revoc\_for\_prev}
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:revocation}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt} -- poll}
    \ \\
    \begin{algorithmic}[1]
      \State On input (\textsc{check for lateral close}) by $R \in$
      \{\texttt{guest}, \texttt{funder}, \texttt{fundee}\}:
      \Indent
        \State input (\textsc{read}) to \ledger and assign output to $\Sigma$
        \State $k_1 \gets 0$
        \If{$\mathrm{TX}_{i-1, 1}$ is defined and $\mathrm{TX}_{i-1, 1} \in
        \Sigma$}
          \State $k_1 \gets i-1$
        \EndIf
        \ForAll{$k \in [i-2]$}
          \If{$\mathrm{TX}_{i-1, 2, k}$ is defined and $\mathrm{TX}_{i-1, 2, k}
          \in \Sigma$}
            \State $k_1 \gets k$
          \EndIf
        \EndFor
        \State $k_2 \gets 0$
        \If{$\mathrm{TX}_{i+1, 1}$ is defined and $\mathrm{TX}_{i+1, 1} \in
        \Sigma$}
          \State $k_2 \gets i+1$
        \EndIf
        \ForAll{$k \in \{i+2, \dots, n\}$}
          \If{$\mathrm{TX}_{i+1, 2, k}$ is defined and $\mathrm{TX}_{i+1, 2, k}
          \in \Sigma$}
            \State $k_2 \gets k$
          \EndIf
        \EndFor
        \State $\texttt{last\_poll} \gets |\Sigma|$
        \If{$k_1 > 0 \vee k_2 > 0$} \Comment{at least one neighbour has
        published its TX}
          \State ignore all messages except for (\textsc{check if closing}) by
          $R$
          \State $\textit{State} \gets \textsc{closing}$
          \State $\mathrm{sigs} \gets \emptyset$
        \EndIf
        \If{$k_1 > 0 \wedge k_2 > 0$} \Comment{both neighbours have published
        their TXs}
          \State add $(\mathrm{sig}(\mathrm{TX}_{i, 3, k_1, k_2}, \pk{p, i,
          k_1}))_{p \in [n] \setminus \{i\}}$ to sigs
          \State add $(\mathrm{sig}(\mathrm{TX}_{i, 3, k_1, k_2}, \pk{p, i,
          k_2}))_{p \in [n] \setminus \{i\}}$ to sigs
          \State add \textsc{sign}($\mathrm{TX}_{i, 3, k_1, k_2}$, $\sk{i, i,
          k_1}$, \texttt{ANYPREVOUT}) to sigs
          \State add \textsc{sign}($\mathrm{TX}_{i, 3, k_1, k_2}$, $\sk{i, i,
          k_2}$, \texttt{ANYPREVOUT}) to sigs
          \State input (\textsc{submit}, $\mathrm{TX}_{i, 3, k_1, k_2}$, sigs)
          to \ledger
        \ElsIf{$k_1 > 0$} \Comment{only left neighbour has published its TX}
          \State add $(\mathrm{sig}(\mathrm{TX}_{i, 2, k_1}, \pk{p, i, k_1}))_{p
          \in [n] \setminus \{i\}}$ to sigs
          \State add \textsc{sign}($\mathrm{TX}_{i, 2, k_1}$, $\sk{i, i, k_1}$,
          \texttt{ANYPREVOUT}) to sigs
          \State add \textsc{sign}($\mathrm{TX}_{i, 2, k_1}$, $\sk{i,
          \mathrm{left}, \mathrm{fund}, \mathrm{old}}$, \texttt{ANYPREVOUT}) to
          sigs
          \State input (\textsc{submit}, $\mathrm{TX}_{i, 2, k_1}$, sigs) to
          \ledger
        \ElsIf{$k_2 > 0$} \Comment{only right neighbour has published its TX}
          \State add $(\mathrm{sig}(\mathrm{TX}_{i, 2, k_2}, \pk{p, i, k_2}))_{p
          \in [n] \setminus \{i\}}$ to sigs
          \State add \textsc{sign}($\mathrm{TX}_{i, 2, k_2}$, $\sk{i, i, k_2}$,
          \texttt{ANYPREVOUT}) to sigs
          \State add \textsc{sign}($\mathrm{TX}_{i, 2, k_2}$, $\sk{i,
          \mathrm{right}, \mathrm{fund}, \mathrm{old}}$, \texttt{ANYPREVOUT}) to
          sigs
          \State input (\textsc{submit}, $\mathrm{TX}_{i, 2, k_2}$, sigs) to
          \ledger
        \EndIf
      \EndIndent
      \Statex

      \State On input (\textsc{check for revoked}) by $R \in \{\texttt{guest},
      \texttt{funder}, \texttt{fundee}\}$:
      \Indent
        \State input (\textsc{read}) to \ledger and assign output to $\Sigma$
        \If{$\mathrm{TX}_{i-1, 1} \in \Sigma \vee \exists k \in \mathbb{N}:
        \mathrm{TX}_{i-1, 2, k} \in \Sigma$} \Comment{left counterparty
        maliciously published old virtual tx}
          \If{$\exists k \in \mathbb{N}: \mathrm{TX}_{i-1, 2, k} \in
          \Sigma$} \Comment{exactly one of the two pairs is valid. That is OK}
            \State $(R_a, \sk{a}, R_b, \sk{b}) \gets (R_{i-1, 2, k}, \sk{i, 2,
            1}, R_{\mathrm{loc}, \mathrm{left}, \mathrm{virt}}, \sk{i,
            \mathrm{rev}})$
          \Else
            \State $(R_a, \sk{a}, R_b, \sk{b}) \gets (R_{i-1, 1}, \sk{i, 2, 1},
            R_{\mathrm{loc}, \mathrm{left}, \mathrm{virt}}, \sk{i,
            \mathrm{rev}})$
          \EndIf
          \State input (\textsc{submit}, ($R_a$, $R_b$, $R_{\mathrm{loc},
          \mathrm{left}, \mathrm{virt}}$, $R_{\mathrm{loc}, \mathrm{left},
          \mathrm{fund}}$), (\textsc{sign}($R_a$, $\sk{a}$),
          (\textsc{sign}($R_b$, $\sk{b}$), \textsc{sign}($R_{\mathrm{loc},
          \mathrm{left}, \mathrm{virt}}$, $\sk{i, \mathrm{rev}}$),
          \textsc{sign}($R_{\mathrm{loc}, \mathrm{left}, \mathrm{fund}}$,
          $\sk{i, \mathrm{rev}}$))) to \ledger
        \EndIf
        \If{$\mathrm{TX}_{i+1, 1} \in \Sigma \vee \exists k \in \mathbb{N}:
        \mathrm{TX}_{i+1, 2, k} \in \Sigma$} \Comment{right counterparty
        maliciously published old virtual tx}
          \State input (\textsc{submit}, ($R_{\mathrm{loc}, \mathrm{right},
          \mathrm{virt}}$, $R_{\mathrm{loc}, \mathrm{right}, \mathrm{fund}}$),
          (\textsc{sign}($R_{\mathrm{loc}, \mathrm{right}, \mathrm{virt}}$,
          $\sk{i, \mathrm{rev}}$), \textsc{sign}($R_{\mathrm{loc},
          \mathrm{right}, \mathrm{fund}}$, $\sk{i, \mathrm{rev}}$))) to \ledger
        \EndIf
        \State output (\textsc{nothing revoked}) to $R$
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:poll}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt} -- On input (\textsc{forceClose}) by $R$:}
    \ \\
    \begin{algorithmic}[1]
      \State \Comment{At most one of \texttt{funder}, \texttt{fundee} is
      defined}
      \State ensure $R  \in \{\texttt{guest}, \texttt{funder},
      \texttt{fundee}\}$
      \IfThen{\textit{State} = \textsc{closed}}{output (\textsc{closed}) to
      $R$}
      \IfThen{\textit{State} = \textsc{guest punished}}{output (\textsc{guest
      punished}) to $R$}
      \label{code:virtual-layer:close:output-guest-punished}
      \State ensure $\textit{State} \in \{\textsc{open}, \textsc{closing}\}$
      \If{$\texttt{host}_P \neq \ledger$} \Comment{$\texttt{host}_P$ is a
      \textsc{virt}}
      \label{code:virtual-layer:close:if-nested-host}
        \State ignore all messages except for output (\textsc{closed}) by
        $\texttt{host}_P$. Also relay to $\texttt{host}_P$ any (\textsc{check if
        closing}) or (\textsc{forceClose}) input received
        \State input (\textsc{forceClose}) to $\texttt{host}_P$
      \EndIf
      \State \Comment{if we have a $\texttt{host}_P$, continue from here on
      output (\textsc{closed}) by it}
      \State send (\textsc{read}) to \ledger as $R$ and assign reply to
      $\Sigma$
      \If{$i \in \{1, n\} \wedge (\mathrm{TX}_{(i-1) + \frac{2}{n-1}(n-i), 1}
      \in \Sigma \vee \exists k \in [n]: \mathrm{TX}_{(i-1) +
      \frac{2}{n-1}(n-i), 2, k} \in \Sigma)$} \Comment{we are an endpoint and
      our counterparty has closed -- 1st subscript of TX is $2$ if $i=1$ and
      $n-1$ if $i=n$}
        \State ignore all messages except for (\textsc{check if closing}) and
        (\textsc{forceClose}) by $R$
        \State $\textit{State} \gets \textsc{closing}$
        \State give up execution token \Comment{control goes to \environment}
      \EndIf
      \State let $\mathrm{TX}_p$ be the unique transaction among
      $\mathrm{TX}_{i, 1}$, $(\mathrm{TX}_{i, 2, k})_{k \in [n]}$,
      $(\mathrm{TX}_{i, 3, k_1, k_2})_{k_1, k_2 \in [n]}$ that can be appended
      to $\Sigma$ in a valid way \Comment{ignore invalid subscript combinations}
      \label{code:virtual-layer:close:tx}
      \State let \texttt{sigs} be the set of stored signatures that sign
      $\mathrm{TX}_p$
      \State add \textsc{sign}($\mathrm{TX}_p$, $\sk{i, \mathrm{left},
      \mathrm{fund}, \mathrm{old}}$, \texttt{ANYPREVOUT}),
      \textsc{sign}($\mathrm{TX}_p$, $\sk{i, \mathrm{right}, \mathrm{fund},
      \mathrm{old}}$, \texttt{ANYPREVOUT}), $(\textsc{sign}(\mathrm{TX}_p,
      \sk{i, j, k}, \texttt{ANYPREVOUT}))_{j, k \in [n]}$ to \texttt{sigs}
      \Comment{ignore invalid signatures}
      \State ignore all messages except for (\textsc{check if closing}) by $R$
      \State $\textit{State} \gets \textsc{closing}$
      \State send (\textsc{submit}, $\mathrm{TX}_p$, \texttt{sigs}) to \ledger
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:close}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt} -- On input (\textsc{check if closing}) by
  $R$:}
    \ \\
    \begin{algorithmic}[1]
      \State ensure \textit{State} = \textsc{closing}
      \State ensure $R \in \{\texttt{guest}, \texttt{funder}, \texttt{fundee}\}$
      \State send (\textsc{read}) to \ledger as $R$ and assign reply to $\Sigma$
      \If{$i = 1$} \Comment{we are \texttt{host\_funder}}
        \State ensure that there exists an output with $c_P + c_{\bar{P}} -
        c_{\mathrm{virt}}$ coins and a $2/\{\pk{1, \mathrm{fund}, \mathrm{new}},
        \pk{2, \mathrm{fund}, \mathrm{new}}\}$ spending method with
        expired/non-existent timelock in $\Sigma$ \Comment{new base funding
        output}
        \label{code:virtual-layer:check-chain-close:funder:output-funder}
        \State ensure that there either exists an output with
        $c_{\mathrm{virt}}$ coins and a $2/\{\pk{\mathrm{left}, \mathrm{virt}},
        \pk{\mathrm{right}, \mathrm{virt}}\}$ spending method with
        expired/non-existent timelock in $\Sigma$ \StarComment{virtual funding
        output by a ``bridge'' tx} or a $\texttt{bridge}_p$ output. In the
        latter case, collect all $B_p$'s signatures in \texttt{sigs}, add
        \textsc{sign}($B_p$, $\sk{1, 2, 1}$, \texttt{ANYPREVOUT}) (or, if $p =
        n, 1$, \textsc{sign}($B_p$, $\sk{1, n-1, n}$, \texttt{ANYPREVOUT})
        instead) to \texttt{sigs}, send (\textsc{submit}, $B_p$, \texttt{sigs})
        to \ledger and keep waiting here for (\textsc{check if closing}) by $R$
        until $B_p$ is in $\Sigma$ returned by sending (\textsc{read}) to
        \ledger.
        \label{code:virtual-layer:check-chain-close:funder:output-virt}
      \ElsIf{$i = n$} \Comment{we are \texttt{host\_fundee}}
        \State ensure that there exists an output with $c_P + c_{\bar{P}} -
        c_{\mathrm{virt}}$ coins and a $2/\{\pk{n-1, \mathrm{fund},
        \mathrm{new}}, \pk{n, \mathrm{fund}, \mathrm{new}}\}$ spending method
        with expired/non-existent timelock in $\Sigma$ \Comment{new base funding
        output}
        \State ensure that there either exists an output with
        $c_{\mathrm{virt}}$ coins and a $2/\{\pk{\mathrm{left}, \mathrm{virt}},
        \pk{\mathrm{right}, \mathrm{virt}}\}$ spending method with
        expired/non-existent timelock in $\Sigma$ \StarComment{virtual funding
        output by a ``bridge'' tx} or a $\texttt{bridge}_p$ output. In the
        latter case, collect all $B_p$'s signatures in \texttt{sigs}, add
        \textsc{sign}($B_p$, $\sk{1, 2, 1}$, \texttt{ANYPREVOUT}) (or, if $p =
        n, 1$, \textsc{sign}($B_p$, $\sk{1, n-1, n}$, \texttt{ANYPREVOUT})
        instead) to \texttt{sigs}, send (\textsc{submit}, $B_p$, \texttt{sigs})
        to \ledger and keep waiting here for (\textsc{check if closing}) by $R$
        until $B_p$ is in $\Sigma$ returned by sending (\textsc{read}) to
        \ledger.
      \Else \: \Comment{we are intermediary}
        \IfThenElse{$\mathtt{side} = \text{``left''}$}{$j \gets i-1$}{$j \gets
        i+1$} \Comment{\texttt{side} is defined for all intermediaries -- cf.
        Fig.~\ref{code:virtual-layer:keys},
        l.~\ref{code:virtual-layer:keys:init}}
        \State ensure that there exists an output with $c_P + c_{\bar{P}} -
        c_{\mathrm{virt}}$ coins and a $2/\{\pk{i, \mathrm{fund}, \mathrm{new}},
        \pk{j, \mathrm{fund}, \mathrm{new}}\}$ spending method with
        expired/non-existent timelock in $\Sigma$
        \State ensure that there either exists an output with
        $c_{\mathrm{virt}}$ coins and a $\pk{i, \mathrm{out}}$ spending method
        with expired/non-existent timelock in $\Sigma$ \StarComment{virtual
        funding output by a ``bridge'' tx} or a $\texttt{bridge}_{i-1, p}$
        output. In the latter case, collect all $B_{i-1, p}$'s signatures in
        \texttt{sigs}, add \textsc{sign}($B_{i-1, p}$, $\sk{1, 2, 1}$,
        \texttt{ANYPREVOUT}) (or, if $i-1, p = n, 1$, \textsc{sign}($B_{i-1,
        p}$, $\sk{1, n-1, n}$, \texttt{ANYPREVOUT}) instead) to \texttt{sigs},
        send (\textsc{submit}, $B_{i-1, p}$, \texttt{sigs}) to \ledger and keep
        waiting here for (\textsc{check if closing}) by $R$ until $B_{i-1, p}$
        is in $\Sigma$ returned by sending (\textsc{read}) to \ledger.
      \EndIf
      \State $\textit{State} \gets \textsc{closed}$
      \State output (\textsc{closed}) to $R$
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:check-chain-close}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt} -- cooperative closing}
    \Comment{we are left intermediary or host of fundee}

    On (\textsc{coop close}, \texttt{sig\_bal}, \texttt{left\_comms\_revkeys})
    by $\bar{P}$:
    \begin{algorithmic}[1]
      \State ensure $\itistate = \textsc{open}$
      \State parse \texttt{sig\_bal} as $(c_1', c_2'), \mathrm{sig}_1,
      \mathrm{sig}_2$
      \State ensure $c_{\mathrm{virt}} = c_1' + c_2'$
      \State ensure \textsc{verify}($(c_1', c_2'), \mathrm{sig}_1,
      \pk{\mathrm{left}, \mathrm{virt}}$) = True
      \State ensure \textsc{verify}($(c_1', c_2'), \mathrm{sig}_2,
      \pk{\mathrm{right}, \mathrm{virt}}$) = True
      \State $\itistate \gets \textsc{coop closing}$
      \State extract $\mathrm{sig}_{i-1, \mathrm{right}, C}$, $\pk{i-1,
      \mathrm{right}, R}$ from \texttt{left\_comms\_revkeys}
      \IfThenElse{{$i < n$}}{$M \gets \textsc{check coop close}$}{$M \gets
      \textsc{check coop close fundee}$}
      \State output ($M$, $(c_1', c_2')$, $\mathrm{sig}_{i-1, \mathrm{right}, C}$,
      $\pk{i-1, \mathrm{right}, R}$) to \texttt{guest}
      \label{code:virtual-layer:coop-close-intermediary:first-invoke-guest}
      \State \trustedcode{ensure $\itistate = \textsc{open}$} \Comment{executed
      by \texttt{guest}}
      \label{code:virtual-layer:coop-close-intermediary:first-activation-guest}
      \State \trustedcode{$\itistate \gets \textsc{coop closing}$}
      \label{code:virtual-layer:coop-close-intermediary:guest-state-change}
      \State \trustedcode{store received signature as $\mathrm{sig}_{\bar{P}, C,
      i+1}$} \Comment{in \texttt{guest}s, $i$ is the current state number}
      \State \trustedcode{store received revocation key as $\pk{\bar{P}, R,
      i+2}$}
      \State \trustedcode{remove most recent keys from list of old funding keys
      and assign them to $\sk{P, F}'$, $\pk{P, F}'$ and $\pk{\bar{P}, F}'$}
      \label{code:virtual-layer:coop-close-intermediary:left-old-fund-keys}
      \State \trustedcode{$C_{P, i+1} \gets$ TX \{input: $(c_P + c_{\bar{P}} +
      c_1' + c_2', 2/\{\pk{P, F}', \pk{\bar{P}, F}'\})$, outputs: $(c_P + c_2',
      (\pk{P, \mathrm{out}} + (p + s)) \vee 2/\{\pk{\bar{P}, R, i+1}, \pk{P, R,
      i+1}\})$, $(c_{\bar{P}} + c_1', \pk{\bar{P}, \mathrm{out}})$\}}
      \label{code:virtual-layer:coop-close-intermediary:left-interm-comm}
      \State \trustedcode{ensure \textsc{verify}($C_{P, i+1}$,
      $\mathrm{sig}_{\bar{P}, C, i+1}$, $\pk{\bar{P}, F}'$) = True}
      \label{code:virtual-layer:coop-close-intermediary:left-interm-verify-comm}
      \State \trustedcode{input (\textsc{coop close check ok}) to
      $\texttt{host}_P$}
      \If{$i < n$} \Comment{we are intermediary}
        \State input (\textsc{coop close}, \texttt{left\_comms\_keys}) to
        \texttt{sibling}
        \State \trustedcode{ensure $\itistate = \textsc{open}$} \Comment{executed
        by \texttt{sibling}}
        \State \trustedcode{$\itistate \gets \textsc{coop closing}$}
        \State \trustedcode{output (\textsc{coop close sign comm}, $(c_1', c_2')$)
        to \texttt{guest}}
        \State \trustedcode{ensure $\itistate = \textsc{open}$} \Comment{executed
        by \texttt{guest} of \texttt{sibling}}
        \label{code:virtual-layer:coop-close-intermediary:first-activation-guest-sibling}
        \State \trustedcode{$\itistate \gets \textsc{coop closing}$}
        \label{code:virtual-layer:coop-close-intermediary:guest-sibling-state-change}
        \State \trustedcode{remove most recent keys from list of old funding keys
        and assign them to $\sk{P, F}'$, $\pk{P, F}'$ and $\pk{\bar{P}, F}'$}
        \label{code:virtual-layer:coop-close-intermediary:right-old-fund-keys}
        \State \trustedcode{$C_{\bar{P}, i+1} \gets$ TX \{input: $(c_P +
        c_{\bar{P}} + c_1' + c_2', 2/\{\pk{P, F}', \pk{\bar{P}, F}'\})$, outputs:
        $(c_P + c_1', \pk{P, \mathrm{out}})$, $(c_{\bar{P}} + c_2', (\pk{\bar{P},
        \mathrm{out}} + (p + s)) \vee 2/\{\pk{P, R, i+1}, \pk{\bar{P}, R,
        i+1}\})$\}}
        \label{code:virtual-layer:coop-close-intermediary:right-interm-comm}
        \State \trustedcode{$\mathrm{sig}_{P, C, i+1} \gets
        \textsc{sign}(C_{\bar{P}, i+1}, \sk{P, F}')$}
        \label{code:virtual-layer:coop-close-intermediary:right-interm-sign-comm}
        \State \trustedcode{$(\sk{P, R, i+2}, \pk{P, R, i+2}) \gets
        \textsc{keyGen}()$}
        \State \trustedcode{input (\textsc{new comm tx}, $\mathrm{sig}_{P, C,
        i+1}$, $\pk{P, R, i+2}$) to $\texttt{host}_P$}
        \State \trustedcode{rename received signature to $\mathrm{sig}_{i,
        \mathrm{right}, C}$} \Comment{executed by \texttt{sibling}}
        \State \trustedcode{rename received public key to $\pk{i, \mathrm{right},
        R}$} \Comment{in \texttt{host}s, $i$ is our hop number}
        \State \trustedcode{send (\textsc{coop close}, \texttt{sig\_bal},
        (\texttt{left\_comms\_keys}, $\mathrm{sig}_{i, \mathrm{right}, C}$,
        $\pk{i, \mathrm{right}, R}$)
        to $\bar{P}$ and expect reply (\textsc{coop close back},
        (\texttt{right\_comms\_revkeys}, \texttt{right\_revocations}))}
        \State \trustedcode{$R_{\mathrm{loc}, \mathrm{right}, \mathrm{virt}}
        \gets$ TX \{input: $(c_{\mathrm{virt}}, 2/\{\pk{i, \mathrm{rev}},
        \pk{i+1, \mathrm{rev}}\})$, output: $(c_{\mathrm{virt}}, \pk{i,
        \mathrm{out}})$\}}
        \State \trustedcode{extract $\mathrm{sig}_{i+1, \mathrm{right},
        \mathrm{rev}, \mathrm{virt}}$ from \texttt{right\_revocations}}
        \State \trustedcode{ensure \textsc{verify}($R_{\mathrm{loc},
        \mathrm{right}, \mathrm{virt}}$, $\mathrm{sig}_{i+1, \mathrm{right},
        \mathrm{rev}, \mathrm{virt}}$, $\pk{i+1, \mathrm{rev}}$) = True}
        \label{code:virtual-layer:coop-close-intermediary:verify-right-virt-rev}
        \State \trustedcode{$R_{\mathrm{loc}, \mathrm{right}, \mathrm{fund}}
        \gets$ TX \{input: $(c_P + c_{\bar{P}}, 2/\{\pk{i, \mathrm{rev}},
        \pk{i+1, \mathrm{rev}}\})$, output: $(c_P + c_{\bar{P}}, \pk{i,
        \mathrm{out}})$\}}
        \State \trustedcode{extract $\mathrm{sig}_{i+1, \mathrm{right},
        \mathrm{rev}, \mathrm{fund}}$ from \texttt{right\_revocations}}
        \State \trustedcode{ensure \textsc{verify}($R_{\mathrm{loc},
        \mathrm{right}, \mathrm{fund}}$, $\mathrm{sig}_{i+1, \mathrm{right},
        \mathrm{rev}, \mathrm{fund}}$, $\pk{i+1, \mathrm{rev}}$) = True}
        \label{code:virtual-layer:coop-close-intermediary:verify-right-fund-rev}
        \State \trustedcode{extract $\mathrm{sig}_{i+1, \mathrm{left}, C}$ from
        \texttt{right\_comms\_revkeys}}
        \State \trustedcode{extract $\mathrm{sig}_{i+1, \mathrm{left}, R}$ from
        \texttt{right\_revocations}}
        \State \trustedcode{extract $\pk{i+1, \mathrm{left}, R}$ from
        \texttt{right\_comms\_revkeys}}
        \State \trustedcode{output (\textsc{verify comm rev}, $\mathrm{sig}_{i+1,
        \mathrm{left}, C}$, $\mathrm{sig}_{i+1, \mathrm{left}, R}$, $\pk{i+1,
        \mathrm{left}, R}$) to \texttt{guest}}
        \State \trustedcode{store received public key as $\pk{\bar{P}, R, i+2}$}
        \Comment{executed by \texttt{guest} of \texttt{sibling}}
        \State \trustedcode{store $\mathrm{sig}_{i+1, \mathrm{left}, C}$ as
        $\mathrm{sig}_{\bar{P}, C, i+1}$, $\pk{\bar{P}, R, i+2}$}
        \State \trustedcode{$C_{P, i+1} \gets$ TX \{input: $(c_P + c_{\bar{P}} +
        c_1' + c_2', 2/\{\pk{P, F}', \pk{\bar{P}, F}'\})$, outputs: $(c_P +
        c_1, (\pk{P, \mathrm{out}} + (p + s)) \vee 2/\{\pk{P, R, i+1},
        \pk{\bar{P}, R, i+1}\})$, $(c_{\bar{P}} + c_2', \pk{\bar{P},
        \mathrm{out}})$\}}
        \State \trustedcode{ensure \textsc{verify}($C_{P, i+1}$,
        $\mathrm{sig}_{\bar{P}, C, i+1}$, $\pk{\bar{P}, F}'$) = True}
        \label{code:virtual-layer:coop-close-intermediary:right-interm-verify-comm}
        \State \trustedcode{store $\mathrm{sig}_{i+1, \mathrm{left}, R}$ as
        $\mathrm{sig}_{\bar{P}, R, i}$}
        \State \trustedcode{$R_{P, i} \gets$ TX \{input: $C_{\bar{P},
        i}$.outputs.$\bar{P}$, output: ($c_P + c_{\bar{P}}$, $\pk{P,
        \mathrm{out}}$)\}}
        \State \trustedcode{ensure \textsc{verify}($R_{P, i}$,
        $\mathrm{sig}_{\bar{P}, R, i}$, $\pk{\bar{P}, R, i}$) = True}
        \label{code:virtual-layer:coop-close-intermediary:right-interm-verify-rev}
        \State \trustedcode{input (\textsc{comm rev verified}) to
        $\texttt{host}_P$}
        \State \trustedcode{output (\textsc{coop close back},
        \texttt{right\_comms\_revkeys}, \texttt{right\_revocations}) to
        \texttt{sibling}} \Comment{executed by \texttt{sibling}}
        \State $R_{\mathrm{loc}, \mathrm{left}, \mathrm{virt}} \gets$ TX
        \{input: $(c_{\mathrm{virt}}, 4/\{\pk{1, \mathrm{rev}}, \pk{i-1,
        \mathrm{rev}}, \pk{i, \mathrm{rev}}, \pk{n, \mathrm{rev}}\})$, output:
        $(c_{\mathrm{virt}}, \pk{i, \mathrm{out}})$\} \Comment{the input
        corresponds to the revocation path of the virtual output of all virtual
        txs owned by $\bar{P}$}
        \State extract $\mathrm{sig}_{n, i, \mathrm{left}, \mathrm{rev},
        \mathrm{virt}}$ from \texttt{right\_revocations}
        \State ensure \textsc{verify}($R_{\mathrm{loc}, \mathrm{left}}$,
        $\mathrm{sig}_{n, \mathrm{left}, \mathrm{rev}}$, $\pk{n, \mathrm{rev}}$)
        = True
        \IfThenElse{$i = 2$}{$m \gets 1$}{$m \gets 2$}
        \IfThenElse{$i = n-1$}{$l \gets n$}{$l \gets n-1$}
        \State ensure that the following signatures are present in
        \texttt{right\_revocations} and store them:
        \begin{itemize}
          \item \Comment{$1$ signature}
        \end{itemize}
        \Indent
          \State sig($R_{i-1, 1}, \pk{n, \mathrm{rev}}$)
        \EndIndent
        \begin{itemize}
          \item \Comment{$l-m$ signatures}
        \end{itemize}
        \Indent
          \State $\forall k \in \{m, \dots, l\} \setminus \{i\}:$
          \Indent
            \State sig($R_{i-1, 2, k}, \pk{n, \mathrm{rev}}$)
          \EndIndent
        \EndIndent
        \begin{itemize}
          \item \Comment{$(i-m) \cdot (l-i)$ signatures}
        \end{itemize}
        \Indent
          \State $\forall k_1 \in \{m, \dots, i-1\}, \forall k_2 \in \{i+1,
          \dots, l\}:$
          \Indent
            \State sig($R_{i-1, 3, k_1, k_2}, \pk{n, \mathrm{rev}}$)
          \EndIndent
        \EndIndent
        \label{code:virtual-layer:coop-close-intermediary:verify-left-virt-rev-end}
      \Else \: \Comment{$i = n$, we are host of fundee}
        \State output (\textsc{revoke}) to \texttt{fundee}
        \State \trustedcode{$R_{\bar{P}, i} \gets$ TX \{input: $C_{P,
        i}$.outputs.$P$, output: $(c_P, \pk{\bar{P}, \mathrm{out}})$\}}
        \Comment{executed by \texttt{fundee}}
        \State \trustedcode{$\mathrm{sig}_{P, R, i} \gets
        \textsc{sign}(R_{\bar{P}, i}, \sk{P, R, i})$}
        \State \trustedcode{$\texttt{virtual\_revocation\_sigs} \gets
        \emptyset$}
        \For{\trustedcode{$j \in [n-1]$}}
          \State \trustedcode{$R_{j, 1} \gets$ TX \{input: $\mathrm{TX}_{j,
          1}.\texttt{revocation}_1$, output: $(c_{\mathrm{virt}}, \pk{j+1,
          \mathrm{out}})$\}}
          \State \trustedcode{$\mathrm{sig}_{j, R, 1, i} \gets
          \textsc{sign}(R_{j, 1}, \sk{i, \mathrm{rev}})$;
          $\texttt{virtual\_revocation\_sigs} \gets
          \texttt{virtual\_revocation\_sigs} \cup \mathrm{sig}_{j, R, 1, i}$}
          \IfThenElse{\trustedcode{$j = 2$}}{\trustedcode{$m \gets
          1$}}{\trustedcode{$m \gets 2$}}
          \IfThenElse{\trustedcode{$j = n-1$}}{\trustedcode{$l \gets
          n$}}{\trustedcode{$l \gets n-1$}}
          \For{\trustedcode{$k \in \{m, \dots, l\}$}}
            \State \trustedcode{$R_{j, 2, k} \gets$ TX \{input: $\mathrm{TX}_{j,
            2, k}.\texttt{revocation}_{2, k}$, output: $(c_{\mathrm{virt}},
            \pk{j+1, \mathrm{out}})$\}}
            \State \trustedcode{$\mathrm{sig}_{j, R, 2, k, i} \gets
            \textsc{sign}(R_{j, 2, k}, \sk{i, \mathrm{rev}})$;
            $\texttt{virtual\_revocation\_sigs} \gets
            \texttt{virtual\_revocation\_sigs} \cup \mathrm{sig}_{j, R, 2, k,
            i}$}
          \EndFor
          \For{\trustedcode{$k_1 \in \{m, \dots, j-1\}, k_2 \in \{j+1, \dots,
          l\}$}}
            \State \trustedcode{$R_{j, 3, k_1, k_2} \gets$ TX \{input:
            $\mathrm{TX}_{j, 3, k_1, k_2}.\texttt{revocation}_{3, k_1, k_2}$,
            output: $(c_{\mathrm{virt}}, \pk{j+1, \mathrm{out}})$\}}
            \State \trustedcode{$\mathrm{sig}_{j, R, 3, k_1, k_2, i} \gets
            \textsc{sign}(R_{j, 3, k_1, k_2}, \sk{i, \mathrm{rev}})$;
            $\texttt{virtual\_revocation\_sigs} \gets
            \texttt{virtual\_revocation\_sigs} \cup \mathrm{sig}_{j, R, 3, k_1,
            k_2, i}$}
          \EndFor
        \EndFor
        \State \trustedcode{input (\textsc{revocations}, $\mathrm{sig}_{P, R,
        i}$, \texttt{virtual\_revocation\_sigs}) to $\texttt{host}_P$}
        \State rename received signature $\mathrm{sig}_{P, R, i}$ to
        $\mathrm{sig}_{n, \mathrm{right}, R}$
        \ForAll{$j \in \{2, \dots, n\}$}
          \State $R_{j, \mathrm{left}} \gets$ TX \{input: $(c_{\mathrm{virt}},
          4/\{\pk{1, \mathrm{rev}}, \pk{j-1, \mathrm{rev}}, \pk{j,
          \mathrm{rev}}, \pk{n, \mathrm{rev}}\})$, output: $(c_{\mathrm{virt}},
          \pk{j, \mathrm{out}})\}$
          \State $\mathrm{sig}_{n, j, \mathrm{left}, \mathrm{rev}} \gets
          \textsc{sign}(R_{j, \mathrm{left}}, \sk{n, \mathrm{rev}})$
        \EndFor
      \EndIf
      \State output (\textsc{new comm rev}) to \texttt{guest}
      \State \trustedcode{$C_{\bar{P}, i+1} \gets$ TX \{input: $(c_P +
      c_{\bar{P}} + c_1' + c_2', 2/\{\pk{\bar{P}, F}', \pk{P, F}'\})$, outputs:
      $(c_{\bar{P}} + c_1', (\pk{\bar{P}, \mathrm{out}} + (p + s)) \vee
      2/\{\pk{\bar{P}, R, i+1}, \pk{P, R, i+1}\})$, $(c_P + c_2', \pk{P,
      \mathrm{out}})$\}} \Comment{executed by \texttt{guest}}
      \State \trustedcode{$\mathrm{sig}_{P, C, i+1} \gets
      \textsc{sign}(C_{\bar{P}, i+1}, \sk{P, F}')$}
      \label{code:virtual-layer:coop-close-intermediary:left-interm-sign-comm}
      \State \trustedcode{$R_{\bar{P}, i} \gets$ TX \{input: $C_{P,
      i}$.outputs.$P$, output: ($c_P + c_{\bar{P}}$, $\pk{\bar{P},
      \mathrm{out}}$)\}}
      \State \trustedcode{$\mathrm{sig}_{P, R, i} \gets
      \textsc{sign}(R_{\bar{P}, i}, \sk{P, R, i})$}
      \label{code:virtual-layer:coop-close-intermediary:left-interm-sign-rev}
      \State \trustedcode{$(\sk{P, R, i+2}, \pk{P, R, i+2}) \gets
      \textsc{keyGen}()$}
      \State \trustedcode{input (\textsc{new comm rev}, $\mathrm{sig}_{P, C,
      i+1}$, $\mathrm{sig}_{P, R, i}$, $\pk{P, R, i+2}$) to $\texttt{host}_P$}
      \label{code:virtual-layer:coop-close-intermediary:left-interm-send-comm-rev}
      \State rename $\mathrm{sig}_{P, C, i+1}$ to $\mathrm{sig}_{i,
      \mathrm{left}, C}$
      \State rename $\mathrm{sig}_{P, R, i}$ to $\mathrm{sig}_{i,
      \mathrm{left}, R}$
      \State rename received public key to $\pk{i, \mathrm{left}, R}$
      \State $R_{\mathrm{rem}, \mathrm{left}, \mathrm{virt}} \gets$ TX \{input:
      $(c_{\mathrm{virt}}, 2/\{\pk{i-1, \mathrm{rev}}, \pk{i, \mathrm{rev}}\})$,
      output: $(c_{\mathrm{virt}}, \pk{i-1, \mathrm{out}})$\}
      \State $\mathrm{sig}_{i, \mathrm{left}, \mathrm{rev}, \mathrm{virt}} \gets
      \textsc{sign}(R_{\mathrm{rem}, \mathrm{left}, \mathrm{virt}}, \sk{i,
      \mathrm{rev}})$
      \State $R_{\mathrm{rem}, \mathrm{left}, \mathrm{fund}} \gets$ TX \{input:
      $(c_P + c_{\bar{P}}, 2/\{\pk{i-1, \mathrm{rev}}, \pk{i,
      \mathrm{rev}}\})$, output: $(c_P + c_{\bar{P}}, \pk{i-1, \mathrm{out}})$\}
      \State $\mathrm{sig}_{i, \mathrm{left}, \mathrm{rev}, \mathrm{fund}} \gets
      \textsc{sign}(R_{\mathrm{rem}, \mathrm{left}, \mathrm{fund}}, \sk{i,
      \mathrm{rev}})$
      \If{$i < n$} \Comment{we are intermediary}
        \State $M \gets$ (\textsc{coop close back},
        ((\texttt{right\_comms\_revkeys}, $\mathrm{sig}_{i, \mathrm{left}, C}$,
        $\pk{i, \mathrm{left}, R}$), (\texttt{right\_revocations},
        $\mathrm{sig}_{i, \mathrm{left}, \mathrm{rev}, \mathrm{virt}}$,
        $\mathrm{sig}_{i, \mathrm{left}, \mathrm{rev}, \mathrm{fund}}$,
        $\mathrm{sig}_{i, \mathrm{left}, R}$)))
      \Else \: \Comment{$i = n$, we are host of fundee}
        \State $M \gets$ (\textsc{coop close back}, ($\mathrm{sig}_{i,
        \mathrm{left}, C}$, $\pk{i, \mathrm{left}, R}$,  $\mathrm{sig}_{n,
        \mathrm{left}, R}$), ($\mathrm{sig}_{n, \mathrm{left}, \mathrm{rev},
        \mathrm{virt}}$, $\mathrm{sig}_{n, \mathrm{left}, \mathrm{rev},
        \mathrm{fund}}$, $(\mathrm{sig}_{n, j, \mathrm{left}, \mathrm{rev}})_{j
        \in \{2, \dots, n\}}$), \texttt{virtual\_rev\_sigs})
      \EndIf
      \State send $M$ to $\bar{P}$ and expect reply (\textsc{coop close
      revocations}, \texttt{left\_revocations})
      \State extract $\mathrm{sig}_{i-1, \mathrm{right}, R}$,
      $\mathrm{sig}_{1, i, \mathrm{right}, \mathrm{rev}}$, $\mathrm{sig}_{i-1,
      \mathrm{right}, \mathrm{rev}}$ from \texttt{left\_revocations}
      \State ensure \textsc{verify}($R_{\mathrm{loc}, \mathrm{left},
      \mathrm{virt}}$,
      $\mathrm{sig}_{1, \mathrm{right}, \mathrm{rev}}$, $\pk{1, \mathrm{rev}}$)
      = True
      \label{code:virtual-layer:coop-close-intermediary:verify-left-virt-rev-start}
      \State ensure \textsc{verify}($R_{\mathrm{loc}, \mathrm{left},
      \mathrm{virt}}$,
      $\mathrm{sig}_{i-1, \mathrm{right}, \mathrm{rev}}$, $\pk{i-1,
      \mathrm{rev}}$) = True
      \label{code:virtual-layer:coop-close-intermediary:verify-left-virt-rev-left}
      \State $R_{\mathrm{loc}, \mathrm{left}, \mathrm{fund}} \gets$ TX
      \{input: $(c_P + c_{\bar{P}}, 2/\{\pk{i-1,
      \mathrm{rev}}, \pk{i, \mathrm{rev}})$, output:
      $(c_P + c_{\bar{P}}, \pk{i, \mathrm{out}})$\} \Comment{the input
      corresponds to the revocation path of the right funding output of all
      virtual txs owned by $\bar{P}$}
      \State extract $\mathrm{sig}_{i-1, \mathrm{left}, \mathrm{rev},
      \mathrm{fund}}$ from \texttt{left\_revocations}
      \State ensure \textsc{verify}($R_{\mathrm{loc}, \mathrm{left},
      \mathrm{fund}}$, $\mathrm{sig}_{i-1, \mathrm{left}, \mathrm{rev},
      \mathrm{fund}}$, $\pk{i-1, \mathrm{rev}}$) = True
      \label{code:virtual-layer:coop-close-intermediary:verify-left-fund-rev}
      \IfThenElse{$i = 2$}{$m \gets 1$}{$m \gets 2$}
      \IfThenElse{$i = n-1$}{$l \gets n$}{$l \gets n-1$}
      \State ensure that the following signatures are present in
      \texttt{left\_revocations} and store them:
      \begin{itemize}
        \item \Comment{$2$ signatures}
      \end{itemize}
      \Indent
        \State sig($R_{i-1, 1}, \pk{1, \mathrm{rev}}$), sig($R_{i-1, 1},
        \pk{i-1, \mathrm{rev}}$)
      \EndIndent
      \begin{itemize}
        \item \Comment{$2(l-m)$ signatures}
      \end{itemize}
      \Indent
        \State $\forall k \in \{m, \dots, l\} \setminus \{i\}:$
        \Indent
          \State sig($R_{i-1, 2, k}, \pk{1, \mathrm{rev}}$), sig($R_{i-1, 2, k},
          \pk{i-1, \mathrm{rev}}$)
        \EndIndent
      \EndIndent
      \begin{itemize}
        \item \Comment{$2(i-m) \cdot (l-i)$ signatures}
      \end{itemize}
      \Indent
        \State $\forall k_1 \in \{m, \dots, i-1\}, \forall k_2 \in \{i+1,
        \dots, l\}:$
        \Indent
          \State sig($R_{i-1, 3, k_1, k_2}, \pk{1, \mathrm{rev}}$), sig($R_{i-1,
          3, k_1, k_2}, \pk{i-1, \mathrm{rev}}$)
        \EndIndent
      \EndIndent
      \State output (\textsc{verify rev}, $\mathrm{sig}_{i-1, \mathrm{right},
      R}$, $\texttt{host}_P$) to \texttt{guest}
      \State \trustedcode{store received signature as $\mathrm{sig}_{bar{P}, R,
      i}$} \Comment{executed by \texttt{guest}}
      \State \trustedcode{$R_{P, i} \gets$ TX \{input: $C_{\bar{P},
      i}$.outputs.$\bar{P}$, output: ($c_P + c_{\bar{P}}$, $\pk{P,
      \mathrm{out}}$)\}}
      \State \trustedcode{ensure \textsc{verify}($R_{P, i}$,
      $\mathrm{sig}_{\bar{P}, R, i}$, $\pk{\bar{P}, R, i}$) = True}
      \label{code:virtual-layer:coop-close-intermediary:left-interm-verify-rev}
      \State \trustedcode{add $\texttt{host}_P$ to list of old hosts}
      \State \trustedcode{assign received host to $\texttt{host}_P$}
      \State \trustedcode{$i \gets i+1$; $c_P \gets c_P + c_2'$; $c_{\bar{P}}
      \gets c_{\bar{P}} + c_1'$}
      \State \trustedcode{add $\sk{P, F}, \pk{P, F}, \pk{\bar{P}, F}$ to list of
      old enabler channel funding keys}
      \State \trustedcode{$(\sk{P, F}, \pk{P, F}) \gets (\sk{P, F}', \pk{P,
      F}')$}
      \State \trustedcode{$\texttt{layer} \gets \texttt{layer} - 1$}
      \State \trustedcode{$\texttt{locked}_P \gets \texttt{locked}_P -
      c_{\mathrm{virt}}$}
      \State \trustedcode{$\itistate \gets \textsc{open}$}
      \label{code:virtual-layer:coop-close-intermediary:guest-back-open}
      \State \trustedcode{$\texttt{hosting} \gets$ False}
      \State \trustedcode{input (\textsc{rev verified}) to last old host}
      \State $\itistate \gets \textsc{coop closed}$
      \If{$i < n$} \Comment{we are intermediary}
      \label{code:virtual-layer:coop-close-intermediary:intermediary-revoke}
        \State send (\textsc{coop close revocations}, \texttt{left\_revocations})
        to \texttt{sibling}
        \State \trustedcode{output (\textsc{coop close revocations},
        $\texttt{host}_P$) to \texttt{guest}} \Comment{executed by
        \texttt{sibling}}
        \State \trustedcode{$R_{\bar{P}, i} \gets$ TX \{input: $C_{P,
        i}$.outputs.$P$, output: ($c_P$, $\pk{\bar{P}, \mathrm{out}}$)\}}
        \Comment{executed by \texttt{guest} of \texttt{sibling}}
        \State \trustedcode{$\mathrm{sig}_{P, R, i} \gets
        \textsc{sign}(R_{\bar{P}, i}, \sk{P, R, i})$}
        \State \trustedcode{add $\texttt{host}_P$ to list of old hosts}
        \State \trustedcode{assign received host to $\texttt{host}_P$}
        \State \trustedcode{$i \gets i+1$; $c_P \gets c_P + c_1'$; $c_{\bar{P}}
        \gets c_{\bar{P}} + c_2'$}
        \State \trustedcode{add $\sk{P, F}, \pk{P, F}, \pk{\bar{P}, F}$ to list of
        old enabler channel funding keys}
        \State \trustedcode{$(\sk{P, F}, \pk{P, F}) \gets (\sk{P, F}', \pk{P,
        F}')$}
        \State \trustedcode{$\texttt{layer} \gets \texttt{layer} - 1$}
        \State \trustedcode{$\texttt{locked}_P \gets \texttt{locked}_P -
        c_{\mathrm{virt}}$}
        \State \trustedcode{$\itistate \gets \textsc{open}$}
        \label{code:virtual-layer:coop-close-intermediary:sibling-guest-back-open}
        \State \trustedcode{$\texttt{hosting} \gets$ False}
        \State \trustedcode{input (\textsc{revocation}, $\mathrm{sig}_{P, R, i}$)
        to last old host}
        \State \trustedcode{rename received signature to $\mathrm{sig}_{i,
        \mathrm{right}, R}$} \Comment{executed by \texttt{sibling}}
        \State \trustedcode{$R_{\mathrm{rem}, \mathrm{right}, \mathrm{virt}}
        \gets$ TX \{input: $(c_{\mathrm{virt}}, 4/\{\pk{1, \mathrm{rev}}, \pk{i,
        \mathrm{rev}}, \pk{i+1, \mathrm{rev}}, \pk{n, \mathrm{rev}}\})$, output:
        $(c_{\mathrm{virt}}, \pk{i+1, \mathrm{out}})$\}}
        \State \trustedcode{$\mathrm{sig}_{i, \mathrm{right}, \mathrm{rev},
        \mathrm{virt}} \gets \textsc{sign}(R_{\mathrm{rem}, \mathrm{right},
        \mathrm{virt}}, \sk{i, \mathrm{rev}})$}
        \State \trustedcode{$R_{\mathrm{rem}, \mathrm{right}, \mathrm{fund}}
        \gets$ TX \{input: $(c_P + c_{\bar{P}}, 2/\{\pk{i, \mathrm{rev}},
        \pk{i+1, \mathrm{rev}}\})$, output: $(c_P + c_{\bar{P}}, \pk{i+1,
        \mathrm{out}})$\}}
        \State \trustedcode{$\mathrm{sig}_{i, \mathrm{right}, \mathrm{rev},
        \mathrm{fund}} \gets \textsc{sign}(R_{\mathrm{rem}, \mathrm{right},
        \mathrm{fund}}, \sk{i, \mathrm{rev}})$}
        \State \trustedcode{$R_{i, 1} \gets$ TX \{input: $\mathrm{TX}_{i,
        1}.\texttt{revocation}_1$, output: $(c_{\mathrm{virt}}, \pk{i+1,
        \mathrm{out}})$\}}
        \State \trustedcode{$\mathrm{sig}_{i, R, 1, i} \gets \textsc{sign}(R_{i,
        1}, \sk{i, \mathrm{rev}})$; $\texttt{left\_revocations} \gets
        \texttt{left\_revocations} \cup \mathrm{sig}_{i, R, 1, i}$}
        \IfThenElse{\trustedcode{$i = 2$}}{\trustedcode{$m \gets
        1$}}{\trustedcode{$m \gets 2$}}
        \IfThenElse{\trustedcode{$i = n-1$}}{\trustedcode{$l \gets
        n$}}{\trustedcode{$l \gets n-1$}}
        \For{\trustedcode{$k \in \{m, \dots, l\}$}}
          \State \trustedcode{$R_{i, 2, k} \gets$ TX \{input: $\mathrm{TX}_{i,
          2, k}.\texttt{revocation}_{2, k}$, output: $(c_{\mathrm{virt}},
          \pk{i+1, \mathrm{out}})$\}}
          \State \trustedcode{$\mathrm{sig}_{i, R, 2, k, i} \gets
          \textsc{sign}(R_{i, 2, k}, \sk{i, \mathrm{rev}})$;
          $\texttt{left\_revocations} \gets \texttt{left\_revocations} \cup
          \mathrm{sig}_{i, R, 2, k, i}$}
        \EndFor
        \For{\trustedcode{$k_1 \in \{m, \dots, i-1\}, k_2 \in \{i+1, \dots,
        l\}$}}
          \State \trustedcode{$R_{i, 3, k_1, k_2} \gets$ TX \{input:
          $\mathrm{TX}_{i, 3, k_1, k_2}.\texttt{revocation}_{3, k_1, k_2}$,
          output: $(c_{\mathrm{virt}}, \pk{i+1, \mathrm{out}})$\}}
          \State \trustedcode{$\mathrm{sig}_{i, R, 3, k_1, k_2, i} \gets
          \textsc{sign}(R_{i, 3, k_1, k_2}, \sk{i, \mathrm{rev}})$;
          $\texttt{left\_revocations} \gets \texttt{left\_revocations} \cup
          \mathrm{sig}_{i, R, 3, k_1, k_2, i}$}
        \EndFor
        \State \trustedcode{send (\textsc{coop close revocations},
        (\texttt{left\_revocations}, $\mathrm{sig}_{i, \mathrm{right}, R}$,
        $\mathrm{sig}_{i, \mathrm{right}, \mathrm{rev}, \mathrm{virt}}$,
        $\mathrm{sig}_{i, \mathrm{right}, \mathrm{rev}, \mathrm{fund}}$) to
        $\bar{P}$)}
      \Else \: \Comment{$i = n$, we are host of fundee}
      \label{code:virtual-layer:coop-close-intermediary:host-of-fundee-revoke}
        \State extract $\mathrm{sig}_{1, \mathrm{right}, R}$ from
        \texttt{left\_revocations}
        \State output (\textsc{verify revocation}, $\mathrm{sig}_{1,
        \mathrm{right}, R}$) to \texttt{fundee}
        \State \trustedcode{store received signature as $\mathrm{sig}_{\bar{P},
        R, i}$}
        \Comment{executed by \texttt{fundee}}
        \State \trustedcode{$R_{P, i} \gets$ TX \{input: $C_{\bar{P},
        i}$.outputs.$\bar{P}$, output: $(c_{\bar{P}}, \pk{P, \mathrm{out}})$\}}
        \State \trustedcode{ensure \textsc{verify}($R_{P, i}$,
        $\mathrm{sig}_{\bar{P}, R, i}$, $\pk{\bar{P}, R, i}$) = True}
        \label{code:virtual-layer:coop-close-intermediary:fundee-verify-rev}
        \For{\trustedcode{$j \in [n-1]$}}
          \IfThenElse{\trustedcode{$j = 2$}}{\trustedcode{$m \gets
          1$}}{\trustedcode{$m \gets 2$}}
          \IfThenElse{\trustedcode{$j = n-1$}}{\trustedcode{$l \gets
          n$}}{\trustedcode{$l \gets n-1$}}
          \State \trustedcode{ensure that the following signatures are present
          in \texttt{left\_revocations} and store them:} \Comment{exclude
          signatures by $j+1$ if $j = n-1$}
          \begin{itemize}
            \item \Comment{$3$ signatures}
          \end{itemize}
          \Indent
            \State \trustedcode{sig($R_{j, 1}, \pk{1, \mathrm{rev}}$),
            sig($R_{j, 1}, \pk{j, \mathrm{rev}}$), sig($R_{j, 1}, \pk{j+1,
            \mathrm{rev}}$)}
          \EndIndent
          \begin{itemize}
            \item \Comment{$3(l-m)$ signatures}
          \end{itemize}
          \Indent
            \State \trustedcode{$\forall k \in \{m, \dots, l\} \setminus
            \{i\}:$}
            \Indent
              \State \trustedcode{sig($R_{j, 2, k}, \pk{1, \mathrm{rev}}$),
              sig($R_{j, 2, k}, \pk{j, \mathrm{rev}}$), sig($R_{j, 2, k},
              \pk{j+1, \mathrm{rev}}$)}
            \EndIndent
          \EndIndent
          \begin{itemize}
            \item \Comment{$3(i-m) \cdot (l-i)$ signatures}
          \end{itemize}
          \Indent
            \State \trustedcode{$\forall k_1 \in \{m, \dots, i-1\}, \forall k_2
            \in \{i+1, \dots, l\}:$}
            \Indent
              \State \trustedcode{sig($R_{j, 3, k_1, k_2}, \pk{1,
              \mathrm{rev}}$), sig($R_{j, 3, k_1, k_2}, \pk{j, \mathrm{rev}}$),
              sig($R_{j, 3, k_1, k_2}, \pk{j+1, \mathrm{rev}}$)}
            \EndIndent
          \EndIndent
        \EndFor
        \State \trustedcode{$\itistate \gets \textsc{coop closed}$}
        \label{code:virtual-layer:coop-close-intermediary:fundee-coop-closed}
        \If{$\texttt{close\_initiator} = P$} \Comment{\environment instructed us
        to close the channel}
          \State execute code of Fig.~\ref{code:ln:coop-closed-to-initiator}
        \Else \: \Comment{\environment instructed another party to close the
        channel}
          \State \trustedcode{send (\textsc{coopClosed}) to
          \texttt{close\_initiator}}
        \EndIf
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:coop-close-intermediary}
\end{center} \ \\

\begin{center}
  \begin{processbox}{\textsc{virt} -- punishment handling}
    \ \\
    \begin{algorithmic}[1]
      \State On input (\textsc{used revocation}) by \texttt{guest}:
      \Comment{(\textsc{used revocation}) by \texttt{funder}/\texttt{fundee} is
      ignored}
      \label{code:virtual-layer:punishment:when-punished-1}
      \Indent
        \State $\textit{State} \gets \textsc{guest punished}$
        \State input (\textsc{used revocation}) to $\texttt{host}_P$, expect
        reply (\textsc{used revocation ok})
        \If{\texttt{funder} or \texttt{fundee} is defined}
          \State output (\textsc{enabler used revocation}) to it
        \Else \: \Comment{\texttt{sibling} is defined}
          \State output (\textsc{enabler used revocation}) to \texttt{sibling}
        \EndIf
      \EndIndent
      \Statex

      \State On input (\textsc{enabler used revocation}) by \texttt{sibling}:
      \Indent
        \State $\textit{State} \gets \textsc{guest punished}$
        \State output (\textsc{enabler used revocation}) to \texttt{guest}
      \EndIndent
      \Statex

      \State On output (\textsc{used revocation}) by $\texttt{host}_P$:
      \label{code:virtual-layer:punishment:when-punished-2}
      \Indent
        \State $\itistate \gets \textsc{guest punished}$
        \If{\texttt{funder} or \texttt{fundee} is defined}
          \State output (\textsc{enabler used revocation}) to it
        \Else \: \Comment{\texttt{sibling} is defined}
          \State output (\textsc{enabler used revocation}) to \texttt{sibling}
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \captionof{figure}{}
  \label{code:virtual-layer:punishment}
\end{center}
