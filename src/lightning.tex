\begin{figure}[H]
  \begin{systembox}{\textsc{ln}}
    \begin{algorithmic}[1]
      \State \textsc{init}():
      \Indent
        \State \TODO{}
      \EndIndent
      \Statex

      \State \textsc{topUp}(\alice):
      \Indent
        \State $(sk_{\mathrm{in}}, pk_{\mathrm{in}}) \gets \textsc{keyGen}()$
        \State output (\textsc{public key}, $pk_{\mathrm{in}}$) to \alice,
        wait\footnote{all other messages by \alice are ignored} for input
        (\textsc{check top up}) by \alice
        \State input (\textsc{read}) to \ledger as \alice and assign ouput to
        $\Sigma$
        \State ensure $\exists \mathrm{tx} \in \Sigma, c_{\mathrm{in}}:
        (c_{\mathrm{in}}, pk_{\mathrm{in}}) \in \mathrm{tx.outputs}$ and assign
        this output to \texttt{base\_output}, else go back to waiting for
        \textsc{check top up} by \alice
        \State return (\textsc{ok})
      \EndIndent
      \Statex

      \State \textsc{open}(\texttt{args}):
      \Indent
        \State ensure \texttt{args} can be parsed as ($c_F$, $pk_{A,
        \mathrm{out}}$, $pk_{B, \mathrm{out}}$)
        \State ensure $c_F = c_{\mathrm{in}}$
        \State $(sk_{A, F}, pk_{A, F}) \gets \textsc{keyGen}()$; $(sk_{B, F},
        pk_{B, F}) \gets \textsc{keyGen}()$
        \State $F \gets$ TX \{input: \texttt{base\_output}, output: $(c_F,
        2/\{pk_{A, F}, pk_{B, F}\})$\}
        \State $\mathrm{sig}_F \gets \textsc{sign}(F, sk)$
        \State send $(\textsc{open}, c_F, pk_{A, \mathrm{out}}, pk_{B,
        \mathrm{out}}, F, \mathrm{sig}_F, \alice)$ to \adversary, wait for
        input (\textsc{check funding}) by \alice
        \State input (\textsc{read}) to \ledger as \alice and assign output to
        $\Sigma$
        \State ensure $F \in \Sigma$
        \State return (\textsc{ok}, $c_F$)
      \EndIndent
      \Statex

      \State \textsc{virtualOpen}($c$, \texttt{keys}):
      \Indent
        \State $(sk_{A, V}, pk_{A, V}) \gets \textsc{keyGen}()$; $(sk_{B, V},
        pk_{B, V}) \gets \textsc{keyGen}()$
        \State \TODO{continue}
        \State send (\textsc{open virtual}, $c$, \bob, \charlie, \alice) to
        \adversary and ensure reply is \textsc{(ok)}
        \State return (\textsc{ok})
      \EndIndent
      \Statex

      \State \textsc{close}($P$):
      \Indent
        \TODO{continue (maybe move to virtual layer?)}
        \TODO{handle arbitrarily nested virtuals (now we only handle one level
        and it leads to nested ifs}
        \If{both channel parties are honest}
          \If{$\mathtt{funded} \neq \emptyset$}
            \State \TODO{prepare virtual layer TX $V$ and its signature --
            careful, may be unneded!}
            \State $C \gets$ TX \{input: $V$.output, outputs: $(c_A, pk_{A,
            \mathrm{out}} \wedge t), (c_B, pk_{B, \mathrm{out}})$\}
            \State $\mathrm{sig}_{B, C} \gets \textsc{sign}(C, sk_{B, V})$
            \State $\mathrm{sig}_{A, C} \gets \textsc{sign}(C, sk_{A, V})$
          \Else
            \State $C \gets$ TX \{input: $F$.output, outputs: $(c_A, pk_{A,
            \mathrm{out}} \wedge t), (c_B, pk_{B, \mathrm{out}})$\}
            \State $\mathrm{sig}_{B, C} \gets \textsc{sign}(C, sk_{B, F})$
            \State $\mathrm{sig}_{A, C} \gets \textsc{sign}(C, sk_{A, F})$
          \EndIf
        \EndIf \: \Comment{if \bob is corrupted, we already have $C$ and
        $\mathrm{sig}_{B, C}$}
        \State $\mathit{State} \gets \textsc{closed}$
        \If{$\mathit{State} = \textsc{open base}$}
          \State input (\textsc{submit}, $(V, \mathrm{sig}_{A, V},
          \mathrm{sig}_{B, V})$, $(C, \mathrm{sig}_{A, C}, \mathrm{sig}_{B,
          C})$) to \ledger
        \Else \: \Comment{$\mathit{State} = \textsc{open virtual}$}
          \If{\alice is the one that had received (\textsc{open virtual}, $\dots$)
          by \texttt{opener}}
            \State $\texttt{initiator} \gets \texttt{opener}$; $\texttt{other}
            \gets \texttt{outer\_peer}$
          \Else \: \Comment{\bob had received (\textsc{open virtual} $\dots$)}
            \State $\texttt{initiator} \gets \texttt{outer\_peer}$;
            $\texttt{other} \gets \texttt{opener}$
          \EndIf
          \If{both parties are honest}
            \If{$\texttt{funded} \neq \emptyset$}
              \State \TODO{prepare virtual layer TXs $V_A, V_B$ and their
              signatures}
              \State $C' \gets$ TX \{input: $V$.output, outputs: $(c_A, pk_{A,
              \mathrm{out}}), (c_B, pk_{B, \mathrm{out}} \wedge t)$\}
              \State $\mathrm{sig}_{A, C}' \gets \textsc{sign}(C', sk_{A, V})$;
              $\mathrm{sig}_{B, C}' \gets \textsc{sign}(C', sk_{B, V})$
            \Else \: \Comment{there are no virtual channels on top of us}
              \State $C' \gets$ TX \{input: $F$.output, outputs: $(c_A, pk_{A,
              \mathrm{out}}), (c_B, pk_{B, \mathrm{out}} \wedge t)$\}
              \State $\mathrm{sig}_{A, C}' \gets \textsc{sign}(C', sk_{A, F})$;
              $\mathrm{sig}_{B, C}' \gets \textsc{sign}(C', sk_{B, F})$
            \EndIf
            \State provide delayed output (\textsc{peer closed virtual}, $(V_B,
            \mathrm{sig}_{A, V_B}, \mathrm{sig}_{B, V_B})$, $(C',
            \mathrm{sig}_{A, C}', \mathrm{sig}_{B, C}')$) to \texttt{other} as
            \bob
          \EndIf
          \If{$\mathtt{funded} \neq \emptyset$}
            \State $\mathtt{output} \gets (\textsc{closed virtual}, (V,
            \mathrm{sig}_{A, V}, \mathrm{sig}_{B, V}), (C, \mathrm{sig}_{A, C},
            \mathrm{sig}_{B, C}))$
          \Else
            \State $\mathtt{output} \gets (\textsc{closed virtual}, (C,
            \mathrm{sig}_{A, C}, \mathrm{sig}_{B, C}))$
          \EndIf
          \State output \texttt{output} to \texttt{initiator} as \alice
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:ln}
\end{figure}
