\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- init}
    \begin{algorithmic}[1]
      \State \Comment{When not specified, input comes from and output goes to
      \environment.}
      \State \Comment{The ITI knows whether it is \alice (funder) or \bob
      (fundee). The activated party is $P$ and the counterparty is $\bar{P}$.}
      \State On every activation, before handling the message:
      \Indent
        \If{$\texttt{last\_poll} \neq \bot$} \Comment{channel has opened}
          \State input (\textsc{read}) to \ledger and assign ouput to $\Sigma$
          \If{$\texttt{last\_poll} + t < |\Sigma|$}
            \State $\texttt{negligent} \gets$ True
            \label{code:ln:init:negligent}
          \EndIf
        \EndIf
      \EndIndent
      \Statex

      \State On (\textsc{init}, $\pk{P, \mathrm{out}}$):
      \Indent
        \State ensure $\itistate = \bot$
        \State $\itistate \gets \textsc{init}$
        \State store $\pk{P, \mathrm{out}}$
        \State $(c_A, c_B, \texttt{locked}_A, \texttt{locked}_B) \gets (0, 0, 0,
        0)$
        \State $(\texttt{paid\_out}, \texttt{paid\_in}) \gets (\emptyset,
        \emptyset)$
        \State $\texttt{negligent} \gets$ False
        \State $\texttt{last\_poll} \gets \bot$
        \State output (\textsc{init ok})
      \EndIndent
      \Statex

      \State On (\textsc{top up}):
      \Indent
        \State ensure $P = \alice$ \Comment{activated party is the funder}
        \State ensure $\itistate = \textsc{init}$
        \label{code:ln:init:change-state}
        \State $(\sk{P, \mathrm{chain}}, \pk{P, \mathrm{chain}}) \gets
        \textsc{keyGen}()$
        \State input (\textsc{read}) to \ledger and assign ouput to $\Sigma$
        \State output (\textsc{top up to}, $\pk{P, \mathrm{chain}}$)
        \While{$\nexists \mathrm{tx} \in \Sigma, c_{P, \mathrm{chain}}: (c_{P,
        \mathrm{chain}}, \pk{P, \mathrm{chain}}) \in \mathrm{tx.outputs}$}
          \State \Comment{while waiting, all other messages by $P$ are ignored}
          \State wait for input (\textsc{check top up})
          \State input (\textsc{read}) to \ledger and assign ouput to $\Sigma$
        \EndWhile
        \State $\itistate \gets \textsc{topped up}$
        \State output (\textsc{top up ok}, $c_{P, \mathrm{chain}}$)
      \EndIndent
      \Statex

      \State On (\textsc{balance}):
      \Indent
        \State ensure $\mathit{State}^P \in \{\textsc{open}, \textsc{closed}\}$
        \label{code:functionality:chan:skeleton:base:balance:start}
        \State output (\textsc{balance}, $c_A, c_B, \texttt{locked}_A,
        \texttt{locked}_B$)
        \label{code:functionality:chan:skeleton:base:balance:end}
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:init}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- methods used by \textsc{virt}}
    \begin{algorithmic}[1]
      \State \textsc{revokePrevious}():
      \Indent
        \State ensure $\itistate \in \textsc{waiting for (outbound)
        revocation}$
        \State $R_{\bar{P}, i} \gets$ TX \{input: $C_{P, i}$.outputs.$P$,
        output: ($C_{P, i}$.outputs.$P$.value, $pk_{\bar{P}, \mathrm{out}}$)\}
        \State $\mathrm{sig}_{A, R, i} \gets \textsc{sign}(R_{\bar{P}, i},
        \sk{P, R})$
        \If{$\itistate = \textsc{waiting for revocation}$}
          \State $\itistate \gets \textsc{waiting for inbound revocation}$
        \Else \: \Comment{$\itistate = \textsc{waiting for outbound
        revocation}$}
          \State $i \gets i + 1$
          \State $\itistate \gets \textsc{waiting for hosts ready}$
        \EndIf
        \State $\texttt{host}_P \gets \texttt{host}_P'$ \Comment{forget old
        host, use new host instead}
        \State $\texttt{layer} \gets \texttt{layer} + 1$
        \label{code:ln:methods-for-virt:host-update}
        \State \Return $\mathrm{sig}_{P, R, i}$
      \EndIndent
      \Statex

      \State \textsc{processRemoteRevocation}($\mathrm{sig}_{\bar{P}, R, i}$):
      \Indent
        \State ensure $\itistate = \textsc{waiting for (inbound)
        revocation}$
        \State $R_{P, i} \gets$ TX \{input: $C_{\bar{P}, i}$.outputs.$P$,
        output: ($C_{\bar{P}, i}$.outputs.$\bar{P}$.value, $pk_{P,
        \mathrm{out}}$)\}
        \State ensure \textsc{verify}($R_{P, i}$, $\mathrm{sig}_{\bar{P}, R,
        i}$, $\pk{\bar{P}, R}$) = True
        \If{$\itistate = \textsc{waiting for revocation}$}
          \State $\itistate \gets \textsc{waiting for outbound
          revocation}$
        \Else \: \Comment{$\itistate = \textsc{waiting for inbound
        revocation}$}
          \State $i \gets i + 1$
          \State $\itistate \gets \textsc{waiting for hosts ready}$
        \EndIf
        \State \Return (\textsc{ok})
      \EndIndent
      \Statex

      \State \textsc{negligent}():
      \Indent
        \State $\texttt{negligent} \gets$ True
        \label{code:ln:methods-for-virt:negligent}
        \State \Return (\textsc{ok})
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:methods-for-virt}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln.exchangeOpenKeys}()}
    \begin{algorithmic}[1]
      \State $(\sk{A, F}, \pk{A, F}) \gets \textsc{keyGen}()$;
      $(\sk{A, R}, \pk{A, R}) \gets \textsc{keyGen}()$
      \State $\itistate \gets \textsc{waiting for opening keys}$
      \State send (\textsc{open}, $c$, \texttt{hops}, $\pk{A, F}$, $\pk{A, R}$,
      $\pk{A, \mathrm{out}}$) to \texttt{fundee}
      \label{code:ln:exchange-open-keys:bob-open}
      \State \Comment{colored code is run by honest \texttt{fundee}.
      Validation is implicit}
      \State \remotecode{ensure we run the code of \bob}
      \State \remotecode{ensure $\itistate = \textsc{init}$}
      \State \remotecode{store $\pk{A, F}$, $\pk{A, R}$, $\pk{A,
      \mathrm{out}}$}
      \State \remotecode{$(\sk{B, F}, \pk{B, F}) \gets \textsc{keyGen}()$;
      $(\sk{B, R}, \pk{B, R}) \gets \textsc{keyGen}()$}
      \If{\remotecode{\texttt{hops} = \ledger}} \Comment{opening base
      channel}
        \State \remotecode{$\texttt{layer} \gets 0$}
        \State \remotecode{$\itistate \gets \textsc{waiting for comm
        sig}$}
      \Else \: \Comment{opening virtual channel}
        \State \remotecode{$\itistate \gets \textsc{waiting for
        check keys}$}
      \EndIf
      \State \remotecode{reply (\textsc{accept channel}, $\pk{B, F}$,
      $\pk{B, R}$, $\pk{B, \mathrm{out}}$)}
      \State ensure $\itistate = \textsc{waiting for opening keys}$
      \State store $\pk{B, F}$, $\pk{B, R}$, $\pk{B, \mathrm{out}}$
      \State $\itistate \gets \textsc{opening keys ok}$
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:exchange-open-keys}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln.prepareBase}()}
    \begin{algorithmic}[1]
      \If{\texttt{hops} = \ledger} \Comment{opening base channel}
        \State $F \gets$ TX \{input: $(c, \pk{A, \mathrm{chain}})$, output: $(c,
        \texttt{3} \wedge 2/\{\pk{A, F}, \pk{B, F}\})$\}
        \label{code:ln:base:create-funding}
        \State $\texttt{host}_P \gets \ledger$
        \State $\texttt{layer} \gets 0$
      \Else \: \Comment{opening virtual channel}
        \State input (\textsc{fund me}, \alice, \bob, \texttt{hops}, $c$,
        $\pk{A, F}$, $\pk{B, F}$) to \texttt{hops}[0].\texttt{left} and expect
        output (\textsc{funded}, $\texttt{host}_P$, \texttt{funder\_layer})
        \Comment{ignore any other message}
        \label{code:ln:prepare-base:fund-me}
        \State $\texttt{layer} \gets \texttt{funder\_layer}$
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:prepare-base}
\end{figure}


\begin{figure}[H]
  \begin{processbox}{\textsc{ln.exchangeOpenSigs}()}
    \begin{algorithmic}[1]
      \State \Comment{$s = (2 + \lceil \texttt{maxTime}_{\texttt{window}} +
      \frac{\texttt{Delay}}{2} /
      \texttt{minTime}_{\texttt{window}}\rceil)\texttt{windowSize}$, where
      $\texttt{maxTime}_{\texttt{window}}$, \texttt{Delay},
      $\texttt{minTime}_{\texttt{window}}$ and \texttt{windowSize} are defined
      in Proposition~\ref{ledger:delay}} \TODO{recheck and include proposition}
      \State $C_{A, 0} \gets$ TX \{input: $(c, \texttt{3} \wedge 2/\{\pk{A, F},
      \pk{B, F}\})$, outputs: ($c$, ($\pk{A, \mathrm{out}} + (t + s)$) $\vee$
      $2/\{\pk{A, R}, \pk{B, R}\}$), ($0$, $\pk{B, \mathrm{out}}$)\}
      \State $C_{B, 0} \gets$ TX \{input: $(c, \texttt{3} \wedge 2/\{\pk{A, F},
      \pk{B, F}\})$, outputs: ($c$, $\pk{A, \mathrm{out}}$), ($0$, ($\pk{B,
      \mathrm{out}} + (t + s)$) $\vee$ $2/\{\pk{A, R}, \pk{B, R}\}$)\}
      \State $\mathrm{sig}_{A, C, 0} \gets \textsc{sign}(C_{B, 0}, \sk{A, F})$
      \State $\itistate \gets \textsc{waiting for comm sig}$
      \State send (\textsc{funding created}, $(c, \pk{A, \mathrm{chain}})$,
      $\mathrm{sig}_{A, C, 0}$) to \texttt{fundee}
      \State \remotecode{ensure $\itistate = \textsc{waiting for comm
      sig}$} \Comment{if opening virtual channel, we have received
      (\textsc{funded}, \texttt{host\_fundee}) by
      \texttt{hops}[-1].\texttt{right} (Fig~\ref{code:ln:bob},
      l.~\ref{code:ln:bob:host})}
      \If{\remotecode{\texttt{hops} = \ledger}} \Comment{opening base channel}
        \State \remotecode{$F \gets$ TX \{input: $(c, \pk{A, \mathrm{chain}})$,
        output: $(c, \texttt{3} \wedge 2/\{\pk{A, F}, \pk{B, F}\})$\}}
      \EndIf
      \State \remotecode{$C_{B, 0} \gets$ TX \{input: $(c, \texttt{3} \wedge
      2/\{\pk{A, F}, \pk{B, F}\})$, outputs: ($c$, $\pk{A, \mathrm{out}}$),
      ($0$, ($\pk{B, \mathrm{out}} + (t + s)$) $\vee$ $2/\{\pk{A, R}, \pk{B,
      R}\}$)\}}
      \State \remotecode{ensure \textsc{verify}($C_{B, 0}$, $\mathrm{sig}_{A, C,
      0}$, $\pk{A, F}$) = True}
      \label{code:ln:exchange-open-sigs:b-verify}
      \State \remotecode{$C_{A, 0} \gets$ TX \{input: $(c, \texttt{3} \wedge
      2/\{\pk{A, F}, \pk{B, F}\})$, outputs: ($c$, ($\pk{A, \mathrm{out}} + (t +
      s)$)
      $\vee$ $2/\{\pk{A, R}, \pk{B, R}\}$), ($0$, $\pk{B, \mathrm{out}}$)\}}
      \State \remotecode{$\mathrm{sig}_{B, C, 0} \gets \textsc{sign}(C_{A, 0},
      \sk{B, F})$}
      \If{\remotecode{\texttt{hops} = \ledger}} \Comment{opening base channel}
        \State \remotecode{$\itistate \gets \textsc{waiting to check
        funding}$}
      \Else \: \Comment{opening virtual channel}
        \State \remotecode{$c_A \gets c$; $c_B \gets 0$; $i \gets 0$}
        \State \remotecode{$\itistate \gets \textsc{open}$}
        \label{code:ln:exchange-open-sigs:state-open}
      \EndIf
      \State \remotecode{reply (\textsc{funding signed}, $\mathrm{sig}_{B, C,
      0}$)}
      \State ensure $\itistate = \textsc{waiting for comm sig}$
      \State ensure \textsc{verify}($C_{A, 0}$, $\mathrm{sig}_{B, C, 0}$,
      $\pk{B, F}$) = True
      \label{code:ln:exchange-open-sigs:a-verify}
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:exchange-open-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln.commitBase}()}
    \begin{algorithmic}[1]
      \State $\mathrm{sig}_F \gets \textsc{sign}(F, \sk{A, \mathrm{chain}})$
      \label{code:ln:base:sign-funding}
      \State send $(\textsc{open}, c, \pk{A, \mathrm{out}}, \pk{B,
      \mathrm{out}}, F, \mathrm{sig}_F, \alice, \bob)$ to \adversary
      \While{$F \notin \Sigma$}
      \label{code:ln:commit-base:f-in-state}
        \State wait for input (\textsc{check funding}) \Comment{ignore all other
        messages}
        \State input (\textsc{read}) to \ledger and assign output to $\Sigma$
      \EndWhile
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:commit-base}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- external open messages for \bob}
    \begin{algorithmic}[1]
      \State On input (\textsc{check funding}):
      \Indent
        \State ensure $\itistate = \textsc{waiting to check funding}$
        \State input (\textsc{read}) to \ledger and assign output to $\Sigma$
        \If{$F \in \Sigma$}
          \State $\itistate \gets \textsc{open}$
          \label{code:ln:bob:state-open}
          \State reply (\textsc{open ok})
        \EndIf
      \EndIndent
      \Statex

      \State On output (\textsc{funded}, $\texttt{host}_P$,
      \texttt{funder\_layer}) by \texttt{hops}[-1].\texttt{right}:
      \label{code:ln:bob:funded}
      \Indent
        \State ensure $\itistate = \textsc{waiting for funded}$
        \State store $\texttt{host}_P$ \Comment{we will talk directly to
        $\texttt{host}_P$}
        \label{code:ln:bob:host}
        \State $\texttt{layer} \gets \texttt{funder\_layer}$
        \State $\itistate \gets \textsc{waiting for comm sig}$
        \State reply (\textsc{fund ack})
      \EndIndent
      \Statex

      \State On output (\textsc{check keys}, ($\pk{1}$, $\pk{2}$)) by
      \texttt{hops}[-1].\texttt{right}:
      \Indent
        \State ensure $\itistate = \textsc{waiting for check keys}$
        \State ensure $\pk{1} = \pk{A, F} \wedge \pk{2} = \pk{B, F}$
        \State $\itistate \gets \textsc{waiting for fudned}$
        \State reply (\textsc{keys ok})
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:bob}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- On (\textsc{open}, $c$, \texttt{hops},
  \texttt{fundee}):}
    \begin{algorithmic}[1]
      \State \Comment{\texttt{fundee} is \bob}
      \label{code:ln:open:alice-open}
      \State ensure we run the code of \alice{} \Comment{activated party is the
      funder}
      \If{\texttt{hops} = \ledger} \Comment{opening base channel}
        \State ensure $\itistate = \textsc{topped up}$
        \State ensure $c = c_{A, \mathrm{chain}}$
      \Else \: \Comment{opening virtual channel}
        \State ensure $\mathrm{len}(\texttt{hops}) \geq 2$ \Comment{cannot open
        a virtual over 1 channel}
      \EndIf
      \State \textsc{ln.exchangeOpenKeys}()
      \State \textsc{ln.prepareBase}()
      \State \textsc{ln.exchangeOpenSigs}()
      \If{\texttt{hops} = \ledger}
        \State \textsc{ln.commitBase}()
      \EndIf
      \State input (\textsc{read}) to \ledger and assign output to $\Sigma$
      \State $\texttt{last\_poll} \gets |\Sigma|$
      \State $c_A \gets c$; $c_B \gets 0$; $i \gets 0$
      \State $\itistate \gets \textsc{open}$
      \label{code:ln:open:state-open}
      \State output (\textsc{open ok}, $c$, \texttt{fundee}, \texttt{hops})
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:open}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln}.\textsc{updateForVirtual}()}
    \begin{algorithmic}[1]
      \State $C_{\bar{P}, i+1} \gets C_{\bar{P}, i}$ with $\pk{P, F}'$ and
      $\pk{\bar{P}, F}'$ instead of $\pk{P, F}$ and $\pk{\bar{P}, F}$
      respectively
      \State $\mathrm{sig}_{P, C, i+1} \gets \textsc{sign}(C_{\bar{P}, i+1})$
      \Comment{kept by $\bar{P}$}
      \State send (\textsc{update forward}, $\mathrm{sig}_{P, C, i+1}$) to
      $\bar{P}$ \State \Comment{$P$ refers to payer and $\bar{P}$ to payee both
      in local and remote code}
      \State \remotecode{$C_{\bar{P}, i+1} \gets C_{\bar{P}, i}$ with $\pk{P,
      F}'$ and $\pk{\bar{P}, F}'$ instead of $\pk{P, F}$ and $\pk{\bar{P}, F}$
      respectively}
      \State \remotecode{ensure \textsc{verify}($C_{\bar{P}, i+1}$,
      $\mathrm{sig}_{P, C, i+1}$, $\pk{P, F}'$) = True}
      \State \remotecode{$C_{P, i+1} \gets C_{P, i}$ with $\pk{\bar{P}, F}'$ and
      $\pk{P, F}'$ instead of $\pk{\bar{P}, F}$ and $\pk{P, F}$ respectively}
      \State \remotecode{$\mathrm{sig}_{\bar{P}, C, i+1} \gets
      \textsc{sign}(C_{P, i+1}, sk_{\bar{P}, F}')$} \Comment{kept by $P$}
      \State \remotecode{reply (\textsc{update back}, $\mathrm{sig}_{\bar{P}, C,
      i+1}$)}
      \State $C_{P, i+1} \gets C_{P, i}$ with $\pk{\bar{P}, F}'$ and $\pk{P,
      F}'$ instead of $\pk{\bar{P}, F}$ and $\pk{P, F}$ respectively
      \State ensure \textsc{verify}($C_{P, i+1}$, $\mathrm{sig}_{\bar{P}, C,
      i+1}$, $\pk{\bar{P}, F}'$) = True
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:open:virtual-update}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- virtualise start and end}
    \begin{algorithmic}[1]
      \State On input (\textsc{fund me}, $c_{\mathrm{guest}}$, \texttt{fundee},
      \texttt{hops}, $\pk{A, V}$, $\pk{B, V}$) by \texttt{funder}:
      \Indent
        \State ensure $\itistate = \textsc{open}$
        \State ensure $c_P - \texttt{locked}_P \geq c_{\mathrm{guest}}$
        \State $\itistate \gets \textsc{virtualising}$
        \State $(\sk{P, F}', \pk{P, F}') \gets \textsc{keyGen}()$
        \State define new \textsc{virt} ITI $\texttt{host}_P'$
        \State send (\textsc{virtualising}, $\texttt{host}_P'$, $\pk{P, F}'$,
        \texttt{hops}, \texttt{fundee}, $c_{\mathrm{guest}}$) to $\bar{P}$ and
        expect reply (\textsc{virtualising ack}, $\texttt{host}_{\bar{P}}'$,
        $\pk{\bar{P}, F}'$)
        \State ensure $\pk{\bar{P}, F}'$ is different from $\pk{\bar{P}, F}$ and
        all older $\bar{P}$'s funding public keys
        \State \textsc{ln}.\textsc{updateForVirtual}()
        \State $\itistate \gets \textsc{waiting for revocation}$
        \State input (\textsc{host me}, \texttt{funder}, \texttt{fundee},
        $\texttt{host}_{\bar{P}}'$, $\texttt{host}_P$, $c_{\mathrm{guest}}$,
        $\pk{A, V}$, $\pk{B, V}$, ($\sk{P, F}'$, $\pk{P, F}'$), ($\sk{P, F}$,
        $\pk{P, F}$), $\pk{\bar{P}, F}$, $\pk{\bar{P}, F}'$) to
        $\texttt{host}_P'$
      \EndIndent
      \Statex

      \State On output (\textsc{hosts ready}) by $\texttt{host}_P$:
      \Comment{$\texttt{host}_P$ is the new host, renamed in
      Fig.~\ref{code:ln:methods-for-virt},
      l.~\ref{code:ln:methods-for-virt:host-update}}
      \label{code:ln:virtualise:start-end:hosts-ready}
      \Indent
        \State ensure $\itistate = \textsc{waiting for hosts ready}$
        \State $\itistate \gets \textsc{open}$
        \State move $\pk{P, F}$, $\pk{\bar{P}, F}$ to list of old funding keys
        \State $(\sk{P, F}, \pk{P, F}) \gets (\sk{P, F}', \pk{P, F}')$;
        $\pk{\bar{P}, F} \gets \pk{\bar{P}, F}'$
        \If{len(\texttt{hops}) = 1} \Comment{we are the last hop}
          \State output (\textsc{funded}, $\texttt{host}_P$, $\texttt{layer}$)
          to \texttt{fundee} and expect reply (\textsc{fund ack})
        \ElsIf{we have received input \textsc{fund me} just before we moved to
        the \textsc{virtualising} state} \Comment{we are the first hop}
          \State $c_P \gets c_P - c_{\mathrm{guest}}$
          \label{code:ln:virtualise:start-end:reduce-coins}
          \State output (\textsc{funded}, $\texttt{host}_P$, $\texttt{layer}$)
          to \texttt{funder} \Comment{do not expect reply by \texttt{funder}}
        \EndIf
        \State reply (\textsc{host ack})
      \EndIndent
      \Statex

      \State On output (\textsc{sign TXs}, TXs) by $\texttt{host}'_P$:
      \Indent
        \State $\mathrm{sigs} \gets \emptyset$
        \For{TX in TXs}
          \State add \textsc{sign}(TX, $\sk{P, F}$, \textsc{anyprevout}) to sigs
        \EndFor
        \State reply (\textsc{TXs signed}, sigs)
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:virtualise:start-end}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- virtualise hops}
    \begin{algorithmic}[1]
      \State On (\textsc{virtualising}, $\texttt{host}_{\bar{P}}'$,
      $\pk{\bar{P}, F}'$, \texttt{hops}, \texttt{fundee}, $c_{\mathrm{guest}}$)
      by $\bar{P}$:
      \Indent
        \State ensure $\itistate = \textsc{open}$
        \State ensure $c_{\bar{P}} - \texttt{locked}_{\bar{P}} \geq c$
        \State ensure $\pk{\bar{P}, F}'$ is different from $\pk{\bar{P}, F}$ and
        all older $\bar{P}$'s funding public keys
        \State $\itistate \gets \textsc{virtualising}$
        \State $\texttt{locked}_{\bar{P}} \gets \texttt{locked}_{\bar{P}} + c$
        \Comment{if $\bar{P}$ is hosting the \texttt{funder}, $\bar{P}$ will
        transfer $c_{\mathrm{guest}}$ coins instead of locking them, but the end
        result is the same}
        \State $(\sk{P, F}', \pk{P, F}') \gets \textsc{keyGen}()$
        \If{$\mathrm{len}(\texttt{hops}) > 1$} \Comment{we are not the last hop}
          \State define new \textsc{virt} ITI $\texttt{host}_P'$
          \State input (\textsc{virtualising}, $\texttt{host}_P'$, ($\sk{P,
          F}'$, $\pk{P, F}'$), $\pk{\bar{P}, F}'$, \texttt{hops}[1:],
          \texttt{fundee}, $c_{\mathrm{guest}}$, $c_{\bar{P}}$, $c_P$) to
          \texttt{hops}[1].\texttt{left} and expect reply (\textsc{virtualising
          ack}, \texttt{host\_sibling}, $\pk{\mathrm{sib}, \bar{P}, F}$)
          \State input (\textsc{init}, $\texttt{host}_P$,
          $\texttt{host}_{\bar{P}}'$, \texttt{host\_sibling}, ($\sk{P, F}'$,
          $\pk{P, F}'$), $\pk{\bar{P}, F}'$, $\pk{\mathrm{sib}, \bar{P}, F}$,
          ($\sk{P, F}$, $\pk{P, F}$), $\pk{\bar{P}, F}$, $c_{\mathrm{guest}}$)
          to $\texttt{host}_P'$ and expect reply (\textsc{host init ok})
        \Else \: \Comment{we are the last hop}
          \State input (\textsc{init}, $\texttt{host}_P$,
          $\texttt{host}_{\bar{P}}'$, \texttt{fundee}=\texttt{fundee}, ($\sk{P,
          F}'$, $\pk{P, F}'$), $\pk{\bar{P}, F}'$, ($\sk{P, F}$, $\pk{P, F}$),
          $\pk{\bar{P}, F}$, $c_{\mathrm{guest}}$) to new \textsc{virt} ITI
          $\texttt{host}_P'$ and expect reply (\textsc{host init ok})
        \EndIf
        \State $\itistate \gets \textsc{waiting for revocation}$
        \State send (\textsc{virtualising ack}, $\texttt{host}_P'$, $\pk{P, F}'$)
        to $\bar{P}$
      \EndIndent
      \Statex

      \State On input (\textsc{virtualising}, \texttt{host\_sibling}, ($\sk{P,
      F}'$, $\pk{P, F}'$), $\pk{\mathrm{sib}, \bar{P}, F}$, \texttt{hops},
      \texttt{fundee}, $c_{\mathrm{guest}}$, $c_{\mathrm{sib}, \mathrm{rem}}$,
      $_{\mathrm{sib}}$) by \texttt{sibling}:
      \Indent
        \State ensure $\itistate = \textsc{open}$
        \State ensure $c_P - \texttt{locked}_P \geq c$
        \State ensure $c_{\mathrm{sib}, \mathrm{rem}} \geq c_P \wedge
        c_{\bar{P}} \geq c_{\mathrm{sib}}$ \Comment{avoid value loss by griefing
        attack: one counterparty closes with old version, the other stays idle
        forever}
        \State $\itistate \gets \textsc{virtualising}$
        \State $\texttt{locked}_P \gets \texttt{locked}_P + c$
        \State define new \textsc{virt} ITI $\texttt{host}_P'$
        \State send (\textsc{virtualising}, $\texttt{host}_P'$, $\pk{P, F}'$,
        \texttt{hops}, \texttt{fundee}, $c_{\mathrm{guest}}$) to
        \texttt{hops}[0].\texttt{right} and expect reply (\textsc{virtualising
        ack}, $\texttt{host}_{\bar{P}}'$, $\pk{\bar{P}, F}'$)
        \State ensure $\pk{\bar{P}, F}'$ is different from $\pk{\bar{P}, F}$ and
        all older $\bar{P}$'s funding public keys
        \State \textsc{ln}.\textsc{updateForVirtual}()
        \State input (\textsc{init}, $\texttt{host}_P$,
        $\texttt{host}_{\bar{P}}'$, \texttt{host\_sibling}, ($\sk{P, F}'$,
        $\pk{P, F}'$), $\pk{\bar{P}, F}'$, $\pk{\mathrm{sib}, \bar{P}, F}$,
        ($\sk{P, F}$, $\pk{P, F}$), $\pk{\bar{P}, F}$, $c_{\mathrm{guest}}$) to
        $\texttt{host}_P'$ and expect reply (\textsc{host init ok})
        \State $\itistate \gets \textsc{waiting for revocation}$
        \State output (\textsc{virtualising ack}, $\texttt{host}_P'$,
        $\pk{\bar{P}, F}'$) to \texttt{sibling}
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:open:virtualise:hops}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln}.\textsc{signaturesRoundTrip}()}
    \begin{algorithmic}[1]
      \State $C_{\bar{P}, i+1} \gets C_{\bar{P}, i}$ with $x$ coins moved from
      $P$'s to $\bar{P}$'s output
      \State $\mathrm{sig}_{P, C, i+1} \gets \textsc{sign}(C_{\bar{P}, i+1},
      \sk{P, F})$ \Comment{kept by $\bar{P}$}
      \State send (\textsc{pay}, $x$, $\mathrm{sig}_{P, C, i+1}$) to $\bar{P}$
      \State \Comment{$P$ refers to payer and $\bar{P}$ to payee both in local
      and remote code}
      \State \remotecode{ensure \texttt{State} = \textsc{open}}
      \If{\remotecode{$\texttt{host}_{\bar{P}} \neq \ledger \wedge \bar{P}$
      has a \texttt{host\_sibling}}} \Comment{we are intermediary channel}
        \State \remotecode{ensure $c_{\mathrm{sib}, \mathrm{rem}} \geq c_P - x
        \wedge c_{\bar{P}} + x \geq c_{\mathrm{sib}}$} \Comment{avoid value
        loss by griefing attack}
      \EndIf
      \State \remotecode{$C_{\bar{P}, i+1} \gets C_{\bar{P}, i}$ with $x$
      coins moved from $P$'s to $\bar{P}$'s output}
      \State \remotecode{ensure \textsc{verify}($C_{\bar{P}, i+1}$,
      $\mathrm{sig}_{P, C, i+1}$, $\pk{P, F}$) = True}
      \State \remotecode{$C_{P, i+1} \gets C_{P, i}$ with $x$ coins moved from
      $P$'s to $\bar{P}$'s output}
      \State \remotecode{$\mathrm{sig}_{\bar{P}, C, i+1} \gets
      \textsc{sign}(C_{P, i+1}, \sk{\bar{P}, F})$} \Comment{kept by $P$}
      \State \remotecode{$R_{P, i} \gets$ TX \{input: $C_{\bar{P},
      i}$.outputs.$P$, output: ($c_{\bar{P}}$, $\pk{P, \mathrm{out}}$)\}}
      \State \remotecode{$\mathrm{sig}_{\bar{P}, R, i} \gets
      \textsc{sign}(R_{P, i}, \sk{\bar{P}, R})$}
      \State \remotecode{reply (\textsc{commitment signed},
      $\mathrm{sig}_{\bar{P}, C, i+1}$, $\mathrm{sig}_{\bar{P}, R, i}$)}
      \State $C_{P, i+1} \gets C_{P, i}$ with $x$ coins moved from $P$'s to
      $\bar{P}$'s output
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:pay:signatures}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln}.\textsc{revocationsTrip}()}
    \begin{algorithmic}[1]
      \State ensure \textsc{verify}($C_{P, i+1}$, $\mathrm{sig}_{\bar{P}, C,
      i+1}$, $\pk{\bar{P}, F}$) = True
      \State $R_{P, i} \gets$ TX \{input: $C_{\bar{P}, i}$.outputs.$P$,
      output: ($c_{\bar{P}}$, $\pk{P, \mathrm{out}}$)\}
      \State ensure \textsc{verify}($R_{P, i}$, $\mathrm{sig}_{\bar{P}, R,
      i}$, $\pk{\bar{P}, R}$) = True
      \State $R_{\bar{P}, i} \gets$ TX \{input: $C_{P, i}$.outputs.$\bar{P}$,
      output: ($c_P$, $\pk{\bar{P}, \mathrm{out}}$)\}
      \State $\mathrm{sig}_{P, R, i} \gets \textsc{sign}(R_{\bar{P}, i},
      \sk{P, R})$
      \State add $x$ to \texttt{paid\_out}
      \label{code:ln:pay:revocations:paid-out}
      \State $c_P \gets c_P - x; c_{\bar{P}} \gets c_{\bar{P}} + x$; $i \gets
      i + 1$
      \If{$\texttt{host}_P \neq \ledger \wedge$ we have a
      \texttt{host\_sibling}} \Comment{we are intermediary channel}
        \State input (\textsc{new balance}, $c_P$, $c_{\bar{P}}$) to
        $\texttt{host}_P$
        \State \trustedcode{relay message as input to \texttt{sibling}}
        \Comment{run by \textsc{virt}}
        \State \trustedcode{relay message as output to \texttt{guest}}
        \Comment{run by \textsc{virt}}
        \State \trustedcode{store new sibling balance and reply (\textsc{new
        balance ok})}
        \State \trustedcode{output (\textsc{new balance ok}) to
        \texttt{sibling}}
        \Comment{run by \textsc{virt}}
        \State \trustedcode{output (\textsc{new balance ok}) to \texttt{guest}}
        \Comment{run by \textsc{virt}}
      \EndIf
      \State send (\textsc{revoke and ack}, $\mathrm{sig}_{P, R, i}$) to
      $\bar{P}$
      \State \remotecode{$R_{\bar{P}, i} \gets$ TX \{input: $C_{P,
      i}$.outputs.$\bar{P}$, output: ($c_P$, $\pk{\bar{P}, \mathrm{out}}$)\}}
      \State \remotecode{ensure \textsc{verify}($R_{\bar{P}, i}$,
      $\mathrm{sig}_{P, R, i}$, $\pk{P, R}$) = True}
      \State \remotecode{add $x$ to \texttt{paid\_in}}
      \label{code:ln:pay:revocations:paid-in}
      \State \remotecode{$c_P \gets c_P - x; c_{\bar{P}} \gets c_{\bar{P}} +
      x$; $i \gets i + 1$}
      \If{\remotecode{$\texttt{host}_P \neq \ledger \wedge \bar{P}$ has a
      \texttt{host\_sibling}}} \Comment{we are intermediary channel}
        \State \remotecode{input (\textsc{new balance}, $c_{\bar{P}}$, $c_P$)
        to $\texttt{host}_{\bar{P}}$}
        \State \remotecode{relay message as input to \texttt{sibling}}
        \Comment{run by \textsc{virt}}
        \State \remotecode{relay message as output to \texttt{guest}}
        \Comment{run by \textsc{virt}}
        \State \remotecode{store new sibling balance and reply (\textsc{new
        balance ok})}
        \State \remotecode{output (\textsc{new balance ok}) to \texttt{sibling}}
        \Comment{run by \textsc{virt}}
        \State \remotecode{output (\textsc{new balance ok}) to \texttt{guest}}
        \Comment{run by \textsc{virt}}
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:pay:revocations}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- On (\textsc{pay}, $x$):}
    \begin{algorithmic}[1]
      \State ensure $\itistate = \textsc{open} \wedge c_P \geq x$
      \If{$\texttt{host}_P \neq \ledger \wedge P$ has a \texttt{host\_sibling}}
      \Comment{we are intermediary channel}
        \State ensure $c_{\mathrm{sib}, \mathrm{rem}} \geq c_P - x \wedge
        c_{\bar{P}} + x \geq c_{\mathrm{sib}}$ \Comment{avoid value loss by
        griefing attack: one counterparty closes with old version, the other
        stays idle forever}
      \EndIf
      \State \textsc{ln}.\textsc{signaturesRoundTrip}()
      \State \textsc{ln}.\textsc{revocationsTrip}()
      \State \Comment{No output is given to the caller, this is intentional}
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:pay}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- On (\textsc{check for lateral close}):}
    \begin{algorithmic}[1]
      \If{$\texttt{host}_P \neq \ledger$}
        \State input (\textsc{check for lateral close}) to
        $\texttt{host}_P$
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:poll-virtual}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- On (\textsc{check chain for old comm}):}
    \begin{algorithmic}[1]
      \State ensure $\itistate \notin \{\bot, \textsc{init},
      \textsc{topped up}\}$ \Comment{channel open}
      \State \Comment{even virtual channels check \ledger directly. This is
      intentional}
      \State input (\textsc{read}) to \ledger and assign reply to $\Sigma$
      \State $\texttt{last\_poll} \gets |\Sigma|$
      \If{$\exists 0 \leq j < i : C_{\bar{P}, j} \in \Sigma$}
      \Comment{counterparty has closed maliciously}
        \State $\itistate \gets \textsc{closing}$
        \State \textsc{ln}.\textsc{submitAndCheckRevocation}($j$)
        \State $\itistate \gets \textsc{closed}$
        \label{code:ln:poll:state-closed}
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:poll}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln}.\textsc{submitAndCheckRevocation}($j$)}
    \begin{algorithmic}[1]
      \State $\mathrm{sig}_{P, R, j} \gets \textsc{sign}(R_{P, j}, \sk{P, R})$
      \State input (\textsc{submit}, ($R_{P, j}$, $\mathrm{sig}_{P, R, j}$,
      $\mathrm{sig}_{\bar{P}, R, j}$)) to \ledger
      \While{$\nexists R_{P, j} \in \Sigma$}
        \State wait for input (\textsc{check revocation}) \Comment{ignore
        other messages}
        \State input (\textsc{read}) to \ledger and assign output to $\Sigma$
      \EndWhile
      \State $c_P \gets c_P + c_{\bar{P}}$
      \If{$\texttt{host}_P \neq \ledger$}
        \State input (\textsc{used revocation}) to $\texttt{host}_P$
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:submit-revocation}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- On (\textsc{close}):}
    \begin{algorithmic}[1]
      \State ensure $\itistate \notin \{\bot, \textsc{init}, \textsc{topped up},
      \textsc{closed}, \textsc{base punished}\}$ \Comment{channel open}
      \If{$\texttt{host}_P \neq \ledger$} \Comment{we have a virtual channel}
        \State $\itistate \gets \textsc{host closing}$
        \State input (\textsc{close}) to $\texttt{host}_P$ and keep relaying
        inputs (\textsc{check chain for closing}) to $\texttt{host}_P$ until
        receiving output (\textsc{closed}) by $\texttt{host}_P$
        \State $\texttt{host}_P \gets \ledger$
      \EndIf
      \State $\itistate \gets \textsc{closing}$
      \State input (\textsc{read}) to \ledger and assign output to $\Sigma$
      \If{$C_{\bar{P}, i} \in \Sigma$} \Comment{counterparty has closed
      honestly}
        \State no-op \Comment{do nothing}
      \ElsIf{$\exists 0 \leq j < i : C_{\bar{P}, j} \in \Sigma$}
      \Comment{counterparty has closed maliciously}
        \State \textsc{ln}.\textsc{submitAndCheckRevocation}($j$)
      \Else \: \Comment{counterparty is idle}
        \While{$\nexists$ unspent \texttt{output} $\in \Sigma$ that $C_{P, i}$
        can spend} \Comment{possibly due to an active timelock}
          \State wait for input (\textsc{check virtual}) \Comment{ignore other
          messages}
          \State input (\textsc{read}) to \ledger and assign output to $\Sigma$
        \EndWhile
        \State \Comment{provably reachable -- \TODO{ref}}
        \State $\mathrm{sig}_{P, C, i}' \gets \textsc{sign}(C_{P, i}, \sk{P,
        F})$
        \State input (\textsc{submit}, $(C_{P, i}, \mathrm{sig}_{P, C, i},
        \mathrm{sig}_{P, C, i}')$) to \ledger
        \While{$C_{P, i} \notin \Sigma$}
          \State wait for input (\textsc{check closed}) \Comment{ignore other
          messages}
          \State input (\textsc{read}) to \ledger and assign output to $\Sigma$
        \EndWhile
        \State \Comment{provably reachable -- \TODO{ref}}
      \EndIf
      \State $\itistate \gets \textsc{closed}$
      \label{code:ln:close:state-closed}
      \State output (\textsc{closed})
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:close}
\end{figure}

\begin{figure}
  \begin{processbox}{\textsc{ln} -- On output (\textsc{used revocation}) by
  $\texttt{host}_P$:}
    \begin{algorithmic}[1]
      \State $\itistate \gets \textsc{base punished}$
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:close}
\end{figure}
