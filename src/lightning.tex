\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- init}
    \begin{algorithmic}[1]
      \State \Comment{When not specified, input comes from and output goes to
      \environment in the real or $P \in \{\alice, \bob\}$ in the ideal world.}
      \State \Comment{In the real world, the player knows whether it is \alice
      (funder) or \bob (fundee). The activated party is $P$ and the counterparty
      is $\bar{P}$.}
      \State On (\textsc{init}, $\pk{P, \mathrm{out}}$):
      \Indent
        \State ensure $\textit{State}^P = \bot$
        \State $\textit{State}^P \gets \textsc{init}$
        \State store $\pk{P, \mathrm{out}}$
        \State $(c_A, c_B) \gets (0, 0)$
        \State output (\textsc{init ok})
      \EndIndent
      \Statex

      \State On (\textsc{topUp}):
      \Indent
        \State ensure $\textit{State}^P = \textsc{init}$
        \State $(\sk{P, \mathrm{chain}}, \pk{P, \mathrm{chain}}) \gets
        \textsc{keyGen}()$
        \State input (\textsc{read}) to \ledger as $P$ and assign ouput to
        $\Sigma$
        \State output (\textsc{top up to}, $\pk{P, \mathrm{chain}}$)
        \While{$\nexists \mathrm{tx} \in \Sigma, c_{P, \mathrm{chain}}: (c_{P,
        \mathrm{chain}}, \pk{P, \mathrm{chain}}) \in \mathrm{tx.outputs}$}
          \State output
          \State \Comment{while waiting, all other messages by $P$ are ignored}
          \State wait for input (\textsc{check top up})
          \State input (\textsc{read}) to \ledger as $P$ and assign ouput to
          $\Sigma$
        \EndWhile
        \State output (\textsc{top up ok}, $c_{P, \mathrm{chain}}$)
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:init}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- methods used by \textsc{virt}}
    \begin{algorithmic}[1]
      \State \textsc{getCommTX}($c_A$, $c_B$, $\pk{A, F}$, $\pk{A,
      \mathrm{out}}$, $\pk{A, R}$, $\pk{B, F}$, $\pk{B, \mathrm{out}}$, $\pk{B,
      R}$, $P$):
      \Indent
        \State $C_{P, i+1} \gets$ TX \{input: ($c_A + c_B$, $\texttt{3} \wedge
        2/\{\pk{A, F}, \pk{B, F}\}$), outputs: (($c_A$, $(\pk{A, \mathrm{out}} +
        t) \vee 2/\{\pk{A, R}, \pk{B, R}\}$), ($c_B$, $\pk{B, \mathrm{out}}$))\}
        \State \Return $C_{P, i+1}$
      \EndIndent
      \Statex

      \State \textsc{getCommKeys}():
      \Indent
        \State \Return $(\pk{A, F}, \pk{A, \mathrm{out}}, \pk{A, R}), (\pk{B,
        F}, \pk{B, \mathrm{out}}, \pk{B, R})$
      \EndIndent
      \Statex

      \State \textsc{revokePrevious}():
      \Indent
        \State $R_{B, i} \gets$ TX \{input: $C_{A, i}$.outputs.\alice, output:
        ($C_{A, i}$.outputs.\alice.value, $pk_{B, \mathrm{out}}$)\}
        \State $\mathrm{sig}_{A, R, i} \gets \textsc{sign}(R_{B, i}, \sk{A, R})$
        \State \Return $\mathrm{sig}_{A, R, i}$
      \EndIndent
      \Statex

      \State \textsc{processRemoteReovcation}($\mathrm{sig}_{B, R, i}$):
      \Indent
        \State $R_{A, i} \gets$ TX \{input: $C_{B, i}$.outputs.\bob, output:
        ($C_{B, i}$.outputs.\bob.value, $pk_{A, \mathrm{out}}$)\}
        \State ensure \textsc{verify}($R_{A, i}$, $\mathrm{sig}_{B, R, i}$,
        $\pk{B, R}$) = True
        \State \Return (\textsc{ok})
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:methods-for-virt}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- base}
    \begin{algorithmic}[1]
      \State \textsc{openBase}(\texttt{fundee}):
      \Indent
        \State ensure super.\textit{State} = \textsc{topped up}
        \State $(\sk{A, F}, \pk{A, F}) \gets \textsc{keyGen}()$;
        $(\sk{A, R}, \pk{A, R}) \gets \textsc{keyGen}()$
        \If{ideal world}
          \State $(\sk{B, F}, \pk{B, F}) \gets \textsc{keyGen}()$; $(\sk{B, R},
          \pk{B, R}) \gets \textsc{keyGen}()$
        \Else \: \Comment{real world}
          \State send (\textsc{open base channel}, $c_{P, \mathrm{chain}}$,
          $\pk{A, F}$, $\pk{A, R}$, $\pk{A, \mathrm{out}}$) to \texttt{fundee}
          \State \Comment{colored code is run by \texttt{fundee}. Validation is
          implicit}
          \State \remotecode{ensure super.\textit{State} = \textsc{init}}
          \Comment{``super'': storage of enclosing protocol}
          \State \remotecode{store $\pk{A, F}$, $\pk{A, R}$, $\pk{A,
          \mathrm{out}}$}
          \State \remotecode{$(\sk{B, F}, \pk{B, F}) \gets \textsc{keyGen}()$;
          $(\sk{B, R}, \pk{B, R}) \gets \textsc{keyGen}()$}
          \State \remotecode{reply (\textsc{accept base channel}, $\pk{B,
          F}$, $\pk{B, R}$, $\pk{B, \mathrm{out}}$)}
          \State store $\pk{B, F}$, $\pk{B, R}$, $\pk{B, \mathrm{out}}$
        \EndIf
        \State $F \gets$ TX \{input: $(c_{P, \mathrm{chain}}, \pk{P,
        \mathrm{chain}})$, output: $(c_{P, \mathrm{chain}}, 2/\{\pk{A, F},
        \pk{B, F}\})$\}
        \label{code:ln:base:create-funding}
        \If{real world}
          \State $C_{A, 0} \gets$ TX \{input: $F$.output, outputs: ($c_{P,
          \mathrm{chain}}$, ($\pk{A, \mathrm{out}} + t$) $\vee$ $2/\{\pk{A, R},
          \pk{B, R}\}$), ($0$, $\pk{B, \mathrm{out}}$)\}
          \State $C_{B, 0} \gets$ TX \{input: $F$.output, outputs: ($c_{P,
          \mathrm{chain}}$, $\pk{A, \mathrm{out}}$), ($0$, ($\pk{B,
          \mathrm{out}} + t$) $\vee$ $2/\{\pk{A, R}, \pk{B, R}\}$)\}
          \State $\mathrm{sig}_{A, C, 0} \gets \textsc{sign}(C_{B, 0}, \sk{A,
          F})$
          \State send (\textsc{funding created}, $(c_{P, \mathrm{chain}}, \pk{P,
          \mathrm{chain}})$, $\mathrm{sig}_{A, C, 0}$) to \texttt{fundee}
          \State \Comment{implicitly verify that this is a continuation of the
          previous exchange}
          \State \remotecode{$F \gets$ TX \{input: $(c_{P, \mathrm{chain}},
          \pk{P, \mathrm{chain}})$, output: $(c_{P, \mathrm{chain}}, 2/\{\pk{A,
          F}, \pk{B, F}\})$\}}
          \State \remotecode{$C_{B, 0} \gets$ TX \{input: $F$.output, outputs:
          ($c_{P, \mathrm{chain}}$, $\pk{A, \mathrm{out}}$), ($0$, ($\pk{B,
          \mathrm{out}} + t$) $\vee$ $2/\{\pk{A, R}, \pk{B, R}\}$)\}}
          \State \remotecode{ensure \textsc{verify}($C_{B, 0}$,
          $\mathrm{sig}_{A, C, 0}$, $\pk{A, F}$) = True}
          \State \remotecode{$C_{A, 0} \gets$ TX \{input: $F$.output, outputs:
          ($c_{P, \mathrm{chain}}$, ($\pk{A, \mathrm{out}} + t$) $\vee$
          $2/\{\pk{A, R}, \pk{B, R}\}$), ($0$, $\pk{B, \mathrm{out}}$)\}}
          \State \remotecode{$\mathrm{sig}_{B, C, 0} \gets \textsc{sign}(C_{A,
          0}, \sk{B, F})$}
          \State \remotecode{reply (\textsc{funding signed}, $\mathrm{sig}_{B,
          C, 0}$)}
          \State ensure \textsc{verify}($C_{A, 0}$, $\mathrm{sig}_{B, C, 0}$,
          $\pk{B, F}$) = True
        \EndIf
        \State $\mathrm{sig}_F \gets \textsc{sign}(F, \sk{P, \mathrm{chain}})$
        \label{code:ln:base:sign-funding}
        \State send $(\textsc{open}, c_{P, \mathrm{chain}}, \pk{A,
        \mathrm{out}}, \pk{B, \mathrm{out}}, F, \mathrm{sig}_F,
        \texttt{funder})$ to \adversary
        \While{$F \notin \Sigma$}
          \State wait for input (\textsc{check funding}) by \texttt{funder}
          \State input (\textsc{read}) to \ledger as \texttt{funder} and assign
          output to $\Sigma$
        \EndWhile
        \State \Return (\textsc{ok}, $c_{P, \mathrm{chain}}$)
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:base}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- open virtual}
    \begin{algorithmic}[1]
      \State \textsc{openVirtual}(\texttt{fundee}, \texttt{host\_funder},
      \texttt{host\_fundee}, $c$):
      \Indent
        \If{real world}
          \State do funding ceremony as in base channel
          (Fig.~\ref{code:ln:base},
          lines~\ref{code:ln:base:create-funding}-\ref{code:ln:base:sign-funding})
          \TODO{abstract better}
          \State \Return $(\pk{A, F}, \pk{B, F})$
        \EndIf
        \State \Return (\textsc{ok})
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:open-virtual}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- pay}
    \begin{algorithmic}[1]
      \State \textsc{pay}($x$, \textit{payid}): \Comment{\alice pays, \bob gets
      paid}
      \Indent
        \State $C_{B, i+1} \gets C_{B, i}$ with $x$ coins moved from \alice's to
        \bob's output
        \State $\mathrm{sig}_{A, C, i+1} \gets \textsc{sign}(C_{B, i+1}, \sk{A,
        F})$ \Comment{kept by \alice}
        \State send (\textsc{pay}, $x$, $\mathrm{sig}_{A, C, i+1}$,
        \textit{payid}) to \bob
        \State \remotecode{$C_{B, i+1} \gets C_{B, i}$ with $x$ coins moved from
        \alice's to \bob's output}
        \State \remotecode{ensure \textsc{verify}($C_{B, i+1}$,
        $\mathrm{sig}_{A, C, i+1}$, $\pk{A, F}$) = True}
        \State \remotecode{$C_{A, i+1} \gets C_{A, i}$ with $x$ coins moved from
        \alice's to \bob's output}
        \State \remotecode{$\mathrm{sig}_{B, C, i+1} \gets \textsc{sign}(C_{A,
        i+1}, \sk{B, F})$} \Comment{kept by \bob}
        \State \remotecode{$R_{A, i} \gets$ TX \{input: $C_{B,
        i}$.outputs.\alice, output: ($c_B$, $\pk{A, \mathrm{out}}$)\}}
        \State \remotecode{$\mathrm{sig}_{B, R, i} \gets \textsc{sign}(R_{A,
        i}, \sk{B, R})$}
        \State \remotecode{reply (\textsc{commitment signed}, $\mathrm{sig}_{B,
        C, i+1}$, $\mathrm{sig}_{B, R, i}$)}
        \State $C_{A, i+1} \gets C_{A, i}$ with $x$ coins moved from \alice's to
        \bob's output
        \State ensure \textsc{verify}($C_{A, i+1}$, $\mathrm{sig}_{B, C, i+1}$,
        $\pk{B, F}$) = True
        \State $R_{A, i} \gets$ TX \{input: $C_{B, i}$.outputs.\alice, output:
        ($c_B$, $\pk{A, \mathrm{out}}$)\}
        \State ensure \textsc{verify}($R_{A, i}$, $\mathrm{sig}_{B, R, i}$,
        $\pk{B, R}$) = True
        \State $R_{B, i} \gets$ TX \{input: $C_{A, i}$.outputs.\bob, output:
        ($c_A$, $\pk{B, \mathrm{out}}$)\}
        \State $\mathrm{sig}_{A, R, i} \gets \textsc{sign}(R_{B, i}, \sk{A, R})$
        \State add ($x$, \textit{payid}) to \texttt{paid\_out}
        \State $c_A \gets c_A - x; c_B \gets c_B + x$
        \State send (\textsc{revoke and ack}, $\mathrm{sig}_{A, R, i}$) to \bob
        \State \remotecode{$R_{B, i} \gets$ TX \{input: $C_{A,
        i}$.outputs.\bob, output: ($c_A$, $\pk{B, \mathrm{out}}$)\}}
        \State \remotecode{ensure \textsc{verify}($R_{B, i}$, $\mathrm{sig}_{A,
        R, i}$, $\pk{A, R}$) = True}
        \State \remotecode{add ($x$, \textit{payid}) to \texttt{paid\_in}}
        \State \remotecode{$c_A \gets c_A - x; c_B \gets c_B + x$}
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:pay}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- close}
    \begin{algorithmic}[1]
      \State \textsc{close}($P$, $(\mathrm{tx}_i, (\sigma_{ij})_j)_i$):
      \Indent
        \State \TODO{also cover case when we are virtual}
        \State $\mathit{State} \gets (\textsc{closing}, P, (\mathrm{tx}_i)_i)$
        \State input (\textsc{submit}, $(\mathrm{tx}_i, (\sigma_{ij})_j)_i$)
        to \ledger as $P$
      \EndIndent
      \Statex

      \State On activation when $\textit{State} = (\textsc{closing}, P,
      (\mathrm{tx}_i)_i)$:
      \Indent
        \State input (\textsc{read}) to \ledger as $P$ and assign output to
        $\Sigma$
        \State ensure all transactions $(\mathrm{tx}_i)_i$ are contained in
        $\Sigma$
        \State $\mathit{State} \gets \textsc{closed}$
        \State \Return (\textsc{ok})
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:virtual}
\end{figure}
