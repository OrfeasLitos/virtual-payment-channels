\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- init}
    \begin{algorithmic}[1]
      \State \textsc{init}(\texttt{keys}, \dave):
      \Indent
        \State $pk_{D, \mathrm{out}} \gets \texttt{keys}$
        \State \Return (\textsc{ok})
      \EndIndent
      \Statex

      \State \textsc{topUp}(\texttt{funder}): \TODO{move to \textsc{common} if
      more stuff fits there}
      \Indent
        \State $(sk_{\mathrm{chain}}, pk_{\mathrm{chain}}) \gets
        \textsc{keyGen}()$
        \State output (\textsc{public key}, $pk_{\mathrm{chain}}$) to \dave
        \While{$\nexists \mathrm{tx} \in \Sigma, c_{\mathrm{chain}}:
        (c_{\mathrm{chain}}, pk_{\mathrm{chain}}) \in \mathrm{tx.outputs}$}
          \State wait\footnote{while waiting, all other messages by \dave are
          ignored} for input (\textsc{check top up}) by \dave
          \State input (\textsc{read}) to \ledger as \dave and assign ouput to
          $\Sigma$
        \EndWhile
        \State $\texttt{base\_output} \gets (c_{\mathrm{chain}},
        pk_{\mathrm{chain}})$
        \State \Return (\textsc{ok}, $c_{\mathrm{chain}}$)
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:init}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- base}
    \begin{algorithmic}[1]
      \State \textsc{openBase}(\texttt{args}):
      \Indent
        \State ensure \texttt{args} can be parsed as ($c_F$, $pk_{A,
        \mathrm{out}}$, $pk_{B, \mathrm{out}}$)
        \State ensure $c_F = c_{\mathrm{in}}$
        \State $(sk_{A, F}, pk_{A, F}) \gets \textsc{keyGen}()$; $(sk_{B, F},
        pk_{B, F}) \gets \textsc{keyGen}()$
        \State $F \gets$ TX \{input: \texttt{base\_output}, output: $(c_F,
        2/\{pk_{A, F}, pk_{B, F}\})$\}
        \State $\mathrm{sig}_F \gets \textsc{sign}(F, sk)$
        \State send $(\textsc{open}, c_F, pk_{A, \mathrm{out}}, pk_{B,
        \mathrm{out}}, F, \mathrm{sig}_F, \alice)$ to \adversary, wait for
        input (\textsc{check funding}) by \alice
        \State input (\textsc{read}) to \ledger as \alice and assign output to
        $\Sigma$
        \State ensure $F \in \Sigma$
        \State \Return (\textsc{ok}, $c_F$)
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:base}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- virtual}
    \begin{algorithmic}[1]
      \State \textsc{openVirtual}($c$, \texttt{keys}):
      \Indent
        \State $(sk_{A, V}, pk_{A, V}) \gets \textsc{keyGen}()$; $(sk_{B, V},
        pk_{B, V}) \gets \textsc{keyGen}()$
        \State \TODO{continue}
        \State send (\textsc{open virtual}, $c$, \bob, \charlie, \alice) to
        \adversary and ensure reply is \textsc{(ok)}
        \State \Return (\textsc{ok})
      \EndIndent
      \Statex

      \State \textsc{pay}($x$):
      \Indent
        \State \TODO{}
      \EndIndent
      \Statex

      \State \textsc{close}($P$, $(\mathrm{tx}_i, (\sigma_{ij})_j)_i$):
      \Indent
          \State $\mathit{State} \gets (\textsc{closing}, P, (\mathrm{tx}_i)_i)$
          \State input (\textsc{submit}, $(\mathrm{tx}_i, (\sigma_{ij})_j)_i$)
          to \ledger as $P$
      \EndIndent
      \Statex

      \State On activation when $\textit{State} = (\textsc{closing}, P,
      (\mathrm{tx}_i)_i)$:
      \Indent
        \State input (\textsc{read}) to \ledger as $P$ and assign reply to
        $\Sigma$
        \State ensure all transactions $(\mathrm{tx}_i)_i$ are contained in
        $\Sigma$
        \State \Return (\textsc{ok})
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:virtual}
\end{figure}
