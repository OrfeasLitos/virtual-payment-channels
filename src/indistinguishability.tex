\begin{theorem}[Recursive Virtual Payment Channel Security]
  \label{theorem:security}
  The protocol $\pchan$ UC-realises $\fchan$ given a global functionality
  $\ledger$ and assuming the security of the underlying digital signature.
  Specifically,
  \begin{gather*}
    \forall \text{ PPT } \adversary, \exists \text{ PPT } \simulator: \forall
    \text{ PPT } \environment \text{ it is }
    \textsc{exec}^{\ledger}_{\pchan, \adversary, \environment} \approx
    \textsc{exec}^{\fchan, \ledger}_{\simulator, \environment}
  \end{gather*}
\end{theorem}

\proof{
  By inspection of Figs.~\ref{code:functionality:rules}
  and~\ref{code:simulator:flow} we can deduce that for a particular
  \environment, in the ideal world execution $\textsc{exec}^{\fchan,
  \ledger}_{\simulator_{\adversary}, \environment}$, $\simulator_{\adversary}$
  simulates internally the two \pchan parties exactly as they would execute
  in the real world execution, $\textsc{exec}^{\ledger}_{\pchan,
  \adversary, \environment}$ in case \fchan does not halt. Indeed, \fchan only
  halts with negligible probability according to Lemma~\ref{lemma:no-halt},
  therefore the two executions are computationally indistinguishable.
}

We now generalise Theorem~\ref{theorem:security} to prove the
indistinguishability of multiple \fchan instances from multiple \pchan
instances, leveraging the definition of the multi-session extension of an ideal
functionality~\cite{DBLP:conf/crypto/CanettiR03}.

\begin{definition}[Multi-Session Extension of a Protocol]
  Let protocol $\pi$. Its \emph{multi-session extension} $\hat{\pi}$ has the
  same code as $\pi$ and has 2 session ids: the ``sub-session id''
  \emph{ssid} which replaces the session id of $\pi$ and the usual session id
  \emph{sid} which has no further function apart from what is prescribed by the
  UC framework.
\end{definition}

\begin{theorem}[Indistinguishability of multiple sessions]
  Let \fchanhat the multi-session extension of \fchan and \pchanhat the
  protocol-multi-session extension of \pchan.
  \begin{gather*}
    \forall \text{ PPT } \adversary, \exists \text{
    PPT } \simulator: \forall \text{ PPT } \environment \text{ it is }
    \textsc{exec}^{\ledger}_{\pchanhat, \adversary, \environment} \approx
    \textsc{exec}^{\fchanhat, \ledger}_{\simulator, \environment}
  \end{gather*}
\end{theorem}

\proof{
  We observe that \fchanhat uses \fchan internally. According to the UC
  theorem~\cite{uc} and given that \pchan UC-realises \fchan
  (Theorem~\ref{theorem:security}), $\fchanhat^{\fchan \rightarrow \pchan}$
  UC-emulates \fchanhat. We now observe that $\fchanhat^{\fchan \rightarrow
  \pchan}$ behaves identically to a session with \pchanhat protocols, as the
  former routes each message to the same internal \pchan instance that would
  handle the same message in the latter case, therefore $\fchanhat^{\fchan
  \rightarrow \pchan}$ UC-emulates \pchanhat. By the transitivity of
  UC-emulation, we deduce that \fchanhat UC-emulates \pchanhat.
}
