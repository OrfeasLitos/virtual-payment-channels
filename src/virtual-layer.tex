\begin{figure}[H]
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State On every activation, before handling the message:
      \Indent
        \If{$\texttt{last\_poll} \neq \bot$} \Comment{virtual layer is ready}
          \State input (\textsc{read}) to \ledger and assign ouput to $\Sigma$
          \If{$\texttt{last\_poll} + t < |\Sigma|$}
            \For{$P \in \{\texttt{guest}, \texttt{funder}, \texttt{fundee}\}$}
            \Comment{at most 1 of \texttt{funder}, \texttt{fundee} is defined}
              \State ensure $P$.\textsc{negligent}() returns (\textsc{ok})
            \EndFor
          \EndIf
        \EndIf
      \EndIndent
      \Statex

      \State \Comment {\texttt{guest} is trusted to give sane inputs, therefore
      a state machine and input verification is redundant}
      \State On input (\textsc{init}, $\texttt{host}_P$, $\bar{P}$,
      \texttt{sibling}, \texttt{fundee}, ($\sk{\mathrm{loc}, \mathrm{virt}}$,
      $\pk{\mathrm{loc}, \mathrm{virt}}$), $\pk{\mathrm{rem}, \mathrm{virt}}$,
      $\pk{\mathrm{sib}, \mathrm{rem}, \mathrm{virt}}$, ($\sk{\mathrm{loc}, F}$,
      $\pk{\mathrm{loc}, F}$), $\pk{\mathrm{rem}, F}$, $c_{\mathrm{guest}}$) by
      \texttt{guest}:
      \Indent
        \State store message contents and \texttt{guest}
        \Comment{\texttt{sibling}, $\pk{\mathrm{sib}, \bar{P}, F}$ are missing
        for edge nodes, \texttt{fundee} is present only in last node}
        \State $\texttt{last\_poll} \gets \bot$
        \State output (\textsc{host init ok}) to \texttt{guest}
      \EndIndent
      \Statex

      \State On input (\textsc{host me}, \texttt{funder}, \texttt{fundee},
      $\bar{P}$, $\texttt{host}_P$, $c_{\mathrm{guest}}$, $\pk{\mathrm{left},
      \mathrm{guest}}$, $\pk{\mathrm{right}, \mathrm{guest}}$,
      ($\sk{\mathrm{loc}, \mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{virt}}$),
      ($\sk{\mathrm{loc}, F}$, $\pk{\mathrm{loc}, F}$), $\pk{\mathrm{rem}, F}$,
      $\pk{\mathrm{rem}, \mathrm{virt}}$) by \texttt{guest}:
      \Indent
        \State $\texttt{last\_poll} \gets \bot$
        \State ensure \textsc{virt.circulateKeysAndCoins}() returns (\textsc{ok})
        \State ensure \textsc{virt.circulateVirtualSigs}() returns (\textsc{ok})
        \State ensure \textsc{virt.circulateFundingSigs}() returns (\textsc{ok})
        \State ensure \textsc{virt.circulateRevocations}() returns (\textsc{ok})
        \State output (\textsc{hosts ready}) to \texttt{guest}
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:keys}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt}.\textsc{circulateKeysAndCoins}(\texttt{left\_data}):}
    \begin{algorithmic}[1]
      \If{\texttt{left\_data} is given as argument} \Comment{we are not
      \texttt{host\_funder}}
        \If{we have a \texttt{sibling}} \Comment{we are not
        \texttt{host\_fundee}}
          \State input (\textsc{keys and coins forward}, (\texttt{left\_data},
          $(\sk{\mathrm{loc}, \mathrm{virt}}, \pk{\mathrm{loc},
          \mathrm{virt}})$, ($\sk{\mathrm{loc}, F}$, $\pk{\mathrm{loc}, F}$),
          $\pk{\mathrm{rem}, F}$, $c_P$, $c_{\bar{P}}$) to \texttt{sibling}
          \State \trustedcode{store input as \texttt{left\_data}}
          \State \trustedcode{parse \texttt{left\_data} as
          \texttt{far\_left\_data}, $(\sk{\mathrm{loc}, \mathrm{virt}},
          \pk{\mathrm{loc}, \mathrm{virt}})$, ($\sk{\mathrm{sib}, F}$,
          $\pk{\mathrm{sib}, F}$), $\pk{\mathrm{sib}, \mathrm{rem}, F}$,
          $c_{\mathrm{sib}}$, $c_{\mathrm{sib}, \mathrm{rem}}$}
          \Comment{remove parentheses as necessary}
          \State \trustedcode{call
          \textsc{virt.circulateKeysAndCoins}(\texttt{left\_data}) of
          $\bar{P}$ and assign returned value to \texttt{right\_data}}
          \State \trustedcode{parse \texttt{right\_data} as
          \texttt{far\_right\_data}, $\pk{\mathrm{rem}, \mathrm{virt}}$}
          \State \trustedcode{output (\textsc{keys and coins back},
          \texttt{right\_data}, ($\sk{\mathrm{loc}, F}$, $\pk{\mathrm{loc},
          F}$), $\pk{\mathrm{rem}, F}$, $c_P$, $c_{\bar{P}}$)}
          \State store output as \texttt{right\_data}
          \State parse \texttt{right\_data} as \texttt{far\_right\_data},
          ($\sk{\mathrm{sib}, F}$, $\pk{\mathrm{sib}, F}$), $\pk{\mathrm{sib},
          \mathrm{rem}, F}$, $c_{\mathrm{sib}}$, $c_{\mathrm{sib},
          \mathrm{rem}}$
          \State \Return (\texttt{right\_data}, $\pk{\mathrm{loc},
          \mathrm{virt}}$)
        \Else \: \Comment{we are \texttt{host\_fundee}}
          \State extract ($\pk{\mathrm{left}, \mathrm{guest}}$,
          $\pk{\mathrm{right}, \mathrm{guest}}$) from \texttt{left\_data}
          \State output (\textsc{check keys}, ($\pk{\mathrm{left},
          \mathrm{guest}}$, $\pk{\mathrm{right}, \mathrm{guest}}$)) to
          \texttt{fundee} and expect reply (\textsc{keys ok})
          \State \Return $\pk{\mathrm{loc}, \mathrm{virt}}$
        \EndIf
      \Else \: \Comment{we are \texttt{host\_funder}}
        \State call \textsc{virt.circulateKeysAndCoins}($\pk{\mathrm{loc},
        \mathrm{virt}}$, ($\pk{\mathrm{left}, \mathrm{guest}}$,
        $\pk{\mathrm{right}, \mathrm{guest}}$)) of $\bar{P}$ and assign
        returned value to \texttt{right\_data}
        \State \Return (\textsc{ok})
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:circulate-keys-and-coins}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State \textsc{getMidTXs}($c_{\mathrm{guest}}$, $c_{\mathrm{loc}}$,
      $c_{\mathrm{rem}}$, $c_{\mathrm{sib}}$, $c_{\mathrm{sibRem}}$,
      $\pk{\mathrm{left}, \mathrm{fund}}$, $\pk{\mathrm{loc}, \mathrm{fund}}$,
      $\pk{\mathrm{sib}, \mathrm{fund}}$, $\pk{\mathrm{right}, \mathrm{fund}}$,
      $\pk{\mathrm{left}, \mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{virt}}$,
      $\pk{\mathrm{sib}, \mathrm{virt}}$, $\pk{\mathrm{right}, \mathrm{virt}}$,
      $\pk{\mathrm{left}, \mathrm{guest}}$, $\pk{\mathrm{right},
      \mathrm{guest}}$, $\pk{\mathrm{loc}, \mathrm{out}}$, $\{\pk{\mathrm{sec},
      i}\}_{i \in 1 \dots n}$):
      \Indent
        \State ensure $c_{\mathrm{sibRem}} \geq c_{\mathrm{guest}} \wedge
        c_{\mathrm{loc}} \geq c_{\mathrm{guest}}$
        \State $c_{\mathrm{left}} \gets c_{\mathrm{sib}} + c_{\mathrm{sibRem}}$;
        $c_{\mathrm{right}} \gets c_{\mathrm{loc}} + c_{\mathrm{rem}}$
        \State $\texttt{left\_fund} \gets 2/\{\pk{\mathrm{left}, \mathrm{fund}},
        \pk{\mathrm{loc}, \mathrm{fund}}\}$
        \State $\texttt{right\_fund} \gets 2/\{\pk{\mathrm{sib}, \mathrm{fund}},
        \pk{\mathrm{right}, \mathrm{fund}}\}$
        \State $\texttt{left\_virt} \gets 2/\{\pk{\mathrm{left}, \mathrm{virt}},
        \pk{\mathrm{loc}, \mathrm{virt}}\}$
        \State $\texttt{left\_virt\_checked} \gets 4/\{\pk{\mathrm{left},
        \mathrm{virt}}, \pk{\mathrm{loc}, \mathrm{virt}}, \pk{\mathrm{left},
        \mathrm{guest}}, \pk{\mathrm{right}, \mathrm{guest}}\}$
        \State $\texttt{right\_virt} \gets 2/\{\pk{\mathrm{sib}, \mathrm{virt}},
        \pk{\mathrm{right}, \mathrm{virt}}\}$
        \State $\texttt{right\_virt\_checked} \gets 4/\{\pk{\mathrm{sib},
        \mathrm{virt}}, \pk{\mathrm{right}, \mathrm{virt}}, \pk{\mathrm{left},
        \mathrm{guest}}, \pk{\mathrm{right}, \mathrm{guest}}\}$
        \State $\texttt{left\_out\_checked} \gets (\texttt{2} \wedge
        \texttt{left\_virt\_checked}) \vee (\texttt{3} \wedge
        \texttt{left\_virt} + (t + s))$
        \State $\texttt{right\_out} \gets (\texttt{1} \wedge
        \texttt{right\_virt}) \vee (\texttt{3} \wedge \texttt{right\_virt} + (t
        + s))$
        \State $\texttt{right\_out\_checked} \gets (\texttt{1} \wedge
        \texttt{right\_virt\_checked}) \vee (\texttt{3} \wedge
        \texttt{right\_virt} + (t + s))$
        \State $\texttt{guest\_all} \gets \texttt{5} \wedge
        n/\{\pk{\mathrm{left}, \mathrm{guest}}, \pk{\mathrm{right},
        \mathrm{guest}}, \{\pk{\mathrm{sec}, 1 \dots n}\}\}$
        \State $\texttt{guest\_out} \gets \texttt{4} \wedge
        2/\{\pk{\mathrm{left}, \mathrm{guest}}, \pk{\mathrm{right},
        \mathrm{guest}}\}$
        \State $\texttt{guest} \gets (\texttt{guest\_out} + (t + s)) \vee
        \texttt{guest\_all}$
        \State $\mathrm{TX}_{\mathrm{none}} \gets$ TX \{inputs:
        (($c_{\mathrm{left}}$, \texttt{left\_fund}), ($c_{\mathrm{right}}$,
        \texttt{right\_fund})), outputs: (($c_{\mathrm{left}} -
        c_{\mathrm{guest}}$, \texttt{left\_out\_checked}), ($c_{\mathrm{right}}
        - c_{\mathrm{guest}}$, \texttt{right\_out\_checked}),
        ($c_{\mathrm{guest}}$, $\pk{\mathrm{loc}, \mathrm{out}}$),
        ($c_{\mathrm{guest}}$, \texttt{guest}))\}
        \State $\mathrm{TX}_{\mathrm{left}} \gets$ TX \{inputs:
        (($c_{\mathrm{left}} - c_{\mathrm{guest}}$, \texttt{1} $\wedge$
        \texttt{left\_virt\_checked}), ($c_{\mathrm{right}}$,
        \texttt{right\_fund})), outputs: (($c_{\mathrm{left}} -
        c_{\mathrm{guest}}$, \texttt{3} $\wedge$ \texttt{left\_virt}),
        ($c_{\mathrm{right}} - c_{\mathrm{guest}}$,
        \texttt{right\_out\_checked}), ($c_{\mathrm{guest}}$, $\pk{\mathrm{loc},
        \mathrm{out}}$))\}
        \State $\mathrm{TX}_{\mathrm{right}} \gets$ TX \{inputs:
        (($c_{\mathrm{left}}$, \texttt{left\_fund}), ($c_{\mathrm{right}} -
        c_{\mathrm{guest}}$, \texttt{2} $\wedge$ \texttt{right\_virt\_checked}),
        ($c_{\mathrm{guest}}$, \texttt{guest\_all})), outputs:
        (($c_{\mathrm{left}} - c_{\mathrm{guest}}$,
        \texttt{left\_out\_checked}), ($c_{\mathrm{right}} -
        c_{\mathrm{guest}}$, \texttt{3} $\wedge$ \texttt{right\_virt}),
        ($c_{\mathrm{guest}}$, $\pk{\mathrm{loc}, \mathrm{out}}$),
        ($c_{\mathrm{guest}}$, \texttt{guest}))\} \State
        $\mathrm{TX}_{\mathrm{both}} \gets$ TX \{inputs: (($c_{\mathrm{left}} -
        c_{\mathrm{guest}}$, \texttt{1} $\wedge$ \texttt{left\_virt\_checked}),
        ($c_{\mathrm{right}} - c_{\mathrm{guest}}$, \texttt{2} $\wedge$
        \texttt{right\_virt\_checked}), ($c_{\mathrm{guest}}$,
        \texttt{guest\_all})), outputs: (($c_{\mathrm{left}} -
        c_{\mathrm{guest}}$, \texttt{3} $\wedge$ \texttt{left\_virt}),
        ($c_{\mathrm{right}} - c_{\mathrm{guest}}$, \texttt{3} $\wedge$
        \texttt{right\_virt}), ($c_{\mathrm{guest}}, \pk{\mathrm{loc},
        \mathrm{out}}$)\}
        \State \Return ($\mathrm{TX}_{\mathrm{none}}$,
        $\mathrm{TX}_{\mathrm{left}}$, $\mathrm{TX}_{\mathrm{right}}$,
        $\mathrm{TX}_{\mathrm{both}}$)
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:mid-txs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State \Comment{left and right refer to the two counterparties, with left
      being the one closer to the funder. Note difference with left/right
      meaning in \textsc{virt.getMidTXs}.}
      \State \textsc{getEdgeTXs}($c_{\mathrm{guest}}$, $c_{\mathrm{left}}$,
      $c_{\mathrm{right}}$, $\pk{\mathrm{left}, \mathrm{fund}}$,
      $\pk{\mathrm{right}, \mathrm{fund}}$, $\pk{\mathrm{left}, \mathrm{virt}}$,
      $\pk{\mathrm{right}, \mathrm{virt}}$, $\pk{\mathrm{left},
      \mathrm{guest}}$, $\pk{\mathrm{right}, \mathrm{guest}}$,
      $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$, \texttt{is\_funder}):
      \Indent
        \State ensure $c_{\mathrm{left}} \geq c_{\mathrm{guest}}$
        \State $c_{\mathrm{tot}} \gets c_{\mathrm{left}} + c_{\mathrm{right}}$
        \State $\texttt{fund} \gets 2/\{\pk{\mathrm{left}, \mathrm{fund}},
        \pk{\mathrm{right}, \mathrm{fund}}\}$
        \State $\texttt{virt} \gets 2/\{\pk{\mathrm{left}, \mathrm{virt}},
        \pk{\mathrm{right}, \mathrm{virt}}\}$
        \State $\texttt{virt\_checked} \gets 4/\{\pk{\mathrm{left},
        \mathrm{virt}}, \pk{\mathrm{right}, \mathrm{virt}}, \pk{\mathrm{left},
        \mathrm{guest}}, \pk{\mathrm{right}, \mathrm{guest}}\}$
        \If{\texttt{is\_funder} = True}
          \State $\texttt{out} \gets (\texttt{1} \wedge \texttt{virt\_checked})
          \vee (\texttt{3} \wedge \texttt{virt} + (t + s))$
        \Else \: \Comment{TXs belong to \texttt{fundee}}
          \State $\texttt{out} \gets (\texttt{2} \wedge \texttt{virt\_checked})
          \vee (\texttt{3} \wedge \texttt{virt} + (t + s))$
        \EndIf
        \State $\texttt{guest\_all} \gets \texttt{5} \wedge
        n/\{\pk{\mathrm{left}, \mathrm{guest}}, \pk{\mathrm{right},
        \mathrm{guest}}, \{\pk{\mathrm{sec}, 1 \dots n}\}\}$
        \State $\texttt{guest\_out} \gets \texttt{4} \wedge
        2/\{\pk{\mathrm{left}, \mathrm{guest}}, \pk{\mathrm{right},
        \mathrm{guest}}\}$
        \State $\texttt{guest} \gets (\texttt{guest\_out} + (t + s)) \vee
        \texttt{guest\_all}$
        \State $\mathrm{TX}_{\mathrm{base}} \gets$ TX \{input:
        ($c_{\mathrm{tot}}$, \texttt{fund}), outputs: (($c_{\mathrm{tot}} -
        c_{\mathrm{guest}}$, \texttt{out}), ($c_{\mathrm{guest}}$,
        \texttt{guest}))\}
        \State \Return $\mathrm{TX}_{\mathrm{base}}$
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:edge-txs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.siblingSigs}()}
    \begin{algorithmic}[1]
      \State parse input as $\mathrm{sigs}_{\mathrm{byLeft}}$
      \State ($\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$,
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{left}}$, $\mathrm{TX}_{\mathrm{loc},
      \mathrm{right}}$, $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$) $\gets$
      \textsc{virt.getMidTXs}($c_{\mathrm{guest}}$, $c_P$, $c_{\bar{P}}$,
      $c_{\mathrm{sib}}$, $c_{\mathrm{sib}, \mathrm{rem}}$, $\pk{\mathrm{sib},
      \mathrm{rem}, F}$, $\pk{\mathrm{sib}, F}$, $\pk{\mathrm{loc}, F}$,
      $\pk{\mathrm{rem}, F}$, $\pk{\mathrm{sib}, \mathrm{rem}, \mathrm{virt}}$,
      $\pk{\mathrm{loc}, \mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{virt}}$,
      $\pk{\mathrm{rem}, \mathrm{virt}}$, $\pk{\mathrm{left}, \mathrm{guest}}$,
      $\pk{\mathrm{right}, \mathrm{guest}}$, $\pk{\mathrm{loc}, \mathrm{virt}}$,
      $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$)
      \State store all signatures in $\mathrm{sigs}_{\mathrm{byLeft}}$ that sign
      any of $\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$,
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{left}}$, $\mathrm{TX}_{\mathrm{loc},
      \mathrm{right}}$, $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$ and remove
      these signatures from $\mathrm{sigs}_{\mathrm{byLeft}}$
      \State ensure that the stored signatures contain one valid
      signature for $\mathrm{TX}_{\mathrm{loc}, \mathrm{right}}$ and
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$ which sign the
      \texttt{guest\_all} input by each one of the previous $j-1$ hops
      \State ensure that there are exactly $4$ more valid signatures in the
      stored signatures, which sign the $\texttt{1} \wedge
      \texttt{left\_virt\_checked}$ inputs of $\mathrm{TX}_{\mathrm{loc},
      \mathrm{left}}$ and $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$ with
      $\pk{\mathrm{sib}, \mathrm{rem}, \mathrm{virt}}$ and $\pk{\mathrm{left},
      \mathrm{guest}}$
      \State $\mathrm{sigs}_{\mathrm{toRight}} \gets
      \mathrm{sigs}_{\mathrm{byLeft}}$
      \For{each hop apart from the first, the last and ours ($i \in [2, \dots,
      n-1] \setminus \{j\}$)} \Comment{$j$ is our hop number, hop data encoded
      in \texttt{left\_data} and \texttt{right\_data}}
        \State extract data needed for \textsc{getMidTXs}() from
        \texttt{left\_data} (if $i < j$) or \texttt{right\_data} (if $i > j$)
        and assign it to $\texttt{data}_i$ and $\{\pk{\mathrm{sec}, i}\}_{i \in
        1 \dots n}$ \Comment{$P$ and \texttt{comm\_keys} are missing, that is
        OK. $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$ contains each party's
        $\pk{i, \mathrm{virt}}$}
        \State ($\mathrm{TX}_{i, \mathrm{none}}$, $\mathrm{TX}_{i,
        \mathrm{left}}$, $\mathrm{TX}_{i, \mathrm{right}}$, $\mathrm{TX}_{i,
        \mathrm{both}}$) $\gets$ \textsc{virt.getMidTXs}($\texttt{data}_i$,
        $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$)
        \State add \textsc{sign}($\mathrm{TX}_{i, \mathrm{right}}$,
        $\sk{\mathrm{loc}, \mathrm{virt}}$, \textsc{anyprevout}) and
        \textsc{sign}($\mathrm{TX}_{i, \mathrm{both}}$, $\sk{\mathrm{loc},
        \mathrm{virt}}$, \textsc{anyprevout}) to
        $\mathrm{sigs}_{\mathrm{toLeft}}$ if $i < j$, or
        $\mathrm{sigs}_{\mathrm{toRight}}$ if $i > j$ \Comment{if $i$-th hop is
        adjacent, $2$ signatures will be produced by each \textsc{sign}()
        invocation: one for the \texttt{guest\_all} and one for the $\texttt{2}
        \wedge \texttt{right\_virt\_checked}$ input}
        \If{$i - j = 1$} \Comment{hop is our next}
          \State add \textsc{sign}($\mathrm{TX}_{i, \mathrm{left}}$,
          $\sk{\mathrm{loc}, \mathrm{virt}}$, \textsc{anyprevout}) to
          $\mathrm{sigs}_{\mathrm{toRight}}$
        \ElsIf{$j - i = 1$} \Comment{hop is our previous}
          \State add \textsc{sign}($\mathrm{TX}_{i, \mathrm{left}}$,
          $\sk{\mathrm{loc}, \mathrm{virt}}$, \textsc{anyprevout}) to
          $\mathrm{sigs}_{\mathrm{toLeft}}$
        \EndIf
      \EndFor
      \If{\texttt{right\_data} does not contain data from a second-next hop}
      \Comment{next hop is \texttt{host\_fundee}}
        \State $\mathrm{TX}_{\mathrm{next}, \mathrm{none}}$ $\gets$
        \textsc{virt.getEdgeTXs}($c_{\mathrm{guest}}$, $c_P$, $c_{\bar{P}}$,
        $\pk{\mathrm{loc}, F}$, $\pk{\mathrm{rem}, F}$, $\pk{\mathrm{loc},
        \mathrm{virt}}$, $\pk{\mathrm{rem}, \mathrm{virt}}$, $\pk{\mathrm{left},
        \mathrm{guest}}$, $\pk{\mathrm{right}, \mathrm{guest}}$, False)
      \EndIf
      \State call
      $\bar{P}$.\textsc{circulateVirtualSigs}($\mathrm{sigs}_{\mathrm{toRight}}$)
      and assign returned value to $\mathrm{sigs}_{\mathrm{byRight}}$
      \State store all signatures in $\mathrm{sigs}_{\mathrm{byRight}}$ that
      sign any of $\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$,
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{left}}$, $\mathrm{TX}_{\mathrm{loc},
      \mathrm{right}}$, $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$ and remove
      these signatures from $\mathrm{sigs}_{\mathrm{byRight}}$
      \State ensure that the stored signatures contain one valid signature for
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{right}}$ and
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$ which sign the
      \texttt{guest\_all} input by each one of the next $n-j$ hops
      \State ensure that there are exactly $4$ more valid signatures in the
      stored signatures, which sign the $\texttt{2} \wedge
      \texttt{right\_virt\_checked}$ inputs of $\mathrm{TX}_{\mathrm{loc},
      \mathrm{right}}$ and $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$ with
      $\pk{\mathrm{rem}, \mathrm{virt}}$ and $\pk{\mathrm{right},
      \mathrm{guest}}$
      \State output (\textsc{virtualSigsBack},
      $\mathrm{sigs}_{\mathrm{toLeft}}$, $\mathrm{sigs}_{\mathrm{byRight}}$)
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:sibling-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.intermediarySigs}()}
    \begin{algorithmic}[1]
      \State ($\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$,
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{left}}$, $\mathrm{TX}_{\mathrm{loc},
      \mathrm{right}}$, $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$) $\gets$
      \textsc{virt.getMidTXs}($c_{\mathrm{guest}}$, $c_P$, $c_{\bar{P}}$,
      $c_{\mathrm{sib}}$, $c_{\mathrm{sib}, \mathrm{rem}}$, $\pk{\mathrm{loc},
      F}$, $\pk{\mathrm{rem}, F}$, $\pk{\mathrm{sib}, F}$, $\pk{\mathrm{sib},
      \mathrm{rem} F}$, $\pk{\mathrm{rem}, \mathrm{virt}}$, $\pk{\mathrm{loc},
      \mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{virt}}$, $\pk{\mathrm{sib},
      \mathrm{rem}, \mathrm{virt}}$, $\pk{\mathrm{left}, \mathrm{guest}}$,
      $\pk{\mathrm{right}, \mathrm{guest}}$, $\pk{\mathrm{loc}, \mathrm{virt}}$,
      $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$)
      \State \Comment{not verifying our signatures in
      $\mathrm{sigs}_{\mathrm{byLeft}}$, our (trusted) \texttt{sibling} will do
      that}
      \State input (\textsc{virtual sigs forward},
      $\mathrm{sigs}_{\mathrm{byLeft}}$) to \texttt{sibling}
      \State \trustedcode{\textsc{virt.siblingSigs}()}
      \State $\mathrm{sigs}_{\mathrm{toLeft}} \gets
      \mathrm{sigs}_{\mathrm{byRight}} + \mathrm{sigs}_{\mathrm{toLeft}}$
      \If{\texttt{left\_data} does not contain data from a second-previous hop}
      \Comment{previous hop is \texttt{host\_funder}}
        \State $\mathrm{TX}_{\mathrm{prev}, \mathrm{none}}$ $\gets$
        \textsc{virt.getEdgeTXs}($c_{\mathrm{guest}}$, $c_{\bar{P}}$, $c_P$,
        $\pk{\mathrm{rem}, F}$, $\pk{\mathrm{loc}, F}$, $\pk{\mathrm{rem},
        \mathrm{virt}}$, $\pk{\mathrm{loc}, \mathrm{virt}}$, $\pk{\mathrm{loc},
        \mathrm{virt}}$, $\pk{\mathrm{left}, \mathrm{guest}}$,
        $\pk{\mathrm{right}, \mathrm{guest}}$, True)
      \EndIf
      \State \Return $\mathrm{sigs}_{\mathrm{toLeft}}$
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:intermediary-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.hostFundeeSigs}()}
    \begin{algorithmic}[1]
      \State $\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$ $\gets$
      \textsc{virt.getEdgeTXs}($c_{\mathrm{guest}}$, $c_P$, $c_{\bar{P}}$,
      $\pk{\mathrm{loc}, F}$, $\pk{\mathrm{rem}, F}$, $\pk{\mathrm{loc},
      \mathrm{virt}}$, $\pk{\mathrm{rem}, \mathrm{virt}}$,
      $\pk{\mathrm{left}, \mathrm{guest}}$, $\pk{\mathrm{right},
      \mathrm{guest}}$, False)
      \label{code:virtual-layer:fundee-sigs:tx-none}
      \For{each hop apart from the first and ours ($i \in [2, \dots, n-1]$)}
      \Comment{hop data encoded in \texttt{left\_data}}
        \State extract data needed for \textsc{getMidTXs}() from
        \texttt{left\_data} and assign it to $\texttt{data}_i$ and
        $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$
        \Comment{$\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$ contains each
        party's $\pk{i, \mathrm{virt}}$}
        \State ($\mathrm{TX}_{i, \mathrm{none}}$, $\mathrm{TX}_{i,
        \mathrm{left}}$, $\mathrm{TX}_{i, \mathrm{right}}$, $\mathrm{TX}_{i,
        \mathrm{both}}$) $\gets$ \textsc{virt.getMidTXs}($\texttt{data}_i$,
        $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$)
        \State add \textsc{sign}($\mathrm{TX}_{i, \mathrm{right}}$,
        $\sk{\mathrm{loc}, \mathrm{virt}}$, \textsc{anyprevout}) and
        \textsc{sign}($\mathrm{TX}_{i, \mathrm{both}}$, $\sk{\mathrm{loc},
        \mathrm{virt}}$, \textsc{anyprevout}) to
        $\mathrm{sigs}_{\mathrm{toLeft}}$ \Comment{if $i$-th hop is
        adjacent, $2$ signatures will be produced by each \textsc{sign}()
        invocation: one for the \texttt{guest\_all} and one for the
        $\texttt{2} \wedge \texttt{right\_virt\_checked}$ input}
        \State output (\textsc{sign TXs}, $\mathrm{TX}_{i, \mathrm{left}}$,
        $\mathrm{TX}_{i, \mathrm{right}}$, $\mathrm{TX}_{i, \mathrm{both}}$)
        to \texttt{fundee} and expect reply (\textsc{TXs signed},
        $\mathrm{sigs}_{\mathrm{guest}}$)
        \State add $\mathrm{sigs}_{\mathrm{guest}}$ to
        $\mathrm{sigs}_{\mathrm{toLeft}}$
        \If{$i = n - 1$} \Comment{hop is our previous}
          \State add \textsc{sign}($\mathrm{TX}_{i, \mathrm{left}}$,
          $\sk{\mathrm{loc}, \mathrm{virt}}$, \textsc{anyprevout}) to
          $\mathrm{sigs}_{\mathrm{toLeft}}$
        \EndIf
      \EndFor
      \State \Return $\mathrm{sigs}_{\mathrm{toLeft}}$
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:fundee-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.hostFunderSigs}()}
    \begin{algorithmic}[1]
      \For{each hop apart from the last and ours ($i \in [2, \dots, n-1]$)}
      \Comment{hop data encoded in \texttt{right\_data}}
        \State extract data needed for \textsc{getMidTXs}() from
        \texttt{right\_data} and assign it to $\texttt{data}_i$ and
        $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$
        \Comment{$\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$ contains each
        party's $\pk{i, \mathrm{virt}}$}
        \State ($\mathrm{TX}_{i, \mathrm{none}}$, $\mathrm{TX}_{i,
        \mathrm{left}}$, $\mathrm{TX}_{i, \mathrm{right}}$, $\mathrm{TX}_{i,
        \mathrm{both}}$) $\gets$ \textsc{virt.getMidTXs}($\texttt{data}_i$,
        $\{\pk{\mathrm{sec}, i}\}_{i \in 1 \dots n}$)
        \State add \textsc{sign}($\mathrm{TX}_{i, \mathrm{right}}$,
        $\sk{\mathrm{loc}, \mathrm{virt}}$, \textsc{anyprevout}) and
        \textsc{sign}($\mathrm{TX}_{i, \mathrm{both}}$, $\sk{\mathrm{loc},
        \mathrm{virt}}$, \textsc{anyprevout}) to
        $\mathrm{sigs}_{\mathrm{toRight}}$ \Comment{if $i$-th hop is
        adjacent, $2$ signatures will be produced by each \textsc{sign}()
        invocation: one for the \texttt{guest\_all} and one for the
        $\texttt{2} \wedge \texttt{right\_virt\_checked}$ input}
        \State output (\textsc{sign TXs}, $\mathrm{TX}_{i, \mathrm{left}}$,
        $\mathrm{TX}_{i, \mathrm{right}}$, $\mathrm{TX}_{i, \mathrm{both}}$)
        to \texttt{fundee} and expect reply (\textsc{TXs signed},
        $\mathrm{sigs}_{\mathrm{guest}}$)
        \State add $\mathrm{sigs}_{\mathrm{guest}}$ to
        $\mathrm{sigs}_{\mathrm{toRight}}$
        \If{$i = 2$} \Comment{hop is our next}
          \State add \textsc{sign}($\mathrm{TX}_{i, \mathrm{left}}$,
          $\sk{\mathrm{loc}, \mathrm{virt}}$, \textsc{anyprevout}) to
          $\mathrm{sigs}_{\mathrm{toRight}}$
        \EndIf
      \EndFor
      \State call
      \textsc{virt.circulateVirtualSigs}($\mathrm{sigs}_{\mathrm{toRight}}$)
      of $P$ and assign output to $\mathrm{sigs}_{\mathrm{byRight}}$
      \State $\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$ $\gets$
      \textsc{virt.getEdgeTXs}($c_{\mathrm{guest}}$, $c_P$, $c_{\bar{P}}$,
      $\pk{\mathrm{loc}, F}$, $\pk{\mathrm{rem}, F}$, $\pk{\mathrm{loc},
      \mathrm{virt}}$, $\pk{\mathrm{rem}, \mathrm{virt}}$, $\pk{\mathrm{left},
      \mathrm{guest}}$, $\pk{\mathrm{right}, \mathrm{guest}}$, True)
      \label{code:virtual-layer:funder-sigs:tx-none}
      \State \Return (\textsc{ok})
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:funder-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.circulateVirtualSigs}($\mathrm{sigs}_{\mathrm{byLeft}}$)}
    \begin{algorithmic}[1]
      \If{$\mathrm{sigs}_{\mathrm{byLeft}}$ is given as argument} \Comment{we
      are not \texttt{host\_funder}}
        \If{we have a \texttt{sibling}} \Comment{we are not
        \texttt{host\_fundee}}
          \State \Return \textsc{virt.intermediarySigs}()
        \Else \: \Comment{we are \texttt{host\_fundee}}
          \State \Return \textsc{virt.hostFundeeSigs}()
        \EndIf
      \Else \: \Comment{we are \texttt{host\_funder}}
        \State \Return \textsc{virt.hostFunderSigs}()
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:virtual-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.circulateFundingSigs}($\mathrm{sig}_{\mathrm{loc},
  \mathrm{none}}$)}
    \begin{algorithmic}[1]
      \If{$\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$ is given as argument}
      \Comment{we are not \texttt{host\_funder}}
        \State ensure \textsc{verify}($\mathrm{TX}_{\mathrm{loc},
        \mathrm{none}}$, $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$,
        $\pk{\mathrm{prev}, F}$) = True \Comment{$\pk{\mathrm{prev}, F}$, found
        in \texttt{left\_data}}
        \State $\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}} \gets \{
        \mathrm{sig}_{\mathrm{loc}, \mathrm{none}} \}$
        \If{we have a \texttt{sibling}} \Comment{we are not \texttt{host\_fundee}}
          \State input (\textsc{virtual base sig forward},
          $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$) to \texttt{sibling}
          \Comment{\texttt{sibling} needs $\mathrm{sig}_{\mathrm{loc},
          \mathrm{none}}$ for closing}
          \State \trustedcode{$\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}} \gets
          \{ \mathrm{sig}_{\mathrm{loc}, \mathrm{none}} \}$}
          \State \trustedcode{$\mathrm{sig}_{\mathrm{next}, \mathrm{none}} \gets
          \textsc{sign}(\mathrm{TX}_{\mathrm{next}, \mathrm{none}},
          \sk{\mathrm{loc}, F})$}
          \State \trustedcode{call
          \textsc{virt.circulateVirtualSigs}($\mathrm{sig}_{\mathrm{next},
          \mathrm{none}}$) of $\bar{P}$ and assign returned value to
          $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$}
          \State \trustedcode{ensure \textsc{verify}($\mathrm{TX}_{\mathrm{loc},
          \mathrm{none}}$, $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$,
          $\pk{\mathrm{next}, F}$) = True} \Comment{$\pk{\mathrm{next}, F}$,
          found in \texttt{right\_data}}
          \State \trustedcode{add $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$
          to $\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}}$}
          \State \trustedcode{output (\textsc{virtual base sig back},
          $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$) \Comment{sibling needs
          $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$ for closing}}
          \State add $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$ to
          $\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}}$
        \EndIf
        \State $\mathrm{sig}_{\mathrm{prev}, \mathrm{none}} \gets
        \textsc{sign}(\mathrm{TX}_{\mathrm{prev}, \mathrm{none}},
        \sk{\mathrm{loc}, F})$
        \State \Return $\mathrm{sig}_{\mathrm{prev}, \mathrm{none}}$
      \Else \: \Comment{we are \texttt{host\_funder}}
        \State $\mathrm{sig}_{\mathrm{next}, \mathrm{none}} \gets
        \textsc{sign}(\mathrm{TX}_{\mathrm{next}, \mathrm{none}},
        \sk{\mathrm{loc}, F})$
        \State call
        \textsc{virt.circulateFundingSigs}($\mathrm{sig}_{\mathrm{next},
        \mathrm{none}}$) of $\bar{P}$ and assign returned value to
        $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$
        \State ensure \textsc{verify}($\mathrm{TX}_{\mathrm{loc},
        \mathrm{none}}$, $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$,
        $\pk{\mathrm{next}, F}$) = True \Comment{$\pk{\mathrm{next}, F}$ found
        in \texttt{right\_data}}
        \State $\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}} \gets \{
        \mathrm{sig}_{\mathrm{loc}, \mathrm{none}} \}$
        \State \Return (\textsc{ok})
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:funding-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.circulateRevocations}(\texttt{revoc\_by\_prev})}
    \begin{algorithmic}[1]
    \If{\texttt{revoc\_by\_prev} is given as argument} \Comment{we are not
    \texttt{host\_funder}}
      \State ensure
      \texttt{guest}.\textsc{processRemoteRevocation}(\texttt{revoc\_by\_prev})
      returns (\textsc{ok})
      \label{code:virtual-layer:revocation:non-funder:proc-remote}
    \Else \: \Comment{we are \texttt{host\_funder}}
      \State $\texttt{revoc\_for\_next} \gets
      \texttt{guest}.\textsc{revokePrevious}()$
      \State input (\textsc{read}) to \ledger and assign ouput to $\Sigma$
      \State $\texttt{last\_poll} \gets |\Sigma|$
      \State call \textsc{virt.circulateRevocations}(\texttt{revoc\_for\_next})
      of $\bar{P}$ and assign returned value to \texttt{revoc\_by\_next}
      \label{code:virtual-layer:revocation:revoc-by-next}
      \State ensure
      \texttt{guest}.\textsc{processRemoteRevocation}(\texttt{revoc\_by\_next})
      returns (\textsc{ok}) \Comment{If the ``ensure'' fails, the opening
      process freezes, this is intentional. The channel can still close via
      (\textsc{close})}
      \label{code:virtual-layer:revocation:funder:proc-remote}
      \State \Return (\textsc{ok})
    \EndIf
    \If{we have a \texttt{sibling}} \Comment{we are not \texttt{host\_fundee}
    nor \texttt{host\_funder}}
      \State input (\textsc{virtual revocation forward}) to \texttt{sibling}
      \State \trustedcode{$\texttt{revoc\_for\_next} \gets
      \texttt{guest}.\textsc{revokePrevious}()$}
      \State input (\textsc{read}) to \ledger and assign ouput to $\Sigma$
      \State $\texttt{last\_poll} \gets |\Sigma|$
      \State \trustedcode{call
      \textsc{virt.circulateRevocations}(\texttt{revoc\_for\_next}) of $\bar{P}$
      and assign output to \texttt{revoc\_by\_next}}
      \State \trustedcode{ensure
      \texttt{guest}.\textsc{processRemoteRevocation}(\texttt{revoc\_by\_next})
      returns (\textsc{ok})}
      \State \trustedcode{output (\textsc{hosts ready}) to \texttt{guest} and
      expect reply (\textsc{host ack})}
      \State \trustedcode{output (\textsc{virtual revocation back})}
    \EndIf
    \State $\texttt{revoc\_for\_prev} \gets
    \texttt{guest}.\textsc{revokePrevious}()$
    \State output (\textsc{hosts ready}) to \texttt{guest} and expect reply
    (\textsc{host ack})
    \label{code:virtual-layer:revocation:hosts-ready}
    \State \Return \texttt{revoc\_for\_prev} \Comment{we are not
    \texttt{host\_fundee} nor \texttt{host\_funder}}
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:revocation}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt} -- poll}
    \begin{algorithmic}[1]
      \State On input (\textsc{check for lateral close}) by $R \in$
      \{\texttt{guest}, \texttt{funder}, \texttt{fundee}\}:
      \Indent
        \State input (\textsc{read}) to \ledger and assign output to $\Sigma$
        \State $\texttt{prev\_went\_on\_chain} \gets \mathrm{TX}_{\mathrm{prev},
        \mathrm{left}} \in \Sigma \vee \mathrm{TX}_{\mathrm{prev},
        \mathrm{none}} \in \Sigma$
        \State $\texttt{next\_went\_on\_chain} \gets \mathrm{TX}_{\mathrm{next},
        \mathrm{right}} \in \Sigma \vee \mathrm{TX}_{\mathrm{next},
        \mathrm{none}} \in \Sigma$
        \State $\texttt{last\_poll} \gets |\Sigma|$
        \If{$\texttt{prev\_went\_on\_chain} \vee
        \texttt{next\_went\_on\_chain}$}
          \State ignore all messages except for (\textsc{check chain for
          closing}) by $R$
          \State $\textit{State} \gets \textsc{closing}$
        \EndIf
        \If{$\texttt{prev\_went\_on\_chain} \wedge
        \texttt{next\_went\_on\_chain}$}
          \State
          \textsc{virt}.\textsc{signAndSubmit}($\mathrm{TX}_{\mathrm{loc},
          \mathrm{both}}$, $\mathrm{sigs}_{\mathrm{loc}, \mathrm{both}}$)
        \ElsIf{\texttt{prev\_went\_on\_chain}}
          \State
          \textsc{virt}.\textsc{signAndSubmit}($\mathrm{TX}_{\mathrm{loc},
          \mathrm{left}}$, $\mathrm{sigs}_{\mathrm{loc}, \mathrm{left}}$)
        \ElsIf{\texttt{next\_went\_on\_chain}}
          \State
          \textsc{virt}.\textsc{signAndSubmit}($\mathrm{TX}_{\mathrm{loc},
          \mathrm{right}}$, $\mathrm{sigs}_{\mathrm{loc}, \mathrm{right}}$)
        \EndIf
      \EndIndent
      \Statex

      \State \textsc{virt}.\textsc{signAndSubmit}(tx, sigs):
      \Indent
        \State add \textsc{sign}(tx, $\sk{\mathrm{loc}, F}$) to sigs
        \State input (\textsc{submit}, tx, sigs) to \ledger
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:poll}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt} -- close}
    \begin{algorithmic}[1]
      \State On input (\textsc{close}) by $R \in \{\texttt{guest},
      \texttt{funder}, \texttt{fundee}\}$: \Comment{At most one of
      \texttt{funder}, \texttt{fundee} is defined}
      \Indent
        \IfThen{\textit{State} = \textsc{closed}}{output (\textsc{closed}) to
        $R$}
        \IfThen{\textit{State} = \textsc{guest punished}}{output (\textsc{guest
        punished}) to $R$}
        \label{code:virtual-layer:close:output-guest-punished}
        \State ensure \textit{State} = \textsc{open}
        \If{$\texttt{host}_P \neq \ledger$} \Comment{$\texttt{host}_P$ is a
        \textsc{virt}}
          \State ignore all messages except for output (\textsc{closed}) by
          $\texttt{host}_P$. Also relay to $\texttt{host}_P$ any (\textsc{check
          chain for closing}) input received
          \State input (\textsc{close}) to $\texttt{host}_P$
        \EndIf
        \State \Comment{if we have a $\texttt{host}_P$, continue from here on
        output (\textsc{closed}) by it}
        \State send (\textsc{read}) to \ledger as $R$ and assign reply to
        $\Sigma$
        \State let \texttt{tx} be the unique valid TX for $\Sigma$ among
        ($\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$,
        $\mathrm{TX}_{\mathrm{loc}, \mathrm{left}}$, $\mathrm{TX}_{\mathrm{loc},
        \mathrm{right}}$, $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$)
        \Comment{if we are not an intermediary, only the first exists}
        \label{code:virtual-layer:close:tx}
        \State let \texttt{sigs} be the corresponding set of signatures among
        ($\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}}$,
        $\mathrm{sigs}_{\mathrm{loc}, \mathrm{left}}$,
        $\mathrm{sigs}_{\mathrm{loc}, \mathrm{right}}$,
        $\mathrm{sigs}_{\mathrm{loc}, \mathrm{both}}$)
        \State add \textsc{sign}(\texttt{tx}, $\sk{A, F}$) and
        \textsc{sign}(\texttt{tx}, $\sk{\mathrm{loc}, \mathrm{virt}}$) to
        \texttt{sigs} \Comment{one of the two signatures may be empty, as some
        transactions don't need a signature by both keys. This is not a
        problem.}
        \State ignore all messages except for (\textsc{check chain for closing})
        by $R$
        \State $\textit{State} \gets \textsc{closing}$
        \State send (\textsc{submit}, (\texttt{tx}, \texttt{sigs})) to \ledger
      \EndIndent
      \Statex

      \State On (\textsc{check chain for closing}) by $R \in \{\texttt{guest},
      \texttt{funder}, \texttt{fundee}\}$:
      \Indent
        \State ensure \textit{State} = \textsc{closing}
        \State send (\textsc{read}) to \ledger as $R$ and assign reply to
        $\Sigma$
        \If{$R = \texttt{guest}$}
          \State $\pk{1} \gets \pk{\mathrm{left}, \mathrm{guest}}$; $\pk{2}
          \gets \pk{\mathrm{right}, \mathrm{guest}}$
        \Else \: \Comment{$R \in \{\texttt{funder}, \texttt{fundee}\}$}
          \State $\pk{1} \gets \pk{\mathrm{loc}, \mathrm{virt}}$; $\pk{2} \gets
          \pk{\mathrm{rem}, \mathrm{virt}}$
        \EndIf
        \If{$\Sigma$ has an unspent output that can be spent exclusively by a
        2-of-\{$\pk{1}$, $\pk{2}$\} multisig} \Comment{if there is a timelock,
        it must have expired}
        \label{code:virtual-layer:close:when-closed}
          \State $\textit{State} \gets \textsc{closed}$
          \State output (\textsc{closed}) to $R$
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:close}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt} -- punishment handling}
    \begin{algorithmic}[1]
      \State On input (\textsc{used revocation}) by \texttt{guest}:
      \Comment{(\textsc{used revocation}) by \texttt{funder}/\texttt{fundee} is
      ignored}
      \label{code:virtual-layer:punishment:when-punished-1}
      \Indent
        \State $\textit{State} \gets \textsc{guest punished}$
        \State input (\textsc{used revocation}) to $\texttt{host}_P$, expect
        reply (\textsc{used revocation ok})
        \If{\texttt{funder} or \texttt{fundee} is defined}
          \State output (\textsc{enabler used revocation}) to it
        \Else \: \Comment{\texttt{sibling} is defined}
          \State output (\textsc{enabler used revocation}) to \texttt{sibling}
        \EndIf
      \EndIndent
      \Statex

      \State On input (\textsc{enabler used revocation}) by \texttt{sibling}:
      \Indent
        \State $\textit{State} \gets \textsc{guest punished}$
        \State output (\textsc{enabler used revocation}) to \texttt{guest}
      \EndIndent
      \Statex

      \State On output (\textsc{used revocation}) by $\texttt{host}_P$:
      \label{code:virtual-layer:punishment:when-punished-2}
      \Indent
        \State $\itistate \gets \textsc{guest punished}$
        \If{\texttt{funder} or \texttt{fundee} is defined}
          \State output (\textsc{enabler used revocation}) to it
        \Else \: \Comment{\texttt{sibling} is defined}
          \State output (\textsc{enabler used revocation}) to \texttt{sibling}
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:punishment}
\end{figure}
