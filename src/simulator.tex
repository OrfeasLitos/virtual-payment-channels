\begin{figure}[H]
  \begin{simulatorbox}{\simulator}
    \begin{itemize}
      \item On receiving (\textsc{relay}, \texttt{in\_msg}, $P$, $R$,
      \texttt{in\_mode}) by \fchan (\texttt{in\_mode} $\in$ \{input, output,
      network\}, $P \in \{\alice, \bob\}$), handle (\texttt{in\_msg}) with the
      simulated party $P$ as if it was received from $R$ by means of
      \texttt{in\_mode}. In case simulated $P$ does not exist yet, initialise it
      as an \textsc{ln} ITI. If there is a resulting message \texttt{out\_msg}
      that is to be sent by simulated $P$ to $R'$ by means of
      $\texttt{out\_mode} \in$ \{input, output, network\}, send (\textsc{relay},
      \texttt{out\_msg}, $P$, $R'$, \texttt{out\_mode}) to \fchan.
      \item On receiving by \fchan a message to be sent by $P$ to $R$ via the
      network, carry on with this action (i.e. send this message via the
      internal \adversary).
      \item Relay any other incoming message to the internal \adversary
      unmodified.
      \item On receiving a message (\texttt{msg}) by the internal \adversary, if it is
      addressed to one of the parties that correspond to \fchan, handle the
      message internally with the corresponding simulated party. Otherwise relay
      the message to its intended recipient unmodified. \Comment{Other
      recipients are \environment, \ledger or parties unrelated to \fchan}
    \end{itemize}

    Given that \fchan relays all messages and that we simulate the real-world
    machines that correspond to \fchan, the simulation is perfectly
    indistinguishable from the real world.
  \end{simulatorbox}
\end{figure}

\begin{figure}[H]
  \begin{simulatorbox}{\simulator -- Pt. 1}
    \begin{algorithmic}[1]
      \State On $(\textsc{open}, c_F, \pk{A, \mathrm{out}}, \pk{B,
      \mathrm{out}}, F, \mathrm{sig}_F \alice)$ by \fchan: \Comment{both honest}
      \Indent
        \State simulate \alice receiving input $(\textsc{open}, c_F, \pk{A,
        \mathrm{out}}, \pk{B, \mathrm{out}})$ by \environment
        \State ensure simulated \alice inputs (\textsc{submit}, $(F',
        \mathrm{sig}_{F'})$) to \ledger
        \State input (\textsc{submit}, $(F, \mathrm{sig}_F)$) to \ledger
      \EndIndent
      \Statex

      \State On $(\textsc{open}, c_F, \pk{A, \mathrm{out}}, \pk{B,
      \mathrm{out}}, \pk{B, F}, \bob)$ by \fchan: \Comment{\alice corrupted}
      \Indent
        \State send LN message (\textsc{open}, $\pk{B, F}$) to \alice and relay
        reply to \fchan \TODO{change msg to fit LN, ensure \alice doesn't see a
        difference from real world}
      \EndIndent
      \Statex

      \State On (\textsc{pay}, $x$, \dave) by \fchan:
      \Indent
        \If{both channel parties are honest}
          \State simulate \dave receiving input (\textsc{pay}, $x$) by
          \environment
          \State ensure simulated \dave outputs (\textsc{ok})
          \State send (\textsc{ok}) to \fchan
        \ElsIf{only \dave's counterparty is corrupted} \Comment{else just relay
        to \adversary}
          \State simulate \dave receiving input (\textsc{pay}, $x$) by
          \environment
          \State ensure simulated \dave outputs (\textsc{ok})
          \State extract the latest commitment transaction $C$ and its signature
          by \dave's counterparty $\mathrm{sig}_{\bar{D}, C}$ from simulated
          \dave's state
          \State send $(C, \mathrm{sig}_{\bar{D}, C})$ to \fchan
        \EndIf
      \EndIndent
      \Statex

      \State On (\textsc{fund you}, $c$, \bob, \charlie, \alice) by \fchan:
      \Indent
        \State simulate \alice receiving input (\textsc{fund you}, $c$, \bob) by
        \charlie
        \State ensure simulated \alice outputs (\textsc{ok}) to \charlie
        \State send (\textsc{ok}) to \fchan
      \EndIndent
      \Statex

      \State On (\textsc{fund} $c$, hops, \texttt{sub\_parties} = (fundee,
      counterparty), \texttt{outer\_parties} = (\charlie, \dave),
      \texttt{funder} = \alice, id) by \fchan:
      \label{code:simulator:fund}
      \Indent
        \State add the message data to \texttt{virtual\_opening}
        \State simulate execution of
        line~\ref{code:functionality:chan:skeleton:virtual:fund:init} of
        Fig.~\ref{code:functionality:chan:skeleton:virtual} with \alice
        \Comment{\simulator knows \bob (\alice's counterparty) through opening
        procedure}
        \State send (\textsc{ok}) to \fchan
        \label{code:simulator:fund:ok}
      \EndIndent
      \Statex

      \State On (\textsc{allow fund}, $c$, \texttt{sub\_parties},
      \texttt{local\_funder} = $L_i$, id, $i \overset{?}{=} |\mathrm{hops}|$) by
      \fchan's \alice to \charlie:
      \Indent
        \State simulate receiving message with \charlie by \alice and all
        subsequent communication
        \State ensure the simulated \charlie sends (\textsc{ok}) to the
        simulated \alice
        \State intercept this message and send it to \fchan's \alice
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{code:simulator:pt1}
\end{figure}

\begin{figure}[H]
  \begin{simulatorbox}{\simulator -- Pt. 2}
    \begin{algorithmic}[1]
      \State On (\textsc{is open successful}, id) by \fchan:
      \Indent
        \State retrieve and remove from \texttt{virtual\_opening} the data
        marked with id
        \State simulate line~\ref{code:protocol:chan:skeleton:vchan} of
        Fig.~\ref{code:protocol:chan:skeleton:virtual} with \alice using this
        data
        \State ensure \alice completes execution of VChan() successfully
        \State send (\textsc{ok}) to \fchan
      \EndIndent
      \Statex

      \State On (\textsc{update to virtual} ) by \fchan:
      \Indent
        \State retrieve and remove from \texttt{virtual\_opening} the data
        marked with id
        \State simulate line~\ref{code:protocol:chan:skeleton:vchan} of
        Fig.~\ref{code:protocol:chan:skeleton:virtual} with \alice using this
        data
        \State ensure \alice completes execution of VChan() successfully
        \State extract from \alice's state the new virtual funding TX $V$ for
        pre-existing channel
        \State extract from \alice's state the new commitment TX $C$ that spends
        the on-chain funding TX
        \State send ($V$, $C$) to \fchan
      \EndIndent
      \Statex

      \State On (\textsc{fund done}, id) by \fchan's \alice to \charlie:
      \Indent
        \State simulate receiving message with \charlie by \alice and all
        subsequent communication
        \State ensure the simulated \charlie sends (\textsc{ok}) to the
        simulated \alice
        \State intercept this message and send it to \fchan's \alice
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{code:simulator}
\end{figure}
