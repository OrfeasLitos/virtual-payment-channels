\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- init}
    \begin{algorithmic}[1]
      \State \Comment{When not specified, input comes from and output goes to
      \environment in the real or $P \in \{\alice, \bob\}$ in the ideal world.}
      \State \Comment{In the real world, the player knows whether it is \alice
      (funder) or \bob (fundee). The activated party is $P$ and the counterparty
      is $\bar{P}$.}
      \State On (\textsc{init}, $\pk{P, \mathrm{out}}$):
      \Indent
        \State ensure $\textit{State}^P = \bot$
        \State $\textit{State}^P \gets \textsc{init}$
        \State store $\pk{P, \mathrm{out}}$
        \State $(c_A, c_B) \gets (0, 0)$
        \State $(\texttt{paid\_out}, \texttt{paid\_in}) \gets (\emptyset,
        \emptyset)$
        \State output (\textsc{init ok})
      \EndIndent
      \Statex

      \State On (\textsc{top up}):
      \Indent
        \State ensure $P = \alice$ \Comment{activated party is the funder}
        \State ensure $\textit{State}^P = \textsc{init}$
        \State $(\sk{P, \mathrm{chain}}, \pk{P, \mathrm{chain}}) \gets
        \textsc{keyGen}()$
        \State input (\textsc{read}) to \ledger as $P$ and assign ouput to
        $\Sigma$
        \State output (\textsc{top up to}, $\pk{P, \mathrm{chain}}$)
        \While{$\nexists \mathrm{tx} \in \Sigma, c_{P, \mathrm{chain}}: (c_{P,
        \mathrm{chain}}, \pk{P, \mathrm{chain}}) \in \mathrm{tx.outputs}$}
          \State output
          \State \Comment{while waiting, all other messages by $P$ are ignored}
          \State wait for input (\textsc{check top up})
          \State input (\textsc{read}) to \ledger as $P$ and assign ouput to
          $\Sigma$
        \EndWhile
        \State $\textit{State}^P \gets \textsc{topped up}$
        \State output (\textsc{top up ok}, $c_{P, \mathrm{chain}}$)
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:init}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- methods used by \textsc{virt}}
    \begin{algorithmic}[1]
      \State \textsc{getCommTX}($c_A$, $c_B$, $\pk{A, F}$, $\pk{A,
      \mathrm{out}}$, $\pk{A, R}$, $\pk{B, F}$, $\pk{B, \mathrm{out}}$, $\pk{B,
      R}$, $P$):
      \Indent
        \State $C_{P, i+1} \gets$ TX \{input: ($c_A + c_B$, $\texttt{3} \wedge
        2/\{\pk{A, F}, \pk{B, F}\}$), outputs: (($c_A$, $(\pk{A, \mathrm{out}} +
        t) \vee 2/\{\pk{A, R}, \pk{B, R}\}$), ($c_B$, $\pk{B, \mathrm{out}}$))\}
        \State \Return $C_{P, i+1}$
      \EndIndent
      \Statex

      \State \textsc{getCommKeys}():
      \Indent
        \State \Return $(\pk{A, F}, \pk{A, \mathrm{out}}, \pk{A, R}), (\pk{B,
        F}, \pk{B, \mathrm{out}}, \pk{B, R})$
      \EndIndent
      \Statex

      \State \textsc{revokePrevious}():
      \Indent
        \State $R_{B, i} \gets$ TX \{input: $C_{A, i}$.outputs.\alice, output:
        ($C_{A, i}$.outputs.\alice.value, $pk_{B, \mathrm{out}}$)\}
        \State $\mathrm{sig}_{A, R, i} \gets \textsc{sign}(R_{B, i}, \sk{A, R})$
        \State \Return $\mathrm{sig}_{A, R, i}$
      \EndIndent
      \Statex

      \State \textsc{processRemoteReovcation}($\mathrm{sig}_{B, R, i}$):
      \Indent
        \State $R_{A, i} \gets$ TX \{input: $C_{B, i}$.outputs.\bob, output:
        ($C_{B, i}$.outputs.\bob.value, $pk_{A, \mathrm{out}}$)\}
        \State ensure \textsc{verify}($R_{A, i}$, $\mathrm{sig}_{B, R, i}$,
        $\pk{B, R}$) = True
        \State \Return (\textsc{ok})
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:methods-for-virt}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln.exchangeOpenKeys}()}
    \begin{algorithmic}[1]
      \State $(\sk{A, F}, \pk{A, F}) \gets \textsc{keyGen}()$;
      $(\sk{A, R}, \pk{A, R}) \gets \textsc{keyGen}()$
      \If{ideal world}
        \State ensure $\textit{State}^B = \textsc{init}$
        \State $(\sk{B, F}, \pk{B, F}) \gets \textsc{keyGen}()$; $(\sk{B, R},
        \pk{B, R}) \gets \textsc{keyGen}()$
      \Else \: \Comment{real world}
        \State $\textit{State}^A \gets \textsc{waiting for opening keys}$
        \State send (\textsc{open channel}, $c$, \texttt{hosts}, $\pk{A, F}$,
        $\pk{A, R}$, $\pk{A, \mathrm{out}}$) to \texttt{fundee}
        \State \Comment{colored code is run by honest \texttt{fundee}.
        Validation is implicit}
        \State \remotecode{ensure $\textit{State}^B = \textsc{init}$}
        \State \remotecode{store $\pk{A, F}$, $\pk{A, R}$, $\pk{A,
        \mathrm{out}}$}
        \State \remotecode{$(\sk{B, F}, \pk{B, F}) \gets \textsc{keyGen}()$;
        $(\sk{B, R}, \pk{B, R}) \gets \textsc{keyGen}()$}
        \If{\remotecode{\texttt{hosts} = \ledger}} \Comment{opening base
        channel}
          \State \remotecode{$\textit{State}^B \gets \textsc{waiting for comm
          sig}$}
        \Else \: \Comment{opening virtual channel}
          \State \remotecode{$\textit{State}^B \gets \textsc{waiting for host}$}
        \EndIf
        \State \remotecode{reply (\textsc{accept channel}, $\pk{B, F}$,
        $\pk{B, R}$, $\pk{B, \mathrm{out}}$)}
        \State ensure $\textit{State}^A = \textsc{waiting for opening keys}$
        \State store $\pk{B, F}$, $\pk{B, R}$, $\pk{B, \mathrm{out}}$
        \State $\textit{State}^A \gets \textsc{opening keys ok}$
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:exchange-open-keys}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln.prepareBase}()}
    \begin{algorithmic}[1]
      \If{\texttt{hosts} = \ledger} \Comment{opening base channel}
        \State $F \gets$ TX \{input: $(c, \pk{A, \mathrm{chain}})$, output: $(c,
        \texttt{3} \wedge 2/\{\pk{A, F}, \pk{B, F}\})$\}
        \label{code:ln:base:create-funding}
        \If{ideal world}
          \State $\textit{State}^B \gets \textsc{waiting to check funding}$
        \EndIf
      \Else \: \Comment{opening virtual channel}
        \If{ideal world}
          \State input (\textsc{host me}, \alice, \bob, \texttt{hosts}, $c$,
          $\pk{A, F}$, $\pk{B, F}$) to \texttt{hosts}[0].\texttt{left} and
          expect output (\textsc{hosts ready}) to \texttt{fundee} by
          \texttt{hosts}[1].\texttt{right} \Comment{ignore any other message}
          \State input (\textsc{host ack}) as \texttt{fundee} to
          \texttt{hosts}[1].\texttt{right} and expect output (\textsc{hosts
          ready}) to \texttt{funder} by \texttt{hosts}[0].\texttt{left}
          \TODO{make this work with \textsc{virt}}
          \TODO{use \texttt{left} similarly in \textsc{virt}}
        \Else \: \Comment{real world}
          \State input (\textsc{host me}, \alice, \bob, \texttt{hosts}, $c$,
          $\pk{A, F}$, $\pk{B, F}$) to \texttt{hosts}[0].\texttt{left} and expect
          reply (\textsc{hosts ready}) \Comment{ignore any other message}
        \EndIf
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:prepare-base}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln.exchangeOpenSigs}()}
    \begin{algorithmic}[1]
      \State $C_{A, 0} \gets$ TX \{input: $(c, \texttt{3} \wedge 2/\{\pk{A, F},
      \pk{B, F}\})$, outputs: ($c$, ($\pk{A, \mathrm{out}} + t$) $\vee$
      $2/\{\pk{A, R}, \pk{B, R}\}$), ($0$, $\pk{B, \mathrm{out}}$)\}
      \State $C_{B, 0} \gets$ TX \{input: $(c, \texttt{3} \wedge 2/\{\pk{A, F},
      \pk{B, F}\})$, outputs: ($c$, $\pk{A, \mathrm{out}}$), ($0$, ($\pk{B,
      \mathrm{out}} + t$) $\vee$ $2/\{\pk{A, R}, \pk{B, R}\}$)\}
      \State $\mathrm{sig}_{A, C, 0} \gets \textsc{sign}(C_{B, 0}, \sk{A, F})$
      \State $\textit{State}^A \gets \textsc{waiting for comm sig}$
      \State send (\textsc{funding created}, $(c, \pk{A, \mathrm{chain}})$,
      $\mathrm{sig}_{A, C, 0}$) to \texttt{fundee}
      \State \remotecode{ensure $\textit{State}^B = \textsc{waiting for comm
      sig}$} \Comment{if opening virtual channel, we have received
      (\textsc{hosts ready}) by \texttt{hosts}[-1].\texttt{right}
      (c.f. Fig~\ref{code:ln:bob}, line~\ref{code:ln:bob:host})} \TODO{do this
      exchange in last hop, \textsc{virt}}
      \If{\remotecode{\texttt{hosts} = \ledger}} \Comment{opening base channel}
        \State \remotecode{$F \gets$ TX \{input: $(c, \pk{A, \mathrm{chain}})$,
        output: $(c, \texttt{3} \wedge 2/\{\pk{A, F}, \pk{B, F}\})$\}}
      \EndIf
      \State \remotecode{$C_{B, 0} \gets$ TX \{input: $(c, \texttt{3} \wedge
      2/\{\pk{A, F}, \pk{B, F}\})$, outputs: ($c$, $\pk{A, \mathrm{out}}$),
      ($0$, ($\pk{B, \mathrm{out}} + t$) $\vee$ $2/\{\pk{A, R}, \pk{B, R}\}$)\}}
      \State \remotecode{ensure \textsc{verify}($C_{B, 0}$, $\mathrm{sig}_{A, C,
      0}$, $\pk{A, F}$) = True}
      \State \remotecode{$C_{A, 0} \gets$ TX \{input: $(c, \texttt{3} \wedge
      2/\{\pk{A, F}, \pk{B, F}\})$, outputs: ($c$, ($\pk{A, \mathrm{out}} + t$)
      $\vee$ $2/\{\pk{A, R}, \pk{B, R}\}$), ($0$, $\pk{B, \mathrm{out}}$)\}}
      \State \remotecode{$\mathrm{sig}_{B, C, 0} \gets \textsc{sign}(C_{A, 0},
      \sk{B, F})$}
      \If{\remotecode{\texttt{hosts} = \ledger}} \Comment{opening base channel}
        \State \remotecode{$\textit{State}^B \gets \textsc{waiting to check
        funding}$}
      \Else \: \Comment{opening virtual channel}
        \State \remotecode{$c_A \gets c$; $c_B \gets 0$; $i \gets 0$}
        \State \remotecode{$\textit{State}^B \gets \textsc{open}$}
      \EndIf
      \State \remotecode{reply (\textsc{funding signed}, $\mathrm{sig}_{B, C,
      0}$)}
      \State ensure $\textit{State}^A = \textsc{waiting for comm sig}$
      \State ensure \textsc{verify}($C_{A, 0}$, $\mathrm{sig}_{B, C, 0}$,
      $\pk{B, F}$) = True
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:exchange-open-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln.commitBase}()}
    \begin{algorithmic}[1]
      \State $\mathrm{sig}_F \gets \textsc{sign}(F, \sk{A, \mathrm{chain}})$
      \label{code:ln:base:sign-funding}
      \State send $(\textsc{open}, c, \pk{A, \mathrm{out}}, \pk{B,
      \mathrm{out}}, F, \mathrm{sig}_F, \alice, \bob)$ to \adversary
      \While{$F \notin \Sigma$}
        \State wait for input (\textsc{check funding}) \Comment{ignore all other
        messages}
        \State input (\textsc{read}) to \ledger as $P$ and assign output to
        $\Sigma$
      \EndWhile
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:commit-base}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- external open messages for \bob}
    \begin{algorithmic}[1]
      \State On input (\textsc{check funding}): \Comment{real or ideal world}
      \Indent
        \State ensure $\textit{State}^B = \textsc{waiting to check funding}$
        \State input (\textsc{read}) to \ledger and assign output to $\Sigma$
        \If{$F \in \Sigma$}
          \State $\textit{State}^B \gets \textsc{open}$
          \State reply (\textsc{open ok})
        \EndIf
      \EndIndent
      \Statex

      \State On (\textsc{hosts ready}) by \texttt{hosts}[-1].\texttt{right}:
      \Comment{real world}
      \Indent
        \State ensure $\textit{State}^B = \textsc{waiting for host}$
        \State $\textit{State}^B \gets \textsc{waiting for comm sig}$
        \label{code:ln:bob:host}
        \State reply (\textsc{host ack})
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:bob}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- On (\textsc{open}, $c$, \texttt{fundee},
  \texttt{hosts}):}
    \begin{algorithmic}[1]
      \State \Comment{\texttt{fundee} is \bob}
      \State ensure $P = \alice$ \Comment{activated party is the funder}
      \State ensure $\textit{State}^A = \textsc{topped up}$
      \State ensure $c = c_{A, \mathrm{chain}}$
      \State \textsc{ln.exchangeOpenKeys}()
      \State \textsc{ln.prepareBase}()
      \If{real world}
        \State \textsc{ln.exchangeOpenSigs}()
      \EndIf
      \If{\texttt{hosts} = \ledger}
        \State \textsc{ln.commitBase}()
      \ElsIf{ideal world} \Comment{opening virtual channel in ideal world}
        \State $\textit{State}^B \gets \textsc{open}$
      \EndIf
      \State $c_A \gets c$; $c_B \gets 0$; $i \gets 0$
      \State $\textit{State}^A \gets \textsc{open}$
      \State output (\textsc{open ok}, $c$, \texttt{fundee}, \texttt{hosts})
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:open}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- On (\textsc{pay}, $x$):}
    \begin{algorithmic}[1]
      \State ensure $\textit{State}^P = \textsc{open} \wedge c_P \geq x$
      \If{ideal world}
        \State send (\textsc{pay}, $x$) to \adversary and expect reply
        (\textsc{pay ok})
        \State ensure $\textit{State}^{\bar{P}} = \textsc{open}$
        \State $c_P \gets c_B - x; c_{\bar{P}} \gets c_{\bar{P}} + x$; $i \gets
        i + 1$
      \Else
        \State $C_{\bar{P}, i+1} \gets C_{\bar{P}, i}$ with $x$ coins moved from
        $P$'s to $\bar{P}$'s output
        \State $\mathrm{sig}_{P, C, i+1} \gets \textsc{sign}(C_{\bar{P}, i+1},
        \sk{P, F})$ \Comment{kept by $\bar{P}$}
        \State send (\textsc{pay}, $x$, $\mathrm{sig}_{P, C, i+1}$) to $\bar{P}$
        \State \Comment{$P$ refers to payer and $\bar{P}$ to payee both in local
        and remote code}
        \State \remotecode{$C_{\bar{P}, i+1} \gets C_{\bar{P}, i}$ with $x$
        coins moved from $P$'s to $\bar{P}$'s output}
        \State \remotecode{ensure \textsc{verify}($C_{\bar{P}, i+1}$,
        $\mathrm{sig}_{P, C, i+1}$, $\pk{P, F}$) = True}
        \State \remotecode{$C_{P, i+1} \gets C_{P, i}$ with $x$ coins moved from
        $P$'s to $\bar{P}$'s output}
        \State \remotecode{$\mathrm{sig}_{\bar{P}, C, i+1} \gets
        \textsc{sign}(C_{P, i+1}, \sk{\bar{P}, F})$} \Comment{kept by $P$}
        \State \remotecode{$R_{P, i} \gets$ TX \{input: $C_{\bar{P},
        i}$.outputs.$P$, output: ($c_{\bar{P}}$, $\pk{P, \mathrm{out}}$)\}}
        \State \remotecode{$\mathrm{sig}_{\bar{P}, R, i} \gets
        \textsc{sign}(R_{P, i}, \sk{\bar{P}, R})$}
        \State \remotecode{reply (\textsc{commitment signed},
        $\mathrm{sig}_{\bar{P}, C, i+1}$, $\mathrm{sig}_{\bar{P}, R, i}$)}
        \State $C_{P, i+1} \gets C_{P, i}$ with $x$ coins moved from $P$'s to
        $\bar{P}$'s output
        \State ensure \textsc{verify}($C_{P, i+1}$, $\mathrm{sig}_{\bar{P}, C,
        i+1}$, $\pk{\bar{P}, F}$) = True
        \State $R_{P, i} \gets$ TX \{input: $C_{\bar{P}, i}$.outputs.$P$,
        output: ($c_{\bar{P}}$, $\pk{P, \mathrm{out}}$)\}
        \State ensure \textsc{verify}($R_{P, i}$, $\mathrm{sig}_{\bar{P}, R,
        i}$, $\pk{\bar{P}, R}$) = True
        \State $R_{\bar{P}, i} \gets$ TX \{input: $C_{P, i}$.outputs.$\bar{P}$,
        output: ($c_P$, $\pk{\bar{P}, \mathrm{out}}$)\}
        \State $\mathrm{sig}_{P, R, i} \gets \textsc{sign}(R_{\bar{P}, i},
        \sk{P, R})$
        \State add $x$ to \texttt{paid\_out}
        \State $c_P \gets c_P - x; c_{\bar{P}} \gets c_{\bar{P}} + x$; $i \gets
        i + 1$
        \State send (\textsc{revoke and ack}, $\mathrm{sig}_{P, R, i}$) to
        $\bar{P}$
        \State \remotecode{$R_{\bar{P}, i} \gets$ TX \{input: $C_{P,
        i}$.outputs.$\bar{P}$, output: ($c_P$, $\pk{\bar{P}, \mathrm{out}}$)\}}
        \State \remotecode{ensure \textsc{verify}($R_{\bar{P}, i}$,
        $\mathrm{sig}_{P, R, i}$, $\pk{P, R}$) = True}
        \State \remotecode{add $x$ to \texttt{paid\_in}}
        \State \remotecode{$c_P \gets c_P - x; c_{\bar{P}} \gets c_{\bar{P}} +
        x$; $i \gets i + 1$}
      \EndIf
      \State \Comment{No output is given to the caller, this is intentional}
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:pay}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{ln} -- close}
    \begin{algorithmic}[1]
      \State \textsc{close}($P$, $(\mathrm{tx}_i, (\sigma_{ij})_j)_i$):
      \Indent
        \State \TODO{also cover case when we are virtual}
        \State $\mathit{State} \gets (\textsc{closing}, P, (\mathrm{tx}_i)_i)$
        \State input (\textsc{submit}, $(\mathrm{tx}_i, (\sigma_{ij})_j)_i$)
        to \ledger as $P$
      \EndIndent
      \Statex

      \State On activation when $\textit{State} = (\textsc{closing}, P,
      (\mathrm{tx}_i)_i)$:
      \Indent
        \State input (\textsc{read}) to \ledger as $P$ and assign output to
        $\Sigma$
        \State ensure all transactions $(\mathrm{tx}_i)_i$ are contained in
        $\Sigma$
        \State $\mathit{State} \gets \textsc{closed}$
        \State \Return (\textsc{ok})
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:ln:virtual}
\end{figure}
