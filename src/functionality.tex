\TODO{Add support for cooperative adding multiple virtuals to single channel
(needs cooperation by all hops of all existing virtuals of current channel)}
\TODO{Add support for cooperative closing (for virtual it also needs cooperation
with all hops of all existing virtuals, we should definitely find another way)}

\fchan is parametrized by the (stateful) objects \textsc{pcn} (payment channel network)
and \textsc{virt} (virtual layer). \TODO{if the 2 objects share too much state, merge into 1 object}

If:
\begin{itemize}
  \item \fchan is activated by $\dave \in \{\alice, \bob\}$,
  \item \fchan then calls a method of either object, expecting some value to be
  returned by it,
  \item then the method gives up the execution token of the ITI (before it
  returns),
\end{itemize}
then \fchan relays to the method any input by \alice until the method returns.

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- init \& top up}
    \begin{algorithmic}[1]
      \State Initialisation: \Comment{runs on first activation}
      \Indent
        \State $(c_A, c_B, \mathrm{locked}_A, \mathrm{locked}_B) \gets (0, 0, 0,
        0)$
        \State $\texttt{virtuals} \gets \emptyset$
        \State $(\texttt{funder}, \texttt{fundee}, \texttt{outer\_funder},
        \texttt{outer\_fundee}) \gets (\bot, \bot, \bot, \bot)$
        \State ensure \textsc{ln.init}() returns (\textsc{ok})
        \State $\mathit{State} \gets \textsc{init}$
      \EndIndent
      \Statex

      \State On (\textsc{top up}) by \alice:
      \label{code:functionality:chan:skeleton:init:top_up:start}
      \Indent
        \State ensure $\mathit{State} = \textsc{init}$
        \State $\mathtt{funder} \gets \alice$
        \State ensure \textsc{ln.topUp}(\alice) returns (\textsc{ok})
        \State $\mathit{State} \gets (\textsc{topped up})$
        \State output (\textsc{topped up}) to \alice
        \label{code:functionality:chan:skeleton:init:top_up:end}
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:init}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- base}
    \begin{algorithmic}[1]
      \State On (\textsc{open}, \texttt{keys}) by \alice:
      \Indent
        \State ensure $\mathit{State} = (\textsc{topped up}) \wedge
        \mathtt{funder} = \alice$
        \State ensure \textsc{ln.open}(\texttt{keys}) returns (\textsc{ok}, $c$)
        \State $c_A \gets c$; $c_B \gets 0$
        \State $\mathit{State} \gets \textsc{open base}$
        \State output (\textsc{open success}) to \alice
      \EndIndent
      \Statex

      \State On (\textsc{pay}, $x$) by $\dave \in \{\alice, \bob\}$:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure $c_D - \mathrm{locked}_D \geq x$
        \State send (\textsc{pay}, $x$, \dave) to \adversary and expect reply
        (\textsc{ok}) \TODO{decide if \textsc{ln.pay}() needed -- probably not}
        \State $c_D \gets c_D - x; c_{\bar{D}} \gets c_{\bar{D}} + x$
        \Comment{$\bar{D}$ is \alice if $D$ is \bob and vice-versa}
        \State output (\textsc{pay success}) to \dave
      \EndIndent
      \Statex

      \State On (\textsc{balance}) by $\dave \in \{\alice, \bob\}$:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State output (\textsc{balance}, $(c_A, c_B, \mathrm{locked}_A,
        \mathrm{locked}_B)$) to \dave % TODO: maybe remove locked_{A,B}
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:base}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- close Pt. 1}
    \begin{algorithmic}[1]
      \State On (\textsc{close}) by \alice:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure \textsc{ln.close}(\alice) returns (\textsc{ok},
        $(\mathrm{tx}_i, (\sigma_ij)_{j \in \{1, \dots, m(i)})_{i \in \{1,
        \dots, n\}}$) \Comment{\textsc{ln} knows if we are base or virtual}
        \State $\mathit{State} \gets \textsc{closed}$
        \If{\textit{State} = \textsc{open base}}
          \State input (\textsc{submit}, $(\mathrm{tx}_1, \sigma_1), \dots,
          (\mathrm{tx}_n, \sigma_n)$) to \ledger
        \Else \: \Comment{\textit{State} = \textsc{open virtual}}
          \State output (\textsc{closed virtual}, $(\mathrm{tx}_1, \sigma_1),
          \dots, (\mathrm{tx}_n, \sigma_n)$) to \texttt{host\_alice} as \alice
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:close:pt1}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- close by corrupted}
    \begin{algorithmic}[1]
      \State On (\textsc{close}, \alice, $\mathrm{sig}_{A, C'}$,
      $\mathrm{sig}_{A, V'}$) by \adversary:
      \Indent
        \State \TODO{in \simulator, allow corrupted party to submit and maintain
        fake ledger. Only in case the closing tx is valid (in the simulated
        ledger), then calculate signature of original comm tx and send this
        message to \fchan}
        \State ensure that \alice is corrupted, \bob is honest
        \If{$\mathtt{funded} = \emptyset$}
          \State ensure $\mathrm{sig}_{A, V'} = \epsilon$
          \State $C' \gets$ TX \{input: $F$.output, outputs: $(c_B, pk_{B,
          \mathrm{out}}), (c_A, pk_{A, \mathrm{out}} \wedge t)$\}
          \State ensure \textsc{verify}($C'$, $\mathrm{sig}_{A, C'}$, $pk_{A, F}$)
          = True
          \State $\mathrm{sig}_{B, C'} \gets \textsc{sign}(C', sk_{B, F})$
        \Else
          \State ensure $\mathrm{sig}_{A, V'} \neq \epsilon$
          \State \TODO{prepare virtual TX, verify $\mathrm{sig}_{A, V'}$}
          \State $C' \gets$ TX \{input: $V'$.output, outputs: $(c_B, pk_{B,
          \mathrm{out}}), (c_A, pk_{A, \mathrm{out}} \wedge t)$\}
          \State ensure \textsc{verify}($C'$, $\mathrm{sig}_{A, C'}$, $pk_{A,
          V'}$) = True
          \State $\mathrm{sig}_{B, V'} \gets \textsc{sign}(V', sk_{B, F})$
          \State $\mathrm{sig}_{B, C'} \gets \textsc{sign}(C', sk_{B, V'})$
        \EndIf
        \State $\mathit{State} \gets \textsc{closed}$
        \If{$\mathit{State} = \textsc{open base}$}
          \State input (\textsc{submit}, ($V'$, $\mathrm{sig}_{A, V}$,
          $\mathrm{sig}_{B, V'}$), ($C'$, $\mathrm{sig}_{A, C'}$,
          $\mathrm{sig}_{B, C'}$)) to \ledger as \alice
        \Else
          \State output (\textsc{closed virtual}, ($V'$, $\mathrm{sig}_{A, V}$,
          $\mathrm{sig}_{B, V'}$), ($C'$, $\mathrm{sig}_{A, C'}$,
          $\mathrm{sig}_{B, C'}$)) to \alice's host (\texttt{opener} if \alice
          had received (\textsc{open virtual}, $\dots$), \texttt{outer\_peer}
          else) as \alice
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:close:corrupted}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- close Pt. 2}
    \begin{algorithmic}[1]
      \State On (\textsc{(peer) closed virtual}, $(V', \mathrm{sig}_{A, V'},
      \mathrm{sig}_{B, V'})$, $(C, \mathrm{sig}_{A, C}, \mathrm{sig}_{B, C})$)
      by \charlie:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure (($c_L$, $c_R$), hops, (\charlie, \dave), (\frank,
        \george), $pk_{A, V}$, $pk_{B, V}$, id) $\in$ \texttt{funded}
        with $\frank \in \{\alice, \bob\}$ \Comment{no stored commitment TX in
        entry yet}
        \If{second tuple of message is empty}
          \State ensure \textsc{verify}($C$, $\mathrm{sig}_{A, C}$, $pk_{A, V}$)
          = \textsc{verify}($C$, $\mathrm{sig}_{B, C}$, $pk_{B, V}$) = True
        \Else
          \State ensure \textsc{verify}($V'$, $\mathrm{sig}_{A, V'}$, $pk_{A,
          V}$) = \textsc{verify}($V'$, $\mathrm{sig}_{B, V'}$, $pk_{B, V}$) =
          \textsc{verify}($C$, $\mathrm{sig}_{A, C}$, $pk_{A, V'}$) =
          \textsc{verify}($C$, $\mathrm{sig}_{B, C}$, $pk_{B, V'}$) = True
        \EndIf
        \State $c_{\mathrm{left}} \gets C\text{.outputs.(the timelocked
        output).coins}$
        \State $c_{\mathrm{right}} \gets C\text{.outputs.(the other
        output).coins}$
        \State ensure $c_{\mathrm{left}} + c_{\mathrm{right}} = c_L + c_R$
        \State add message contents to \texttt{funded} entry
        \State output (\textsc{(peer) closed virtual}, $c_{\mathrm{left}}$, id) to
        \george if peer closed, to \frank else
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:close:pt2}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- fund virtual}
    \begin{algorithmic}[1]
      \State On (\textsc{fund}, $c$, \texttt{hops}, \texttt{inner\_parties} =
      (\texttt{inner\_fundee}, \texttt{inner\_peer}), \texttt{outer\_parties} =
      (\texttt{outer\_funder}, \texttt{outer\_peer}), \texttt{keys}) by \alice:
      \TODO{\texttt{out\_keys} = $pk_{\mathit{VA}, out}$, $pk_{\mathit{VB},
      out}$, use this in \textsc{vn.fund}()}
      \Comment{we fund another channel}
      \label{code:functionality:chan:skeleton:virtual:fund}
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure $c_A - \mathrm{locked}_A \geq c$
        \State ensure \texttt{outer\_funder} = \alice
        \State input (\textsc{open virtual}, $c$, \texttt{inner\_peer},
        \texttt{outer\_peer}, \texttt{keys}) to \texttt{inner\_fundee} as
        \alice, ensure output is (\textsc{ok}, \texttt{in\_keys})
        \label{code:functionality:chan:skeleton:virtual:subfunc}
        \State generate unique \textit{vid}
        \label{code:functionality:chan:skeleton:virtual:id}
        \State ensure \textsc{vl.fund}($c$, \texttt{hops},
        \texttt{inner\_parties}, \texttt{outer\_parties}, \textit{vid}) returns
        (\textsc{ok})
        \label{code:functionality:chan:skeleton:virtual:fund:vl}
        \State add (($c$, 0), \texttt{hops}, \texttt{sub\_parties},
        \texttt{outer\_parties}, \textit{vid}) to \texttt{funded}
        \label{code:functionality:chan:skeleton:virtual:fund:store}
        \State output (\textsc{ok}) to \alice
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:virtual:fund:fig}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- virtual}
    \begin{algorithmic}[1]
      \State On input (\textsc{open virtual}, $c$, \texttt{local\_peer},
      \texttt{outer\_peer}, \texttt{keys}) by $\charlie$ to \alice:
      \Comment{\alice is funded by \charlie}
      \label{code:functionality:chan:skeleton:virtual:fund-you}
      \Indent
        \TODO{what if counterparty corrupted?}
        \State ensure $\mathit{State} = \textsc{init}$
        \State ensure \textsc{ln.virtualOpen}($c$, \texttt{keys}) returns
        (\textsc{ok})
        \label{code:functionality:chan:skeleton:virtual:ln}
        \State $\bob \gets \texttt{local\_peer}$
        \State $\mathtt{opener} \gets \charlie$
        \State $c_A \gets c; c_B \gets 0$
        \State from now on, handle any (\textsc{relayed}, $m$) input by
        \{\texttt{opener}, \texttt{outer\_peer}\} as if it were input ($m$) by
        \{\alice, \bob\} respectively
        \State from now on, transform any output ($m$) to $\{\alice, \bob\}$ to
        output (\textsc{relay}, $m$) to $\{\mathtt{opener},
        \texttt{outer\_peer}\}$ respectively
        \State $\mathit{State} \gets \textsc{open virtual}$
        \State output (\textsc{ok}, $pk_{A, V}$, $pk_{B, V}$) to \charlie
      \EndIndent
      \Statex

      \State On (\textsc{relay}, $m$, \charlie) by \alice:
      \Indent
        \State ensure there is an entry in \texttt{funded} with \alice as funder
        outer party and \charlie as fundee sub-party
        \label{code:functionality:chan:skeleton:virtual:relay:input:start}
        \State input (\textsc{relayed}, $m$) to \charlie
        \label{code:functionality:chan:skeleton:virtual:relay:input:end}
      \EndIndent
      \Statex

      \State On output (\textsc{relay}, $m$) by \charlie to \alice:
      \Indent
        \State ensure there is an entry in \texttt{funded} with \alice as funder
        outer party and \charlie as fundee sub-party \Comment{defensive check,
        may be redundant due to being subroutine respecting}
        \label{code:functionality:chan:skeleton:virtual:relay:output:start}
        \State output (\textsc{relayed}, $m$, \charlie) to \environment
        \label{code:functionality:chan:skeleton:virtual:relay:output:end}
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:virtual}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- corruption}
    \begin{algorithmic}[1]
      \State On (\textsc{corrupt}) by $P$, addressed to \alice:
      \Indent
        \State ensure $P \in \{\mathtt{opener}, \adversary\}$
        \ForAll{$(\_, \_, (\mathrm{fundee}, \_), (\alice, \_)) \in
        \mathtt{funded}$}
          \State send (\textsc{corrupt}) to fundee and ensure reply is
          (\textsc{ok})
        \EndFor
        \If{$\mathit{State} \in \{\textsc{open base}, \textsc{open virtual}\}$}
          \State $C \gets$ TX \{input: $F$.output, outputs: $(c_A, pk_{A,
          \mathrm{out}}), (c_B, pk_{B, \mathrm{out}} \wedge t)$\}
          \State $\mathrm{sig}_{A, C} \gets \textsc{sign}(C, sk_{A, F})$
        \EndIf
        \State from now on, allow \adversary to handle all \alice's messages,
        i.e. act as a relay
        \If{\bob is not corrupted}
          \State from now on, override reactions to messages (\textsc{open}) and
          (\textsc{pay}) addressed to \bob with those defined in the current
          Figure
        \EndIf
        \State output (\textsc{ok}) to $P$
      \EndIndent
      \Statex

      \State On (\textsc{open}, $c_F$, $pk_{A, \mathrm{out}}$, $pk_{B,
      \mathrm{out}}$) by \bob:
      \Indent
        \State ensure $\mathit{State} = (\textsc{topped up}, \bob)$ \TODO{decide
        what happens when channel funded by corrupted party}
        \State ensure $c_F = c_{\mathrm{on}}$
        \State $(sk_{B, F}, pk_{B, F}) \gets \textsc{keyGen}()$
        \State send $(\textsc{open}, c_F, pk_{A, \mathrm{out}}, pk_{B,
        \mathrm{out}}, pk_{B, F}, \bob)$ to \adversary, assign reply to ($pk_{A,
        F}$, $C =$ TX \{input: $F$.output, outputs: ($c_F, pk_{B, \mathrm{out}}
        \wedge t$), ($0, pk_{A, \mathrm{out}}$)\}, $\mathrm{sig}_{A, C}$)
        \State ensure \textsc{verify}($C$, $\mathrm{sig}_{A, C}$, $pk_{A, F}$) =
        True
        \State $F \gets$ TX \{input: \texttt{base\_output}, output: $(c_F,
        2/\{pk_{A, F}, pk_{B, F}\})$\}
        \State $\mathrm{sig}_F \gets \textsc{sign}(F, sk)$
        \State $\mathit{State} \gets \textsc{waiting for ledger}$
        \State input $(\textsc{submit}, (F, \mathrm{sig}_F))$ to \ledger
      \EndIndent
      \Statex

      \State On (\textsc{pay}, $x$) by \bob:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure $c_B - \mathrm{locked}_B \geq x$
        \State send (\textsc{pay}, $x$, \bob) to \adversary and assign reply to
        ($C' =$ TX \{input: $F$.output, outputs: $(c_A + x, pk_{A, \mathrm{out}}),
        (c_B - \mathrm{locked}_B - x, pk_{B, \mathrm{out}} \wedge t)$\},
        $\mathrm{sig}_{A, C}'$) \TODO{think about locked coins again}
        \State ensure \textsc{verify}($C'$, $\mathrm{sig}_{A, C}'$, $pk_{A, F}$)
        = True
        \State $C \gets C'$; $\mathrm{sig}_{A, C} \gets \mathrm{sig}_{A, C}'$
        \State $c_B \gets c_B - x; c_A \gets c_A + x$
        \State output (\textsc{pay success}) to \bob
      \EndIndent
      \Statex

      \State \TODO{receive payment from corrupted counterparty}
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:corruption}
\end{figure}
