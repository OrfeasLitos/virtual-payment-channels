\begin{figure}[H]
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State \textsc{fund}($c$, \texttt{hops}, (\texttt{funder},
      \texttt{fundee}), (\texttt{host\_funder}, \texttt{host\_fundee}),
      \textsc{pcn}, \textit{vid}):
      \Indent
        \State ensure \texttt{host\_funder} = \alice{} \Comment{we are hosting
        the funder}
        \State ensure $\mathrm{len}(\texttt{hops}) \geq 2$ \Comment{no point in
        opening a virtual over 1 channel}
        \State send (\textsc{openVirtual}, $c$, \texttt{fundee},
        \texttt{host\_fundee}) to \texttt{funder}, ensure reply is (\textsc{ok},
        $(\pk{A, V}, \pk{B, V})$)
        \State ensure \textsc{virt.circulateVirtualKeys}(\texttt{hops}) returns
        (\textsc{ok})
        \State ensure \textsc{virt.circulateVirtualSigs}($c$, \texttt{hops},
        $(\pk{A, V}, \pk{B, V})$) returns (\textsc{ok})
        \State ensure \textsc{virt.circulateFundingSigs}(\texttt{hops},
        $(\pk{A, V}, \pk{B, V})$) returns (\textsc{ok})
        \State ensure \textsc{virt.circulateRevocations}(\texttt{hops}) returns
        (\textsc{ok})
        \State \Return (\textsc{ok})
      \EndIndent
      \Statex

      \State \textsc{circulateVirtualKeys}(\texttt{hops},
      $\pk{\mathrm{left}}$):
      \Indent
        \State \Comment{\texttt{hops} is a list of \textit{pid} pairs}
        \State $(\sk{\mathrm{loc}}, \pk{\mathrm{loc}}) \gets
        \textsc{keyGen}()$
        \If{$\pk{\mathrm{left}}$ is given as argument} \Comment{we are
        not \texttt{host\_funder}}
          \If{len(\texttt{hops}[1:]) $\geq 1$} \Comment{we are not
          \texttt{host\_fundee}}
            \State send (\textsc{virtualKeysForward}, $\texttt{hops}$[1:],
            $\pk{\mathrm{left}}$, $(\sk{\mathrm{loc}},
            \pk{\mathrm{loc}})$) to \texttt{hops}[1].\alice{}
            \Comment{sibling}
            \State \trustedcode{store $\pk{\mathrm{left}},
            (\sk{\mathrm{loc}}, \pk{\mathrm{loc}})$}
            \State \trustedcode{call
            \textsc{virt.circulateVirtualKeys}(\texttt{hops},
            $\pk{\mathrm{loc}}$) of \texttt{hops}[0].\bob and assign
            reply to $\pk{\mathrm{right}}$}
            \State \trustedcode{reply (\textsc{VirtualKeysBack},
            $\pk{\mathrm{right}}$)}
            \State store $\pk{\mathrm{right}}$
          \EndIf
          \State \Return $\pk{\mathrm{loc}}$
        \Else \: \Comment{we are \texttt{host\_funder}}
          \State call \textsc{virt.circulateVirtualKeys}(\texttt{hops},
          $\pk{\mathrm{loc}}$) of \texttt{hops}[0].\bob and assign
          reply to $\pk{\mathrm{right}}$
          \State \Return (\textsc{ok})
        \EndIf
      \EndIndent
      \Statex

      \State \textsc{circulateVirtualSigs}($c$, \texttt{hops}, $(\pk{A,
      V}, \pk{B, V})$, $\mathrm{sigs}_{\mathrm{byLeft}}$):
      \Indent
        \If{$\mathrm{sigs}_{\mathrm{byLeft}}$ is given as argument} \Comment{we
        are not \texttt{host\_funder}}
          \State create all TXs that need $\mathrm{sigs}_{\mathrm{byLeft}}$
          \TODO{}
          \State verify $\mathrm{sigs}_{\mathrm{byLeft}}$ on TXs \TODO{}
          \If{len(\texttt{hops}[1:]) $\geq 1$} \Comment{we are not
          \texttt{host\_fundee}}
            \State send (\textsc{virtualSigsForward}, \texttt{hops}[1:],
            $\mathrm{sigs}_{\mathrm{byLeft}}$) to \texttt{hops}[1].\alice{}
            \Comment{sibling needs $\mathrm{sigs}_{\mathrm{byLeft}}$ for closing}
            \State \trustedcode{create all right's TXs that need our sigs and sign
            them for $\mathrm{sigs}_{\mathrm{toRight}}$} \TODO{}
            \State \trustedcode{call \textsc{virt.circulateVirtualSigs}($c$,
            \texttt{hops}, $\mathrm{sigs}_{\mathrm{toRight}}$) of
            \texttt{hops}[0].\bob and assign reply to
            $\mathrm{sigs}_{\mathrm{byRight}}$}
            \State \trustedcode{create all TXs that need
            $\mathrm{sigs}_{\mathrm{byRight}}$} \TODO{}
            \State \trustedcode{verify $\mathrm{sigs}_{\mathrm{byRight}}$ on TXs}
            \TODO{}
            \State \trustedcode{reply (\textsc{virtualSigsBack},
            $\mathrm{sigs}_{\mathrm{byRight}}$)} \Comment{sibling needs
            $\mathrm{sigs}_{\mathrm{byRight}}$ for closing}
          \EndIf
        \Else \: \Comment{we are \texttt{host\_funder}}
          \State create all right's TXs that need our sigs and sign them for
          $\mathrm{sigs}_{\mathrm{toRight}}$ \TODO{}
          \State call \textsc{virt.circulateVirtualSigs}($c$, \texttt{hops},
          $\mathrm{sigs}_{\mathrm{toRight}}$) of \texttt{hops}[0].\bob and
          assign reply to $\mathrm{sigs}_{\mathrm{byRight}}$
          \State create all TXs that need $\mathrm{sigs}_{\mathrm{byRight}}$
          \TODO{}
          \State verify $\mathrm{sigs}_{\mathrm{byRight}}$ on TXs \TODO{}
          \State \Return (\textsc{ok})
        \EndIf
        \If{$\mathrm{sigs}_{\mathrm{byLeft}}$ is given}
          \State create all left's TXs that need our sigs and sign
          them for $\mathrm{sigs}_{\mathrm{toLeft}}$ \TODO{}
          \State \Return $\mathrm{sigs}_{\mathrm{forLeft}}$
        \EndIf
      \EndIndent
      \Statex

      \State \textsc{circulateFundingSigs}(\texttt{hops}, $(\pk{A, V},
      \pk{B, V})$):
      \Indent
        \State \Return (\textsc{ok})
      \EndIndent
      \Statex

      \State \textsc{circulateRevocations}(\texttt{hops}):
      \Indent
        \State \Return (\textsc{ok})
      \EndIndent
      \Statex

      \State \textsc{close}($P$):
        \TODO{continue}
        \TODO{handle arbitrarily nested virtuals (now we only handle one level
        and it leads to nested ifs}
        \If{both channel parties are honest}
          \If{$\mathtt{funded} \neq \emptyset$}
            \State \TODO{prepare virtual layer TX $V$ and its signature --
            careful, may be unneded!}
            \State $C \gets$ TX \{input: $V$.output, outputs: $(c_A, \pk{A,
            \mathrm{out}} \wedge t), (c_B, \pk{B, \mathrm{out}})$\}
            \State $\mathrm{sig}_{B, C} \gets \textsc{sign}(C, \sk{B, V})$
            \State $\mathrm{sig}_{A, C} \gets \textsc{sign}(C, \sk{A, V})$
          \Else
            \State $C \gets$ TX \{input: $F$.output, outputs: $(c_A, \pk{A,
            \mathrm{out}} \wedge t), (c_B, \pk{B, \mathrm{out}})$\}
            \State $\mathrm{sig}_{B, C} \gets \textsc{sign}(C, \sk{B, F})$
            \State $\mathrm{sig}_{A, C} \gets \textsc{sign}(C, \sk{A, F})$
          \EndIf
        \EndIf \: \Comment{if \bob is corrupted, we already have $C$ and
        $\mathrm{sig}_{B, C}$}
        \State $\mathit{State} \gets \textsc{closed}$
        \If{$\mathit{State} = \textsc{open base}$}
          \State input (\textsc{submit}, $(V, \mathrm{sig}_{A, V},
          \mathrm{sig}_{B, V})$, $(C, \mathrm{sig}_{A, C}, \mathrm{sig}_{B,
          C})$) to \ledger
        \Else \: \Comment{$\mathit{State} = \textsc{open virtual}$}
          \If{\alice is the one that had received (\textsc{open virtual}, $\dots$)
          by \texttt{opener}}
            \State $\texttt{initiator} \gets \texttt{opener}$; $\texttt{other}
            \gets \texttt{outer\_peer}$
          \Else \: \Comment{\bob had received (\textsc{open virtual} $\dots$)}
            \State $\texttt{initiator} \gets \texttt{outer\_peer}$;
            $\texttt{other} \gets \texttt{opener}$
          \EndIf
          \If{both parties are honest}
            \If{$\texttt{funded} \neq \emptyset$}
              \State \TODO{prepare virtual layer TXs $V_A, V_B$ and their
              signatures}
              \State $C' \gets$ TX \{input: $V$.output, outputs: $(c_A, \pk{A,
              \mathrm{out}}), (c_B, \pk{B, \mathrm{out}} \wedge t)$\}
              \State $\mathrm{sig}_{A, C}' \gets \textsc{sign}(C', \sk{A, V})$;
              $\mathrm{sig}_{B, C}' \gets \textsc{sign}(C', \sk{B, V})$
            \Else \: \Comment{there are no virtual channels on top of us}
              \State $C' \gets$ TX \{input: $F$.output, outputs: $(c_A, \pk{A,
              \mathrm{out}}), (c_B, \pk{B, \mathrm{out}} \wedge t)$\}
              \State $\mathrm{sig}_{A, C}' \gets \textsc{sign}(C', \sk{A, F})$;
              $\mathrm{sig}_{B, C}' \gets \textsc{sign}(C', \sk{B, F})$
            \EndIf
            \State provide delayed output (\textsc{peer closed virtual}, $(V_B,
            \mathrm{sig}_{A, V_B}, \mathrm{sig}_{B, V_B})$, $(C',
            \mathrm{sig}_{A, C}', \mathrm{sig}_{B, C}')$) to \texttt{other} as
            \bob
          \EndIf
          \If{$\mathtt{funded} \neq \emptyset$}
            \State $\mathtt{output} \gets (\textsc{closed virtual}, (V,
            \mathrm{sig}_{A, V}, \mathrm{sig}_{B, V}), (C, \mathrm{sig}_{A, C},
            \mathrm{sig}_{B, C}))$
          \Else
            \State $\mathtt{output} \gets (\textsc{closed virtual}, (C,
            \mathrm{sig}_{A, C}, \mathrm{sig}_{B, C}))$
          \EndIf
          \State output \texttt{output} to \texttt{initiator} as \alice
        \EndIf
        \Statex

        \State \textsc{closed}($c_L$, $c_R$, $(\mathrm{tx}_i,
        (\sigma_{ij})_j)_i$):
        \Indent
          \ForAll{$i$ in $1 \dots |(\mathrm{tx}_i, (\sigma_{ij})_j)_i|$}
            \State ensure \textsc{verify}($\mathrm{tx}_i$, $(\sigma_{ij})_j$) =
            True
          \EndFor
          \State ensure ($\mathrm{tx}_1$, $(\sigma_{1j})_j$) has exactly $1$
          input, which spends an output of $V$ of value $c_L + c_R$
          \State return (\textsc{ok})
        \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer}
\end{figure}
