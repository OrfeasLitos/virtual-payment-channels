\section{Discussion and Future work}
\label{sec:future-work}
\makeatletter%
\@ifclassloaded{IEEEtran}%
  {\paragraph{Domino attack}}%
  {\paragraph{Domino attack.}}%
\makeatother%
In~\cite{donner} the Domino attack is presented. In a nutshell, it claims that a
malicious member of a virtual channel can force other participant channels to close. To illustrate the objective, consider
 Fig.~\ref{figure:example-start-end}, and suppose $A$ and $E$ open channels
$(A, B)$, $(D, E)$ and $(A, E)$ only with the intent of forcing channels $(B,
C)$ and $(C, D)$ to close. Applying the attack to our protocol, we observe that contrary to the objective of the attack,  honest base parties are only
forced to publish a single virtual transaction each and that all virtual
transactions have a funding output for the corresponding channel, therefore no
base channel is closed. Thus the attack does not achieve its objective, it merely requires the publication of a single virtual transaction per base
party. This still has a small downside: 
the channel capacity is reduced by the collateral, which
is paid directly to one of the two base channel parties. Since no coins are
stolen in the process, the only cost to $B$, $C$ and $D$ is the on-chain fees
for publishing a transaction. This is an inherent but small risk of
recursive channels, which must be taken into account before allowing one's
channel to be the base of another. This risk can be eliminated by imposing a
unilateral closing fee equal to the on-chain fee of publishing one transaction
per base party. This fee need not apply in case of cooperative closing nor
during normal operation and can be reduced for reputable counterparties.
Mechanisms for assigning inactivity blame (i.e., proving that honest parties
attempted collaborative closing before closing unilaterally) can be designed but
are beyond the scope of this work.

There is also a simple modification to Elmo that eliminates the issue of base channel capacity reduction under Domino attack, while it also reduces on-chain
footprint: from each virtual tx, we can
eliminate the output that directly
pays a party (e.g., $1$st output of
Fig.~\ref{figure:virtual-layer-extend-interval-simple}) and move the
corresponding coins into the funding output of this transaction. We further
ensure at the protocol level that the base party that owns these coins never
allows its channel balance to fall below the collateral, until the supported
virtual channel closes. This change ensures that the collateral
automatically becomes available to use in the base channel after the virtual one
closes, effectively keeping more funds off-chain even after a Domino attack.

\makeatletter%
\@ifclassloaded{IEEEtran}%
  {\paragraph{Future work}}%
  {\paragraph{Future work.}}%
\makeatother%
  A number of features can be added to our protocol for additional efficiency,
  usability and flexibility. First of all, in our current construction, each
  time a particular channel $C$ acts as a base
  channel for a new virtual channel, one more ``virtualisation layer'' is added. When
  one of its owners wants to close $C$, it has to put on-chain as many
  transactions as there are virtualisation layers. Also the timelocks associated
  with closing a virtual channel increase with the number of virtualisation
  layers of its base channels. Both these issues can be alleviated by extending
  the opening and cooperative closing subprotocol with the ability to
  cooperatively open and close multiple virtual channels in the same layer,
  either simultaneously or by amending an existing virtualisation layer.

  Further usability enhancements are possible: Firstly, the maximum time between
  activations can be turned from the currently global constant into a
  per-channel configurable parameter. Secondly, various non-malicious mishaps
  such as dropped messages can be handled gracefully, without causing unilateral
  channel closure. Lastly, LN features like one-off multi-hop payments and
  cooperative on-chain closing of simple channels can be straightforwardly
  incorporated. For more detail see Appx.~\ref{sec:further-future-work}.

  Due to the possibility of a griefing attack
  (Appx.~\ref{construction:real-world}), the range of balances a virtual
  channel can
  support is limited by the balances of neighbouring channels. We believe that
  this limitation can be lifted if the Lightning-based
  construction for the payment layer is replaced with an
  eltoo-based~\cite{eltoo} one. Since in eltoo a maliciously published
  old state can be simply re-spent by the honest latest state, the griefing
  attack is completely avoided. What is more, our protocol shares with eltoo the
  need for the \texttt{ANYPREVOUT} flag, therefore no additional
  requirements from Bitcoin would be added by this change. Lastly,
  due to the separation of intermediate layers with the payment layer in our
  pseudocode implementation (i.e., the distinction
  between the \textsc{ln} and the \textsc{virt} protocols), this change
  in principle needs only limited changes to our protocol.

  Furthermore, any deployment of the protocol has to explicitly handle the issue
  of transaction fees. These include miner fees for on-chain transactions and
  intermediary fees for the parties that own base channels and facilitate
  opening virtual channels. These fees should take into account the fact that
  each intermediary has quadratic storage requirements, whereas endpoints only
  need constant storage, creating an opportunity for amplification attacks.
  Furthermore, a fee structure that takes into account the opportunity cost of
  base parties locking collateral for a potentially long time is needed. A
  straightforward mechanism is for parties to agree on a time-based fee schedule
  and periodically update their base channels to reflect contingent payments by
  the endpoints. We leave the relevant incentive analysis as future work.

  In order to increase readability and to keep focus on the salient points of
  the construction, our protocol does not exploit various possible
  optimisations. These include allowing parties to stay offline for
  longer~\cite{DBLP:conf/ccs/AumayrTMMM22}, and some techniques employed in Lightning that
  drastically reduce storage requirements, such as storage of per-update secrets
  in $O(\log n)$
  space\footnote{\url{https://github.com/lightning/bolts/blob/master/03-transactions.md\#efficient-per-commitment-secret-storage}},
  and other improvements to our novel virtual subprotocol.

  %Moreover, our need for \texttt{ANYPREVOUT} prevents our protocol from being
  %deployable on Bitcoin today. Though it is a prime contender for inclusion
  %in the next update, there is a slight chance it will never make it.
  %Nevertheless,
  As mentioned before, we conjecture that a variadic virtual
  channel protocol with unlimited lifetime needs each party to store an
  exponential number of signatures if \texttt{ANYPREVOUT} is not available. We
  leave proof of this as future work. Furthermore, the formal verification of
  the UC security proof is deferred to such a time when a practical framework
  for mechanised UC proofs becomes available.

  Last but not least, the current analysis gives no privacy guarantees for the
  protocol, as it does not employ onion packets~\cite{sphinx} like Lightning.
  Furthermore, \fchan leaks all messages to the ideal adversary therefore
  theoretically no privacy is offered at all. Nevertheless, onion packets can be
  incorporated in the current construction. Intuitively our construction
  leaks less data than Lightning for the same multi-hop payments, as
  intermediaries in our case are not notified on each payment, contrary to
  multi-hop payments in Lightning. Therefore a future extension can improve the
  privacy of the construction and formally demonstrate exact privacy guarantees.
