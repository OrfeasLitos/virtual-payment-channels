\begin{figure}[H]
  \begin{simulatorbox}{\simulator{} -- general message handling rules}
    \begin{itemize}
      \item On receiving (\textsc{relay}, \texttt{in\_msg}, $P$, $R$,
      \texttt{in\_mode}) by \fchan (\texttt{in\_mode} $\in$ \{input, output,
      network\}, $P \in \{\alice, \bob\}$), handle (\texttt{in\_msg}) with the
      simulated party $P$ as if it was received from $R$ by means of
      \texttt{in\_mode}. In case simulated $P$ does not exist yet, initialise it
      as an \textsc{ln} ITI. If there is a resulting message \texttt{out\_msg}
      that is to be sent by simulated $P$ to $R'$ by means of
      $\texttt{out\_mode} \in$ \{input, output, network\}, send (\textsc{relay},
      \texttt{out\_msg}, $P$, $R'$, \texttt{out\_mode}) to \fchan.
      \item On receiving by \fchan a message to be sent by $P$ to $R$ via the
      network, carry on with this action (i.e. send this message via the
      internal \adversary).
      \item Relay any other incoming message to the internal \adversary
      unmodified.
      \item On receiving a message (\texttt{msg}) by the internal \adversary, if it is
      addressed to one of the parties that correspond to \fchan, handle the
      message internally with the corresponding simulated party. Otherwise relay
      the message to its intended recipient unmodified. \Comment{Other
      recipients are \environment, \ledger or parties unrelated to \fchan}
    \end{itemize}

    Given that \fchan relays all messages and that we simulate the real-world
    machines that correspond to \fchan, the simulation is perfectly
    indistinguishable from the real world.
  \end{simulatorbox}
  \caption{}
  \label{code:simulator:flow}
\end{figure}

\begin{figure}[H]
  \begin{simulatorbox}{\simulator{} -- notifications to \fchan}
    \begin{itemize}
      \item ``$P$'' refers one of the parties that correspond to \fchan.
      \item When an action in this Figure interrupts an ITI simulation, continue
      simulating from the interruption location once action is over/\fchan hands
      control back.
    \end{itemize} \ \\
    \begin{algorithmic}[1]
      \State On (\textsc{corrupt}) by \adversary, addresed to $P$:
      \Indent
        \State \Comment{After executing this code, deliver (\textsc{corrupt}) to
        simulated $P$ as detailed in Fig.~\ref{code:simulator:flow}.  Given that
        \fchan returns control directly to us after it handles this message, we
        will always deliver (\textsc{corrupt}) successfully.}
        \State send (\textsc{info}, \textsc{became corrupted or negligent}, $P$)
        to \fchan
        \label{code:simulator:corrupted}
      \EndIndent
      \Statex

      \State When simulated $P$ sets its internal variable \texttt{negligent} to
      True (Fig.~\ref{code:ln:methods-for-virt},
      l.~\ref{code:ln:methods-for-virt:negligent}/Fig.~\ref{code:ln:init},
      l.~\ref{code:ln:init:negligent}):
      \Indent
        \State send (\textsc{info}, \textsc{became corrupted or negligent}, $P$)
        to \fchan
        \label{code:simulator:negligent}
      \EndIndent
      \Statex

      \State When simulated honest \alice receives (\textsc{open}, $x$, $\dots$)
      by \environment:
      \Indent
        \State store $x$ \Comment{will be used to inform \fchan once the channel
        is open}
      \EndIndent
      \Statex

      \State When the last of the honest simulated \fchan's parties moves to the
      \textsc{open} state for the first time
      (Fig.~\ref{code:ln:exchange-open-sigs},
      l.~\ref{code:ln:exchange-open-sigs:state-open}/Fig.~\ref{code:ln:bob},
      l.~\ref{code:ln:bob:state-open}/Fig.~\ref{code:ln:open},
      l.~\ref{code:ln:open:state-open}):
      \label{code:simulator:when-open}
      \Indent
        \IfThen{$x$ is undefined}{$x \gets 0$} \Comment{$x$ is already defined
        if \alice is honest}
        \State send (\textsc{info}, \textsc{open}, $x$) to \fchan
        \label{code:simulator:open}
      \EndIndent
      \Statex

      \State When (both \fchan's simulated parties are honest and $P$ completes
      sending a payment of value $c$ (Fig.~\ref{code:ln:pay:revocations},
      l.~\ref{code:ln:pay:revocations:paid-out}) and $\bar{P}$ completes
      receiving that payment (Fig.~\ref{code:ln:pay:revocations},
      l.~\ref{code:ln:pay:revocations:paid-in})), or (when only $S$ is honest
      and (completes either receiving ($\bar{P} \gets S$, $P \gets \bar{S}$) or
      sending ($P \gets S$, $\bar{P} \gets \bar{S}$) a payment of value $c$)):
      \Comment{also send this message if both parties are honest when
      Fig.~\ref{code:ln:pay:revocations},
      l.~\ref{code:ln:pay:revocations:paid-out} is executed by one party, but
      its counterparty is corrupted before executing
      Fig.~\ref{code:ln:pay:revocations},
      l.~\ref{code:ln:pay:revocations:paid-in}}
      \label{code:simulator:when-pay}
      \Indent
        \State send (\textsc{info}, \textsc{pay}, $c$, $P$, $\bar{P}$) to \fchan
      \EndIndent
      \Statex

      \State When honest simulated $P$ executes
      Fig.~\ref{code:ln:virtualise:start-end},
      l.~\ref{code:ln:virtualise:start-end:reduce-coins}: \Comment{if $\bar{P}$
      is honest, it has already moved to the new host,
      (Fig~\ref{code:virtual-layer:revocation},
      l.~\ref{code:virtual-layer:revocation:revoc-by-next}
      and~\ref{code:virtual-layer:revocation:hosts-ready}), so lifting to next
      layer is complete}
      \label{code:simulator:when-fund}
      \Indent
        \State extract $c_{\mathrm{guest}}$ from executed
        Fig.~\ref{code:ln:virtualise:start-end},
        l.~\ref{code:ln:virtualise:start-end:reduce-coins}
        \State send (\textsc{info}, \textsc{fund}, $c_{\mathrm{guest}}$, $P$) to
        \fchan
      \EndIndent
      \Statex

      \State When one of the honest simulated \fchan's parties $P$ moves to the
      \textsc{closed} state (Fig.~\ref{code:ln:poll},
      l.~\ref{code:ln:poll:state-closed}/Fig.~\ref{code:ln:close},
      l.~\ref{code:ln:close:state-closed}):
      \Indent
        \State send (\textsc{info}, \textsc{close}, $P$) to \fchan
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{code:simulator}
\end{figure}
