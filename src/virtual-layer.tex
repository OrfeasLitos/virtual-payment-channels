\begin{figure}[H]
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State \textsc{fund}($c$, \texttt{hops}, (\texttt{funder},
      \texttt{fundee}), (\texttt{host\_funder}, \texttt{host\_fundee}),
      \textsc{pcn}, \textit{vid}):
      \Indent
        \State ensure \texttt{host\_funder} = \alice{} \Comment{we are hosting
        the funder}
        \State ensure $\mathrm{len}(\texttt{hops}) \geq 2$ \Comment{no point in
        opening a virtual over 1 channel}
        \State send (\textsc{open virtual}, $c$, \texttt{fundee},
        \texttt{host\_fundee}) to \texttt{funder}, ensure reply is (\textsc{ok},
        $(\pk{A, V}, \pk{B, V})$)
        \State ensure \textsc{virt.circulateVirtualKeys}(\texttt{hops}, ($\pk{A,
        V}$, $\pk{B, V}$)) returns (\textsc{ok})
        \State ensure \textsc{virt.circulateVirtualSigs}($c$, \texttt{hops})
        returns (\textsc{ok})
        \State ensure \textsc{virt.circulateFundingSigs}(\texttt{hops}) returns
        (\textsc{ok})
        \State ensure \textsc{virt.circulateRevocations}(\texttt{hops}) returns
        (\textsc{ok})
        \State \Return (\textsc{ok})
      \EndIndent
      \Statex

      \State \textsc{circulateVirtualKeys}(\texttt{hops}, ($\pk{A, V}$, $\pk{B,
      V}$), \texttt{left\_virt\_keys}):
      \Indent
        \State \Comment{\texttt{hops} is a list of \textit{pid} pairs}
        \State $(\sk{\mathrm{loc}}, \pk{\mathrm{loc}}) \gets
        \textsc{keyGen}()$
        \If{\texttt{left\_virt\_keys} is given as argument} \Comment{we are not
        \texttt{host\_funder}}
          \If{len(\texttt{hops}[1:]) $\geq 1$} \Comment{we are not
          \texttt{host\_fundee}}
            \State input (\textsc{virtual keys forward}, $\texttt{hops}$[1:],
            ($\pk{A, V}$, $\pk{B, V}$), \texttt{left\_virt\_keys},
            $(\sk{\mathrm{loc}}, \pk{\mathrm{loc}})$, ($\pk{A, F}, \pk{B, F}$))
            to \texttt{hops}[1].\alice{} \Comment{sibling}
            \State \trustedcode{store inputs as \texttt{left\_virt\_keys},
            $(\sk{\mathrm{loc}}, \pk{\mathrm{loc}})$, \texttt{left\_fund\_keys}}
            \State \trustedcode{call
            \textsc{virt.circulateVirtualKeys}(\texttt{hops}, ($\pk{A, V}$,
            $\pk{B, V}$), ($\pk{\mathrm{loc}}$, \texttt{left\_virt\_keys}[0]))
            of \texttt{hops}[0].\bob and assign output to
            \texttt{right\_virt\_keys}, \texttt{right\_fund\_keys}}
            \State \trustedcode{output (\textsc{virtual keys back},
            \texttt{right\_virt\_keys}, ($\pk{A, F}, \pk{B, F}$))}
            \State store outputs as \texttt{right\_virt\_keys},
            \texttt{right\_fund\_keys}
            \State \Return ($\pk{\mathrm{loc}}$, \texttt{right\_virt\_keys}[0]),
            \texttt{right\_fund\_keys}
          \Else \: \Comment{we are \texttt{host\_fundee}}
            \State \TODO{there is a problem with the base-virtual channel
            semantics, as a base channel becomes virtual itself when it
            facilitates another virtual. When it's solved, we may have to
            reconsider the \texttt{fundee} below.}
            \State call \textsc{pcn.getCommKeys}() of \texttt{fundee} and assign
            output to ($\pk{A, V}'$, \_, \_), ($\pk{B, V}'$, \_, \_)
            \State ensure $\pk{A, V} = \pk{A, V}' \wedge \pk{B, V} = \pk{B, V}'$
            \State \Return $\pk{\mathrm{loc}}$
          \EndIf
        \Else \: \Comment{we are \texttt{host\_funder}}
          \State call \textsc{virt.circulateVirtualKeys}(\texttt{hops}, ($\pk{A,
          V}$, $\pk{B, V}$), $\pk{\mathrm{loc}}$) of \texttt{hops}[0].\bob and
          assign output to ($\pk{\mathrm{right}}$, $\pk{\mathrm{right}, 2}$),
          \texttt{right\_fund\_keys}
          \State \Return (\textsc{ok})
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:keys}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State \textsc{getMidTXs}($c_{\mathrm{guest}}$, $c_{\mathrm{loc}}$,
      $c_{\mathrm{rem}}$, $\pk{\mathrm{left}, \mathrm{fund}}$,
      $\pk{\mathrm{loc}, \mathrm{fund}}$, $\pk{\mathrm{sib}, \mathrm{fund}}$,
      $\pk{\mathrm{right}, \mathrm{fund}}$, $\pk{\mathrm{left}, \mathrm{virt}}$,
      $\pk{\mathrm{loc}, \mathrm{virt}}$, $\pk{\mathrm{sib}, \mathrm{virt}}$,
      $\pk{\mathrm{right}, \mathrm{virt}}$, $\pk{\mathrm{left},
      \mathrm{guest}}$, $\pk{\mathrm{right}, \mathrm{guest}}$,
      $\pk{\mathrm{loc}, \mathrm{out}}$, \texttt{comm\_keys\_loc},
      \texttt{comm\_keys\_rem}, $P$):
      \Indent
        \State ensure $c_{\mathrm{sibRem}} \geq c_{\mathrm{guest}} \wedge
        c_{\mathrm{loc}} \geq c_{\mathrm{guest}}$
        \State $c_{\mathrm{left}} \gets c_{\mathrm{sib}} + c_{\mathrm{sibRem}}$;
        $c_{\mathrm{right}} \gets c_{\mathrm{loc}} + c_{\mathrm{rem}}$
        \State $\texttt{left\_fund} \gets 2/\{\pk{\mathrm{left}, \mathrm{fund}},
        \pk{\mathrm{loc}, \mathrm{fund}}\}$
        \State $\texttt{right\_fund} \gets 2/\{\pk{\mathrm{sib}, \mathrm{fund}},
        \pk{\mathrm{right}, \mathrm{fund}}\}$
        \State $\texttt{left\_virt} \gets 2/\{\pk{\mathrm{left}, \mathrm{virt}},
        \pk{\mathrm{loc}, \mathrm{virt}}\}$
        \State $\texttt{right\_virt} \gets 2/\{\pk{\mathrm{sib}, \mathrm{virt}},
        \pk{\mathrm{right}, \mathrm{virt}}\}$
        \State $\texttt{guest} \gets 2/\{\pk{\mathrm{left}, \mathrm{guest}},
        \pk{\mathrm{right}, \mathrm{guest}}\}$
        \State $\texttt{left\_out} \gets (\texttt{2} \wedge \texttt{left\_virt})
        \vee (\texttt{3} \wedge \texttt{left\_virt} + t)$
        \State $\texttt{right\_out} \gets (\texttt{1} \wedge
        \texttt{right\_virt}) \vee (\texttt{3} \wedge \texttt{right\_virt} + t)$
        \State $\texttt{guest\_out} \gets \texttt{guest\_virt} \vee (\texttt{3}
        \wedge \texttt{guest\_virt} + t)$
        \State $\mathrm{TX}_{\mathrm{none}} \gets$ TX \{inputs:
        (($c_{\mathrm{left}}$, \texttt{left\_fund}), ($c_{\mathrm{right}}$,
        \texttt{right\_fund})), outputs: (($c_{\mathrm{left}} -
        c_{\mathrm{guest}}$, \texttt{left\_out}), ($c_{\mathrm{right}} -
        c_{\mathrm{guest}}$, \texttt{right\_out}), ($c_{\mathrm{guest}}$,
        $\pk{\mathrm{loc}, \mathrm{out}}$), ($c_{\mathrm{guest}}$,
        \texttt{guest\_out}))\}
        \State $\mathrm{TX}_{\mathrm{left}} \gets$ TX \{inputs:
        (($c_{\mathrm{left}} - c_{\mathrm{guest}}$, \texttt{1} $\wedge$
        \texttt{left\_virt}), ($c_{\mathrm{right}}$, \texttt{right\_fund})),
        outputs: (($c_{\mathrm{left}} - c_{\mathrm{guest}}$, \texttt{3} $\wedge$
        \texttt{left\_virt}), ($c_{\mathrm{right}} - c_{\mathrm{guest}}$,
        \texttt{right\_out}), ($c_{\mathrm{guest}}$, $\pk{\mathrm{loc},
        \mathrm{out}}$))\}
        \State $\mathrm{TX}_{\mathrm{right}} \gets$ TX \{inputs:
        (($c_{\mathrm{left}}$, \texttt{left\_fund}), ($c_{\mathrm{right}} -
        c_{\mathrm{guest}}$, \texttt{2} $\wedge$ \texttt{right\_virt}), outputs:
        (($c_{\mathrm{left}} - c_{\mathrm{guest}}$, \texttt{left\_out}),
        ($c_{\mathrm{right}} - c_{\mathrm{guest}}$, \texttt{3} $\wedge$
        \texttt{right\_virt}), ($c_{\mathrm{guest}}$, $\pk{\mathrm{loc},
        \mathrm{out}}$))\}
        \State $\mathrm{TX}_{\mathrm{both}} \gets$ TX \{inputs:
        (($c_{\mathrm{left}} - c_{\mathrm{guest}}$, \texttt{1} $\wedge$
        \texttt{left\_virt}), ($c_{\mathrm{right}} - c_{\mathrm{guest}}$,
        \texttt{2} $\wedge$ \texttt{right\_virt}), ($c_{\mathrm{guest}}$,
        \texttt{guest})), outputs: (($c_{\mathrm{left}} - c_{\mathrm{guest}}$,
        \texttt{3} $\wedge$ \texttt{left\_virt}), ($c_{\mathrm{right}} -
        c_{\mathrm{guest}}$, \texttt{3} $\wedge$ \texttt{right\_virt}),
        ($c_{\mathrm{guest}}, \pk{\mathrm{loc}, \mathrm{out}}$)\}
        \State $C \gets \textsc{pcn.getCommTX}(c_{\mathrm{loc}} -
        c_{\mathrm{guest}}, c_{\mathrm{rem}}, \texttt{comm\_keys\_loc},
        \texttt{comm\_keys\_rem}, $P$)$
        \State \Return ($\mathrm{TX}_{\mathrm{none}}$,
        $\mathrm{TX}_{\mathrm{left}}$, $\mathrm{TX}_{\mathrm{right}}$,
        $\mathrm{TX}_{\mathrm{both}}$, $C$)
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:mid-txs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State \Comment{left and right refer to the two counterparties, with left
      being the one closer to the funder. Note difference with left/right
      meaning in \textsc{virt.getMidTXs}.}
      \State \textsc{getEdgeTXs}($c_{\mathrm{guest}}$, $c_{\mathrm{left}}$,
      $c_{\mathrm{right}}$, $\pk{\mathrm{left}, \mathrm{fund}}$,
      $\pk{\mathrm{right}, \mathrm{fund}}$, $\pk{\mathrm{left}, \mathrm{virt}}$,
      $\pk{\mathrm{right}, \mathrm{virt}}$, $\pk{\mathrm{left},
      \mathrm{guest}}$, $\pk{\mathrm{right}, \mathrm{guest}}$,
      \texttt{comm\_keys\_left}, \texttt{comm\_keys\_right},
      \texttt{is\_funder}, $P$):
      \Indent
        \State ensure $c_{\mathrm{left}} \geq c_{\mathrm{guest}}$
        \State $c_{\mathrm{tot}} \gets c_{\mathrm{left}} + c_{\mathrm{right}}$
        \State $\texttt{fund} \gets 2/\{\pk{\mathrm{left}, \mathrm{fund}},
        \pk{\mathrm{right}, \mathrm{fund}}\}$
        \State $\texttt{virt} \gets 2/\{\pk{\mathrm{left}, \mathrm{virt}},
        \pk{\mathrm{right}, \mathrm{virt}}\}$
        \State $\texttt{guest} \gets 2/\{\pk{\mathrm{left}, \mathrm{guest}},
        \pk{\mathrm{right}, \mathrm{guest}}\}$
        \If{\texttt{is\_funder} = True}
          \State $\texttt{out} \gets (\texttt{1} \wedge \texttt{virt}) \vee
          (\texttt{3} \wedge \texttt{virt} + t)$
        \Else \: \Comment{TXs belong to \texttt{fundee}}
          \State $\texttt{out} \gets (\texttt{2} \wedge \texttt{virt}) \vee
          (\texttt{3} \wedge \texttt{virt} + t)$
        \EndIf
        \State $\texttt{guest\_out} \gets \texttt{guest\_virt} \vee
        (\texttt{guest\_virt} + t)$
        \State $\mathrm{TX}_{\mathrm{base}} \gets$ TX \{input:
        $c_{\mathrm{tot}}$, \texttt{fund}, outputs: (($c_{\mathrm{tot}} -
        c_{\mathrm{guest}}$, \texttt{out}), ($c_{\mathrm{guest}}$,
        \texttt{guest\_out}))\}
        \State $C \gets \textsc{pcn.getCommTX}(c_{\mathrm{left}} -
        c_{\mathrm{guest}}, c_{\mathrm{right}}, \texttt{comm\_keys\_left},
        \texttt{comm\_keys\_right}, P)$
        \State \Return ($\mathrm{TX}_{\mathrm{base}}$, $C$)
      \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:edge-txs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.siblingSigs}()}
    \begin{algorithmic}[1]
      \State $(\texttt{comm\_keys\_loc}, \texttt{comm\_keys\_rem}) \gets
      \textsc{pcn.getCommKeys}()$
      \State $\mathrm{sigs}_{\mathrm{toRight}} \gets \emptyset$
      \If{we have \texttt{right\_virt\_keys}[1]} \Comment{next
      hop is not \texttt{host\_fundee}}
        \State ($\mathrm{TX}_{\mathrm{next}, \mathrm{none}}$,
        $\mathrm{TX}_{\mathrm{next}, \mathrm{left}}$,
        $\mathrm{TX}_{\mathrm{next}, \mathrm{right}}$,
        $\mathrm{TX}_{\mathrm{next}, \mathrm{both}}$, $C$) $\gets$
        \textsc{virt.getMidTXs}($c$, $c_A$, $c_B$, $\pk{A, F}$, $\pk{B, F}$,
        \texttt{right\_fund\_keys}, $\pk{loc}$,
        \texttt{right\_virt\_keys}[0], \texttt{right\_virt\_keys}[0],
        \texttt{right\_virt\_keys}[1], $\pk{A, V}$, $\pk{B, V}$,
        \texttt{right\_virt\_keys}[0], \texttt{comm\_keys\_loc},
        \texttt{comm\_keys\_rem}, $B$)
        \For{TX in ($\mathrm{TX}_{\mathrm{next}, \mathrm{left}}$,
        $\mathrm{TX}_{\mathrm{next}, \mathrm{right}}$,
        $\mathrm{TX}_{\mathrm{next}, \mathrm{both}}$, $C$)}
          \State add \textsc{sign}(TX, $\sk{\mathrm{loc}}$,
          \textsc{anyprevout}) to $\mathrm{sigs}_{\mathrm{toRight}}$
        \EndFor
      \Else \: \Comment{next hop is \texttt{host\_fundee}}
        \State ($\mathrm{TX}_{\mathrm{next}, \mathrm{none}}$, $C$) $\gets$
        \textsc{virt.getEdgeTXs}($c$, $c_A$, $c_B$, $\pk{A, F}$, $\pk{B, F}$,
        $\pk{loc}$, \texttt{right\_fund\_keys}[0], $\pk{A, V}$, $\pk{B, V}$,
        \texttt{comm\_keys\_loc}, \texttt{comm\_keys\_rem}, False, $B$)
        \State add \textsc{sign}($C$, $\sk{\mathrm{loc}}$, \textsc{anyprevout})
        to $\mathrm{sigs}_{\mathrm{toRight}}$
      \EndIf
      \State call \textsc{virt.circulateVirtualSigs}($c$, \texttt{hops},
      $\mathrm{sigs}_{\mathrm{toRight}}$) of \texttt{hops}[0].\bob and assign
      output to $\mathrm{sigs}_{\mathrm{byRight}}$
      \State $\texttt{fund\_outputs} \gets \{ 2/\{\pk{A, F}, \pk{B, F}\} \}$
      \State ($\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$,
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{left}}$, $\mathrm{TX}_{\mathrm{loc},
      \mathrm{right}}$, $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$, $C$)
      $\gets$ \textsc{virt.getMidTXs}($c$, $c_A$, $c_B$,
      \texttt{left\_fund\_keys}, $\pk{A, F}$, $\pk{B, F}$,
      \texttt{left\_virt\_keys}[0], $\pk{loc}$, $\pk{loc}$,
      \texttt{right\_virt\_keys}[0], $\pk{A, V}$, $\pk{B, V}$, $\pk{loc}$,
      \texttt{comm\_keys\_loc}, \texttt{comm\_keys\_rem}, $A$)
      \For{TX, $i$ in ($\mathrm{TX}_{\mathrm{loc}, \mathrm{left}}$,
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{right}}$, $\mathrm{TX}_{\mathrm{loc},
      \mathrm{both}}$, $C$)}
        \State ensure \textsc{verify}(TX, $\mathrm{sigs}_{\mathrm{byRight}}[i]$,
        \texttt{right\_virt\_keys}[0]) = True
      \EndFor
      \State output (\textsc{virtualSigsBack},
      $\mathrm{sigs}_{\mathrm{byRight}}$) \Comment{sibling needs
      $\mathrm{sigs}_{\mathrm{byRight}}$ for closing}
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:sibling-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.intermediarySigs}()}
    \begin{algorithmic}[1]
      \State $\texttt{fund\_outputs} \gets \{ 2/\{\pk{A, F}, \pk{B, F}\}, 2/\{
      \texttt{right\_fund\_keys}\} \}$
      \State ($\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$,
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{left}}$, $\mathrm{TX}_{\mathrm{loc},
      \mathrm{right}}$, $\mathrm{TX}_{\mathrm{loc}, \mathrm{both}}$, $C$)
      $\gets$ \textsc{virt.getMidTXs}($c$, $c_A$, $c_B$, $\pk{A, F}$, $\pk{B,
      F}$, \texttt{right\_fund\_keys}, \texttt{left\_virt\_keys}[0], $\pk{loc}$,
      $\pk{loc}$, \texttt{right\_virt\_keys}[0], $\pk{A, V}$, $\pk{B, V}$,
      $\pk{loc}$, \texttt{comm\_keys\_loc}, \texttt{comm\_keys\_rem}, $A$)
      \For{TX, $i$ in ($\mathrm{TX}_{\mathrm{loc}, \mathrm{left}}$,
      $\mathrm{TX}_{\mathrm{loc}, \mathrm{right}}$, $\mathrm{TX}_{\mathrm{loc},
      \mathrm{both}}$, $C$)}
        \State ensure \textsc{verify}(TX, $\mathrm{sigs}_{\mathrm{byLeft}}[i]$,
        \texttt{left\_virt\_keys}[0]) = True
      \EndFor
      \State input (\textsc{virtual sigs forward}, \texttt{hops}[1:],
      $\mathrm{sigs}_{\mathrm{byLeft}}$) to \texttt{hops}[1].\alice{}
      \Comment{sibling needs $\mathrm{sigs}_{\mathrm{byLeft}}$ for closing}
      \State \trustedcode{\textsc{virt.siblingSigs}()}
      \State $\mathrm{sigs}_{\mathrm{toLeft}} \gets \emptyset$
      \If{we have \texttt{left\_virt\_keys}[1]} \Comment{previous hop is not
      \texttt{host\_funder}}
        \State ($\mathrm{TX}_{\mathrm{prev}, \mathrm{none}}$,
        $\mathrm{TX}_{\mathrm{prev}, \mathrm{left}}$,
        $\mathrm{TX}_{\mathrm{prev}, \mathrm{right}}$,
        $\mathrm{TX}_{\mathrm{prev}, \mathrm{both}}$, $C$) $\gets$
        \textsc{virt.getMidTXs}($c$, $c_A$, $c_B$, $\pk{A, F}$, $\pk{B, F}$,
        \texttt{right\_fund\_keys}, $\pk{loc}$, \texttt{right\_virt\_keys}[0],
        \texttt{right\_virt\_keys}[0], \texttt{right\_virt\_keys}[1], $\pk{A,
        V}$, $\pk{B, V}$, \texttt{right\_virt\_keys}[0],
        \texttt{comm\_keys\_loc}, \texttt{comm\_keys\_rem}, $B$)
        \For{TX in ($\mathrm{TX}_{\mathrm{prev}, \mathrm{left}}$,
        $\mathrm{TX}_{\mathrm{prev}, \mathrm{right}}$,
        $\mathrm{TX}_{\mathrm{prev}, \mathrm{both}}$, $C$)}
          \State add \textsc{sign}(TX, $\sk{\mathrm{loc}}$, \textsc{anyprevout})
          to $\mathrm{sigs}_{\mathrm{toLeft}}$
        \EndFor
      \Else \: \Comment{previous hop is \texttt{host\_funder}}
        \State ($\mathrm{TX}_{\mathrm{prev}, \mathrm{none}}$, $C$) $\gets$
        \textsc{virt.getEdgeTXs}($c$, $c_B$, $c_A$, $\pk{B, F}$, $\pk{A, F}$,
        \texttt{left\_virt\_keys}[0], $\pk{loc}$,  $\pk{A, V}$, $\pk{B, V}$,
        \texttt{comm\_keys\_rem}, \texttt{comm\_keys\_loc}, True, $B$)
        \State add \textsc{sign}($C$, $\sk{\mathrm{loc}}$, \textsc{anyprevout})
        to $\mathrm{sigs}_{\mathrm{toLeft}}$
      \EndIf
      \State \Return $\mathrm{sigs}_{\mathrm{toLeft}}$
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:intermediary-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.circulateVirtualSigs}($c$, \texttt{hops},
  $\mathrm{sigs}_{\mathrm{byLeft}}$)}
    \begin{algorithmic}[1]
      \State $(\texttt{comm\_keys\_loc}, \texttt{comm\_keys\_rem}) \gets
      \textsc{pcn.getCommKeys}()$
      \If{$\mathrm{sigs}_{\mathrm{byLeft}}$ is given as argument} \Comment{we
      are not \texttt{host\_funder}}
        \If{len(\texttt{hops}[1:]) $\geq 1$} \Comment{we are not
        \texttt{host\_fundee}}
          \State \Return \textsc{virt.intermediarySigs}()
        \Else \: \Comment{we are \texttt{host\_fundee}}
          \State $\texttt{fund\_outputs} \gets \{ 2/\{\pk{A, F}, \pk{B, F}\} \}$
          \State ($\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$, $C$) $\gets$
          \textsc{virt.getEdgeTXs}($c$, $c_B$, $c_A$, $\pk{B, F}$, $\pk{A, F}$,
          \texttt{left\_virt\_keys}[0], $\pk{loc}$, $\pk{A, V}$, $\pk{B, V}$,
          \texttt{comm\_keys\_rem}, \texttt{comm\_keys\_loc}, False, $A$)
          \State ensure \textsc{verify}($C$,
          $\mathrm{sigs}_{\mathrm{byLeft}}[0]$, \texttt{left\_virt\_keys}[0]) =
          True
          \State ($\mathrm{TX}_{\mathrm{prev}, \mathrm{none}}$,
          $\mathrm{TX}_{\mathrm{prev}, \mathrm{left}}$,
          $\mathrm{TX}_{\mathrm{prev}, \mathrm{right}}$,
          $\mathrm{TX}_{\mathrm{prev}, \mathrm{both}}$, $C$) $\gets$
          \textsc{virt.getMidTXs}($c$, $c_A$, $c_B$, $\pk{A, F}$, $\pk{B, F}$,
          \texttt{right\_fund\_keys}, $\pk{loc}$, \texttt{right\_virt\_keys}[0],
          \texttt{right\_virt\_keys}[0], \texttt{right\_virt\_keys}[1], $\pk{A,
          V}$, $\pk{B, V}$, \texttt{right\_virt\_keys}[0],
          \texttt{comm\_keys\_loc}, \texttt{comm\_keys\_rem}, $B$)
          \State $\mathrm{sigs}_{\mathrm{toLeft}} \gets \emptyset$
          \For{TX in ($\mathrm{TX}_{\mathrm{prev}, \mathrm{left}}$,
          $\mathrm{TX}_{\mathrm{prev}, \mathrm{right}}$,
          $\mathrm{TX}_{\mathrm{prev}, \mathrm{both}}$, $C$)}
            \State add \textsc{sign}(TX, $\sk{\mathrm{loc}}$, \textsc{anyprevout})
            to $\mathrm{sigs}_{\mathrm{toLeft}}$
          \EndFor
          \State \Return $\mathrm{sigs}_{\mathrm{toLeft}}$
        \EndIf
      \Else \: \Comment{we are \texttt{host\_funder}}
        \State ($\mathrm{TX}_{\mathrm{next}, \mathrm{none}}$,
        $\mathrm{TX}_{\mathrm{next}, \mathrm{left}}$,
        $\mathrm{TX}_{\mathrm{next}, \mathrm{right}}$,
        $\mathrm{TX}_{\mathrm{next}, \mathrm{both}}$, $C$) $\gets$
        \textsc{virt.getMidTXs}($c$, $c_A$, $c_B$, $\pk{A, F}$, $\pk{B, F}$,
        \texttt{right\_fund\_keys}, $\pk{loc}$, \texttt{right\_virt\_keys}[0],
        \texttt{right\_virt\_keys}[0], \texttt{right\_virt\_keys}[1], $\pk{A,
        V}$, $\pk{B, V}$, \texttt{right\_virt\_keys}[0],
        \texttt{comm\_keys\_loc}, \texttt{comm\_keys\_rem}, $B$)
        \State $\mathrm{sigs}_{\mathrm{toRight}} \gets \emptyset$
        \For{TX in ($\mathrm{TX}_{\mathrm{next}, \mathrm{left}}$,
        $\mathrm{TX}_{\mathrm{next}, \mathrm{right}}$,
        $\mathrm{TX}_{\mathrm{next}, \mathrm{both}}$, $C$)}
          \State add \textsc{sign}(TX, $\sk{\mathrm{loc}}$, \textsc{anyprevout})
          to $\mathrm{sigs}_{\mathrm{toRight}}$
        \EndFor
        \State call \textsc{virt.circulateVirtualSigs}($c$, \texttt{hops},
        $\mathrm{sigs}_{\mathrm{toRight}}$) of \texttt{hops}[0].\bob and
        assign output to $\mathrm{sigs}_{\mathrm{byRight}}$
        \State $\texttt{fund\_outputs} \gets \{ 2/\{\pk{A, F}, \pk{B, F}\} \}$
        \State ($\mathrm{TX}_{\mathrm{loc}, \mathrm{none}}$, $C$) $\gets$
        \textsc{virt.getEdgeTXs}($c$, $c_A$, $c_B$, $\pk{A, F}$, $\pk{B, F}$,
        $\pk{loc}$, \texttt{right\_virt\_keys}[0], $\pk{A, V}$, $\pk{B, V}$,
        \texttt{comm\_keys\_loc}, \texttt{comm\_keys\_rem}, True, $A$)
        \State ensure \textsc{verify}($C$,
        $\mathrm{sigs}_{\mathrm{byRight}}[0]$, \texttt{right\_virt\_keys}[0]) =
        True
        \State \Return (\textsc{ok})
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:virtual-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.circulateFundingSigs}(\texttt{hops},
      $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$)}
    \begin{algorithmic}[1]
      \If{$\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$ is given as argument}
      \Comment{we are not \texttt{host\_funder}}
        \State ensure \textsc{verify}($\mathrm{TX}_{\mathrm{loc},
        \mathrm{none}}$, $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$,
        \texttt{left\_virt\_keys}[0]) = True
        \State $\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}} \gets \{
        \mathrm{sig}_{\mathrm{loc}, \mathrm{none}} \}$
        \If{len(\texttt{hops}[1:]) $\geq 1$} \Comment{we are not
        \texttt{host\_fundee}}
          \State input (\textsc{virtual base sig forward}, \texttt{hops}[1:],
          $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$) to
          \texttt{hops}[1].\alice{} \Comment{sibling needs
          $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$ for closing}
          \State \trustedcode{$\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}} \gets
          \{ \mathrm{sig}_{\mathrm{loc}, \mathrm{none}} \}$}
          \State \trustedcode{$\mathrm{sig}_{\mathrm{next}, \mathrm{none}} \gets
          \textsc{sign}(\mathrm{TX}_{\mathrm{next}, \mathrm{none}},
          \sk{\mathrm{loc}, F})$}
          \State \trustedcode{call
          \textsc{virt.circulateVirtualSigs}(\texttt{hops},
          $\mathrm{sig}_{\mathrm{next}, \mathrm{none}}$) of
          \texttt{hops}[0].\bob and assign output to
          $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$}
          \State \trustedcode{ensure \textsc{verify}($\mathrm{TX}_{\mathrm{loc},
          \mathrm{none}}$, $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$,
          \texttt{right\_virt\_keys}[0]) = True}
          \State \trustedcode{add $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$
          to $\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}}$}
          \State \trustedcode{output (\textsc{virtual base sig back},
          $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$) \Comment{sibling needs
          $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$ for closing}}
          \State add $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$ to
          $\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}}$
        \EndIf
        \State $\mathrm{sig}_{\mathrm{prev}, \mathrm{none}} \gets
        \textsc{sign}(\mathrm{TX}_{\mathrm{prev}, \mathrm{none}},
        \sk{\mathrm{loc}, F})$
        \State \Return $\mathrm{sig}_{\mathrm{prev}, \mathrm{none}}$
      \Else \: \Comment{we are \texttt{host\_funder}}
        \State $\mathrm{sig}_{\mathrm{next}, \mathrm{none}} \gets
        \textsc{sign}(\mathrm{TX}_{\mathrm{next}, \mathrm{none}},
        \sk{\mathrm{loc}, F})$
        \State call \textsc{virt.circulateFundingSigs}(\texttt{hops},
        $\mathrm{sig}_{\mathrm{next}, \mathrm{none}}$) of \texttt{hops}[0].\bob
        and assign output to $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$
        \State ensure \textsc{verify}($\mathrm{TX}_{\mathrm{loc},
        \mathrm{none}}$, $\mathrm{sig}_{\mathrm{loc}, \mathrm{none}}$,
        \texttt{right\_virt\_keys}[0]) = True
        \State $\mathrm{sigs}_{\mathrm{loc}, \mathrm{none}} \gets \{
        \mathrm{sig}_{\mathrm{loc}, \mathrm{none}} \}$
        \State \Return (\textsc{ok})
      \EndIf
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:funding-sigs}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt.circulateRevocations}(\texttt{hops},
  \texttt{revoc\_by\_prev})}
    \begin{algorithmic}[1]
    \If{\texttt{revoc\_by\_prev} is given as argument} \Comment{we are not
    \texttt{host\_funder}}
      \State ensure
      \textsc{pcn.processRemoteRevocation}(\texttt{revoc\_by\_prev}) returns
      (\textsc{ok})
    \Else \: \Comment{we are \texttt{host\_funder}}
      \State $\texttt{revoc\_for\_next} \gets \textsc{pcn.revokePrevious}()$
      \State call \textsc{virt.circulateRevocations}(\texttt{hops},
      \texttt{revoc\_for\_next}) of \texttt{hops}[0].\bob and assign output to
      \texttt{revoc\_by\_next}
      \State ensure
      \textsc{pcn.processRemoteRevocation}(\texttt{revoc\_by\_next}) returns
      (\textsc{ok})
      \State \Return (\textsc{ok})
    \EndIf
    \If{len(\texttt{hops}[1:]) $\geq 1$} \Comment{we are not
    \texttt{host\_fundee} nor \texttt{host\_funder}}
      \State input (\textsc{virtual revocation forward}, \texttt{hops}[1:]) to
      \texttt{hops}[1].\alice
      \State \trustedcode{$\texttt{revoc\_for\_next} \gets
      \textsc{pcn.revokePrevious}()$}
      \State \trustedcode{call \textsc{virt.circulateRevocations}(\texttt{hops},
      \texttt{revoc\_for\_next}) of \texttt{hops}[0].\bob and assign output to
      \texttt{revoc\_by\_next}}
      \State \trustedcode{ensure
      \textsc{pcn.processRemoteRevocation}(\texttt{revoc\_by\_next}) returns
      (\textsc{ok})}
      \State \trustedcode{output (\textsc{virtual revocation back})}
    \EndIf
    \State $\texttt{revoc\_for\_prev} \gets \textsc{pcn.revokePrevious}()$
    \State \Return \texttt{revoc\_for\_prev}
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer:revocation}
\end{figure}

\begin{figure}[H]
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State \textsc{close}($P$):
        \TODO{continue}
        \TODO{handle arbitrarily nested virtuals (now we only handle one level
        and it leads to nested ifs}
        \If{both channel parties are honest}
          \If{$\mathtt{funded} \neq \emptyset$}
            \State \TODO{prepare virtual layer TX $V$ and its signature --
            careful, may be unneded!}
            \State $C \gets$ TX \{input: $V$.output, outputs: $(c_A, \pk{A,
            \mathrm{out}} + t), (c_B, \pk{B, \mathrm{out}})$\}
            \State $\mathrm{sig}_{B, C} \gets \textsc{sign}(C, \sk{B, V})$
            \State $\mathrm{sig}_{A, C} \gets \textsc{sign}(C, \sk{A, V})$
          \Else
            \State $C \gets$ TX \{input: $F$.output, outputs: $(c_A, \pk{A,
            \mathrm{out}} + t), (c_B, \pk{B, \mathrm{out}})$\}
            \State $\mathrm{sig}_{B, C} \gets \textsc{sign}(C, \sk{B, F})$
            \State $\mathrm{sig}_{A, C} \gets \textsc{sign}(C, \sk{A, F})$
          \EndIf
        \EndIf \: \Comment{if \bob is corrupted, we already have $C$ and
        $\mathrm{sig}_{B, C}$}
        \State $\mathit{State} \gets \textsc{closed}$
        \If{$\mathit{State} = \textsc{open base}$}
          \State input (\textsc{submit}, $(V, \mathrm{sig}_{A, V},
          \mathrm{sig}_{B, V})$, $(C, \mathrm{sig}_{A, C}, \mathrm{sig}_{B,
          C})$) to \ledger
        \Else \: \Comment{$\mathit{State} = \textsc{open virtual}$}
          \If{\alice is the one that had received (\textsc{open virtual}, $\dots$)
          by \texttt{opener}}
            \State $\texttt{initiator} \gets \texttt{opener}$; $\texttt{other}
            \gets \texttt{outer\_peer}$
          \Else \: \Comment{\bob had received (\textsc{open virtual} $\dots$)}
            \State $\texttt{initiator} \gets \texttt{outer\_peer}$;
            $\texttt{other} \gets \texttt{opener}$
          \EndIf
          \If{both parties are honest}
            \If{$\texttt{funded} \neq \emptyset$}
              \State \TODO{prepare virtual layer TXs $V_A, V_B$ and their
              signatures}
              \State $C' \gets$ TX \{input: $V$.output, outputs: $(c_A, \pk{A,
              \mathrm{out}}), (c_B, \pk{B, \mathrm{out}} + t)$\}
              \State $\mathrm{sig}_{A, C}' \gets \textsc{sign}(C', \sk{A, V})$;
              $\mathrm{sig}_{B, C}' \gets \textsc{sign}(C', \sk{B, V})$
            \Else \: \Comment{there are no virtual channels on top of us}
              \State $C' \gets$ TX \{input: $F$.output, outputs: $(c_A, \pk{A,
              \mathrm{out}}), (c_B, \pk{B, \mathrm{out}} + t)$\}
              \State $\mathrm{sig}_{A, C}' \gets \textsc{sign}(C', \sk{A, F})$;
              $\mathrm{sig}_{B, C}' \gets \textsc{sign}(C', \sk{B, F})$
            \EndIf
            \State provide delayed output (\textsc{peer closed virtual}, $(V_B,
            \mathrm{sig}_{A, V_B}, \mathrm{sig}_{B, V_B})$, $(C',
            \mathrm{sig}_{A, C}', \mathrm{sig}_{B, C}')$) to \texttt{other} as
            \bob
          \EndIf
          \If{$\mathtt{funded} \neq \emptyset$}
            \State $\mathtt{output} \gets (\textsc{closed virtual}, (V,
            \mathrm{sig}_{A, V}, \mathrm{sig}_{B, V}), (C, \mathrm{sig}_{A, C},
            \mathrm{sig}_{B, C}))$
          \Else
            \State $\mathtt{output} \gets (\textsc{closed virtual}, (C,
            \mathrm{sig}_{A, C}, \mathrm{sig}_{B, C}))$
          \EndIf
          \State output \texttt{output} to \texttt{initiator} as \alice
        \EndIf
        \Statex

        \State \textsc{closed}($c_L$, $c_R$, $(\mathrm{tx}_i,
        (\sigma_{ij})_j)_i$):
        \Indent
          \ForAll{$i$ in $1 \dots |(\mathrm{tx}_i, (\sigma_{ij})_j)_i|$}
            \State ensure \textsc{verify}($\mathrm{tx}_i$, $(\sigma_{ij})_j$) =
            True
          \EndFor
          \State ensure ($\mathrm{tx}_1$, $(\sigma_{1j})_j$) has exactly $1$
          input, which spends an output of $V$ of value $c_L + c_R$
          \State return (\textsc{ok})
        \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer}
\end{figure}
