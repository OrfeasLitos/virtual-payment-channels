\section{Protocol Pseudocode}
\label{sec:pseudocode}

We here present a simplified version of the protocol. We omit
complications imposed by UC. Appx.~\ref{sec:protocol} contains
the full protocol and Appx.~\ref{sec:construction} its in-depth
description in prose.
\ \\

\begin{center}
  \begin{processbox}{\pchan -- self is $P$}
    \algnotext{EndIf}
    \begin{itemize}
      \item At the beginning of each activation:
      \begin{algorithmic}[0]
      % TODO: change 0 to 1 if line numbers needed in all algorithm snippets.
      % Due to number duplication, we may need to scrap itemize and have one big
      % algorithmic instead
        \If{we have not been activated for more than $p$ blocks}
          \State We are negligent \Comment{no balance security guarantees}
        \EndIf
      \end{algorithmic}

      \item Open channel with counterparty $P'$:
      \begin{algorithmic}[0]
        \State Generate funding and revocation keypairs.
        \State Exchange funding, revocation \& own public keys with $P'$.
        \If{opening virtual (off-chain) channel}
          \State Run next bullet ``Host a virtual channel'' as endpoint.
        \EndIf
        \State Exchange \& verify signatures on commitment txs with $P'$.
        \If{opening simple (on-chain) channel}
          \State Prepare and submit funding transaction to ledger and wait for
          its inclusion. \Comment{only one party funds the channel, so the
          funding transaction needs only the funder's signature}
          \State $t_P \gets s + p$ \Comment{simple channel timelock}
          \State \Comment{$s$: max blocks before submitted tx enters ledger}
        \EndIf
      \end{algorithmic}

      \item Host a virtual channel of $c$ coins (endpoint or intermediary):
      \begin{algorithmic}[0]
        \State Ensure we have at least $c$ coins.
        \State Generate one new funding keypair, $O(n^2)$ virtual keypairs
        ($O(n)$ per hop) and one virtual revocation keypair.
        \State Exchange these public keys with all base channel parties.
        \State Generate and sign new commitment txs with our counterparty/ies
        ($1$ if endpoint, $2$ if intermediary), using the new funding and latest
        revocation keys and reducing by $c$ the balance of the party ``closer''
        to the funder.
        \State Exchange signatures with counterparty/ies and verify them.
        \State Generate and sign all $O(n^3)$ virtual and bridge txs.
        \State Exchange all signatures among all base channel parties and verify
        that all our virtual txs have fully signed inputs.
        \State Exchange with counterparty/ies and verify signatures for the
        funding inputs of our initiator and extend-interval txs.
        \State Exchange with counterparty/ies and verify signatures for the
        revocation txs of the previous channel state.
        \If{we are intermediary}
          \State $t_P \gets \max\{t \text{ of left channel}, t \text{ of right
          channel}\}$
        \Else \: \Comment{we are endpoint}
          \State $t_P \gets p + \sum_{j = 2}^{n-1}(s - 1 + t_j)$
          \Comment{max delay is $O($sum of intermediaries' delays$)$. Occurs
          when we use initiator tx and each intermediary uses extend-interval tx
          sequentially.}
        \EndIf
      \end{algorithmic}

      \item React if counterparty publishes virtual tx:
      \begin{algorithmic}[0]
        \State Publish our only valid virtual tx. \Comment{if both
        counterparties have published, this is a merge-intervals tx, otherwise
        it is an extend-interval tx.}
      \end{algorithmic}

      \item Pay $x$ coins to $P'$ over our (simple or virtual) channel:
      \begin{algorithmic}[0]
        \State Ensure we have at least $x$ coins.
        \If{we host a virtual channel}
          \State Ensure new balance prevents griefing.
          \Comment{cf.~\ref{construction:ln}}
        \EndIf
        \State Generate and sign new commitment txs, with $x$ coins less for the
        payer and $x$ coins more for the payee.
        \State Exchange and verify signatures.
        \State Sign revocation txs corresponding to old commitment txs.
        \State Generate next revocation keypairs.
        \State Exchange and verify revocation signatures and public keys.
      \end{algorithmic}

      \item Close virtual channel unilaterally:
      \begin{algorithmic}[0]
        \State Publish initiator \& bridge tx. \Comment{Funding output is
        on-chain}
        \State Publish our latest commitment tx on-chain.
      \end{algorithmic}

      \item Close virtual channel cooperatively: \Comment{Only if not hosting}
      \begin{algorithmic}[0]
        \State Endpoints sign \& send their balance $(c_1, c_2)$ to all
        parties.
        \State Parties verify sigs, ensure endpoints agree and $c_1 + c_2 = c$.
        \State All parties generate and sign new commitment txs with:
        \begin{itemize}
          \item the funding keys used before opening virtual channel,
          \item the new revocation keys, and
          \item $c_1$ more coins to party closer to funder, $c_2$ to the
          other.
        \end{itemize}
        \State All parties generate new revocation keypairs.
        \State All pairs exchange \& verify sigs \& revocation public keys.
        \State All parties generate and sign revocation txs for the old virtual,
        bridge and commitment txs.
        \State All pairs exchange and verify signatures.
      \end{algorithmic}

      \item Punish malicious counterparties: \Comment{Run every $p$ blocks}
      \begin{algorithmic}[0]
        \If{an old commitment tx is on-chain}
          \State Sign and publish the corresponding revocation tx.
        \EndIf
        \If{the ledger contains an old virtual or bridge tx}
          \State Sign and publish the corresponding revocation tx(s)
        \EndIf
      \end{algorithmic}
    \end{itemize}
  \end{processbox}
  \captionof{figure}{High level pseudocode of the Elmo protocol}
  \label{code:pseudocode}
\end{center}
