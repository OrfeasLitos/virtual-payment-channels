\TODO{Add support for cooperative adding multiple virtuals to single channel
(needs cooperation by all hops of all existing virtuals of current channel)}
\TODO{Add support for cooperative closing (for virtual it also needs cooperation
with all hops of all existing virtuals, we should definitely find another way)}
\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- init \& top up}
    \begin{algorithmic}[1]
      \State Initialisation: \Comment{runs on first activation}
      \Indent
        \State $\mathit{State} \gets \textsc{init}$
        \State $(\mathrm{locked}_A, \mathrm{locked}_B) \gets (0, 0)$
      \EndIndent
      \Statex

      \State On (\textsc{top up}, $c_{\mathrm{min}}$) by \alice:
      \label{code:functionality:chan:skeleton:init:top_up:start}
      \Indent
        \State ensure $\mathit{State} = \textsc{init}$
        \State $\mathit{State} \gets \textsc{sent key}$
        \State $(sk, pk) \gets \textsc{keyGen}()$
        \State output (\textsc{public key}, $pk$) to \alice
        \label{code:functionality:chan:skeleton:init:top_up:end}
      \EndIndent
      \Statex

      \State On (\textsc{check top up}) by \alice:
      \label{code:functionality:chan:skeleton:init:check_top_up:start}
      \Indent
        \State ensure $\mathit{State} = \textsc{sent key}$
        \State input (\textsc{read}) to \ledger as \alice and assign ouput to
        $\Sigma$
        \State ensure $\exists \mathrm{tx} \in \Sigma, c_{\mathrm{on}}:
        c_{\mathrm{on}} \geq c_{\mathrm{min}} \wedge (c_{\mathrm{on}}, pk) \in
        \mathrm{tx.outputs}$
        \State $\mathtt{base\_output} \gets (c_{\mathrm{on}}, pk) \text{ of tx}$
        \State $\mathit{State} \gets (\textsc{topped up}, \alice)$
        \State output (\textsc{topped up}) to \alice
        \label{code:functionality:chan:skeleton:init:check_top_up:end}
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:init}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- base}
    \begin{algorithmic}[1]
      \State On (\textsc{open}, $c_F$, $pk_{A, \mathrm{out}}$, $pk_{B,
      \mathrm{out}}$) by \alice:
      \Indent
        \State ensure $\mathit{State} = (\textsc{topped up}, \alice)$
        \State ensure $c_F = c_{\mathrm{on}}$
        \State $(sk_{A, F}, pk_{A, F}) \gets \textsc{keyGen}()$; $(sk_{B, F},
        pk_{B, F}) \gets \textsc{keyGen}()$
        \State $F \gets$ TX \{input: \texttt{base\_output}, output: $(c_F,
        2/\{pk_{A, F}, pk_{B, F}\})$\}
        \State $\mathrm{sig}_F \gets \textsc{sign}(F, sk)$
        \State $\mathit{State} \gets \textsc{waiting for ledger}$
        \State send $(\textsc{open}, c_F, pk_{A, \mathrm{out}}, pk_{B,
        \mathrm{out}}, F, \mathrm{sig}_F, \alice)$ to \adversary
      \EndIndent
      \Statex

      \State On (\textsc{check funding}) by \alice:
      \Indent
        \State ensure $\mathit{State} = \textsc{waiting for ledger}$
        \State input (\textsc{read}) to \ledger as \alice and assign output to
        $\Sigma$
        \State ensure $F \in \Sigma$
        \State $c_A \gets c$; $c_B \gets 0$
        \State $\mathit{State} \gets \textsc{open base}$
        \State output (\textsc{open success}) to \alice
      \EndIndent
      \Statex

      \State On (\textsc{pay}, $x$) by $\dave \in \{\alice, \bob\}$:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure $c_D - \mathrm{locked}_D \geq x$
        \State send (\textsc{pay}, $x$, \dave) to \adversary and expect reply
        (\textsc{ok})
        \State $c_D \gets c_D - x; c_{\bar{D}} \gets c_{\bar{D}} + x$
        \Comment{$\bar{D}$ is \alice if $D$ is \bob and vice-versa}
        \State output (\textsc{pay success}) to \dave
      \EndIndent
      \Statex

      \State On (\textsc{balance}) by $\dave \in \{\alice, \bob\}$:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State output (\textsc{balance}, $(c_A, c_B, \mathrm{locked}_A,
        \mathrm{locked}_B)$) to \dave % TODO: maybe remove locked_{A,B}
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:base}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- close Pt. 1}
    \begin{algorithmic}[1]
      \State On (\textsc{close}) by \alice:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \If{both channel parties are honest}
          \State $C \gets$ TX \{input: $F$.output, outputs: $(c_A, pk_{A,
          \mathrm{out}} \wedge t), (c_B, pk_{B, \mathrm{out}})$\}
          \State $\mathrm{sig}_{B, C} \gets \textsc{sign}(C, sk_{B, F})$
        \EndIf \Comment{if \bob is corrupted, we already have $C$ and
        $\mathrm{sig}_{B, C}$}
        \State $\mathrm{sig}_{A, C} \gets \textsc{sign}(C, sk_{A, F})$
        \State $\mathit{State} \gets \textsc{closed}$
        \If{$\mathit{State} = \textsc{open base}$}
          \State input (\textsc{submit}, $(C, \mathrm{sig}_{A, C},
          \mathrm{sig}_{B, C})$) to \ledger
        \ElsIf{$\mathit{State} = \textsc{open virtual}$}
          \If{\alice had received \textsc{fund you}} \Comment{by
          \texttt{opener}}
            \State $\mathrm{initiator} \gets \mathtt{opener}$; $\mathrm{other}
            \gets \mathtt{outer\_peer}$
          \Else
            \State $\mathrm{initiator} \gets \mathtt{outer\_peer}$;
            $\mathrm{other} \gets \mathtt{opener}$
          \EndIf
          \If{both parties are honest}
            \State $C' \gets$ TX \{input: $F$.output, outputs: $(c_A, pk_{A,
            \mathrm{out}}), (c_B, pk_{B, \mathrm{out}} \wedge t)$\}
            \State $\mathrm{sig}_{A, C}' \gets \textsc{sign}(C', sk_{A, F})$;
            $\mathrm{sig}_{B, C}' \gets \textsc{sign}(C', sk_{B, F})$
            \State output (\textsc{peer closed virtual}, $(C', \mathrm{sig}_{A,
            C}', \mathrm{sig}_{B, C}')$ to other as \bob and expect reply
            (\textsc{ok})
          \EndIf
          \State output (\textsc{closed virtual}, $(C, \mathrm{sig}_{A, C},
          \mathrm{sig}_{B, C})$) to initiator as \alice
        \EndIf
      \EndIndent
      \Statex

      \State On (\textsc{close}, \alice) by \adversary:
      \Indent
        \State ensure that \alice is corrupted, \bob is honest
        \State $C' \gets$ TX \{input: $F$.output, outputs: $(c_B, pk_{B,
        \mathrm{out}}), (c_A, pk_{A, \mathrm{out}} \wedge t)$\}
        \State $\mathrm{sig}_{B, C'} \gets \textsc{sign}(C', sk_{B, F})$
        \State $\mathit{State} \gets \textsc{closed}$
        \State send (C', $\mathrm{sig}_{B, C'}$) to \adversary
        \State \TODO{asynchronously, if a lot of time passes and $C'$ not in
        \ledger, submit $C$ to \ledger for good measure}
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:close:pt1}
\end{figure}
\TODO{send comm TXs of sub-virtuals to our base as well}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- close Pt. 2}
    \begin{algorithmic}[1]
      \State On (\textsc{closed virtual}, $(C, \mathrm{sig}_{A, C},
      \mathrm{sig}_{B, C})$) by \charlie:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure (($c_L$, $c_R$), hops, (\charlie, \dave), (\frank,
        \george), $pk_{A, V}$, $pk_{B, V}$, id) $\in$ \texttt{funded}
        with $\frank \in \{\alice, \bob\}$ \Comment{no stored commitment TX in
        entry yet}
        \State ensure \textsc{verify}($C$, $\mathrm{sig}_{A, C}$, $pk_{A, V}$)
        = \textsc{verify}($C$, $\mathrm{sig}_{B, C}$, $pk_{B, V}$) = True
        \State $c_{\mathrm{left}} \gets C\text{.outputs.(the timelocked
        output).coins}$
        \State $c_{\mathrm{right}} \gets C\text{.outputs.(the other
        output).coins}$
        \State ensure $c_{\mathrm{left}} + c_{\mathrm{right}} = c_L + c_R$
        \State add message contents to \texttt{funded} entry
        \State output (\textsc{closed virtual}, $c_{\mathrm{left}}$, id) to
        \frank
      \EndIndent
      \Statex

      \TODO{delete following and make it work like previous, but return OK to
      \dave}
      \State On (\textsc{peer closed virtual}, $c_{\mathrm{right}}$, id) by
      \dave:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure $(\mathrm{virtual}, c, \fchan, \dave, \mathrm{id}) \in
        \mathtt{funded}$
        \State ensure $c_{\mathrm{right}} \leq c$
        \State send (\textsc{closed}) to virtual and expect reply (\textsc{yes})
        \State $c_D \gets c_D + c_{\mathrm{right}}$
        \State remove entry from \texttt{funded}
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:close:pt2}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- fund virtual}
    \begin{algorithmic}[1]
      \State On (\textsc{fund}, $c$, hops, \texttt{sub\_parties} = (fundee,
      counterparty), \texttt{outer\_parties} = (\alice, \dave),
      $pk_{\mathit{VA}, out}$, $pk_{\mathit{VB}, out}$) by \alice:
      \Comment{we fund another channel} \TODO{use $pk_{VA}$ in virtual LN()}
      % TODO: decide if \alice of outer_parties should be \charlie instead
      \label{code:functionality:chan:skeleton:virtual:fund}
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure $c_A - \mathrm{locked}_A \geq c$
        \State input (\textsc{fund you}, $c$, counterparty, \dave) to fundee as
        \alice, ensure output is (\textsc{ok}, $pk_{A, V}$, $pk_{B, V}$)
        \label{code:functionality:chan:skeleton:virtual:subfunc}
        \State generate random id
        \label{code:functionality:chan:skeleton:virtual:id}
        \State send (\textsc{fund} $c$, hops, \texttt{sub\_parties} = (fundee,
        counterparty), \texttt{outer\_parties} = (\alice, \dave),
        \texttt{funder} = \alice, id) to \adversary and ensure reply is
        (\textsc{ok})
        \label{code:functionality:chan:skeleton:virtual:fund:leak}
        \State $(L_0, R_0) \gets (\alice, \bob)$
        \label{code:functionality:chan:skeleton:virtual:fund:init}
        \ForAll{$(L_i, R_i) \in \mathrm{hops}$} \Comment{$i \in \{1, \dots,
        |\mathrm{hops}|\}$}
        \label{code:functionality:chan:skeleton:virtual:fund:for:allow:start}
          \State ensure $R_{i-1} = L_i$
          \State send (\textsc{allow fund}, $c$, \texttt{sub\_parties}, id, $i
          \overset{?}{=} |\mathrm{hops}|$) to $L_i$ as \alice and ensure reply
          is (\textsc{ok})
          \label{code:functionality:chan:skeleton:virtual:fund:for:allow:send}
        \EndFor
        \label{code:functionality:chan:skeleton:virtual:fund:for:allow:end}
        \If{both channel parties are honest}
          \State send (\textsc{is open successful}, id) to \adversary and ensure
          reply is (\textsc{ok})
        \ElsIf{only \alice is honest}
          \State $(sk_{A, V}, pk_{A, V}) \gets \textsc{keyGen}()$
          \State send (\textsc{update to virtual}, $pk_{A, V}$) to \adversary
          and assign reply to ($V =$ TX \{input: $F$.output, outputs: ($c_A +
          c_B - c$, $2/\{pk_{A, V}, pk_{B, V}\}$), ($c$, $2/\{pk_{G, V}, pk_{A,
          V}\}$), (0, $|\mathrm{hops}|$/$\{\mathrm{hops}_i.pk\}_i$)\},
          $\mathrm{sig}_{B, V}$, $C' =$ TX \{input: $V$.outputs.0, outputs:
          $(c_A - \mathrm{locked}_A - c, pk_{A, \mathrm{out}} \wedge t), (c_B -
          \mathrm{locked}_B, pk_{B, \mathrm{out}})$\}, $\mathrm{sig}_{B, C'}$)
          \TODO{think about locked coins}
          \State ensure \textsc{verify}($V$, $\mathrm{sig}_{B, V}$, $pk_{B,
          F}$) = \textsc{verify}($C'$, $\mathrm{sig}_{B, C'}$, $pk_{A, V}$) =
          True
        \EndIf
        \label{code:functionality:chan:skeleton:virtual:fund:simulate}
        \ForAll{$(L_i, R_i) \in \mathrm{hops}$} \Comment{$i \in \{1, \dots,
        |\mathrm{hops}|\}$}
        \label{code:functionality:chan:skeleton:virtual:fund:confirm}
          \State send (\textsc{fund done}, id) to $L_i$ as \alice and ensure
          reply is (\textsc{ok})
        \EndFor
        \State $c_A \gets c_A - c$
        \If{only \alice is honest}
          \State $C \gets C'$; $\mathrm{sig}_{B, C} \gets \mathrm{sig}_{B, C'}$
        \EndIf
        % TODO: decide if need to store hops here
        \State add (($c$, 0), hops, \texttt{sub\_parties},
        \texttt{outer\_parties}, $pk_{A, V}$, $pk_{B, V}$, id) to
        \texttt{funded}
        \label{code:functionality:chan:skeleton:virtual:fund:store}
        \State output (\textsc{ok}) to \alice
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:virtual:fund:fig}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- virtual}
    \begin{algorithmic}[1]
      \State On input (\textsc{fund you}, $c$, local peer, \texttt{outer\_peer})
      by $\charlie$ to \alice: \Comment{\alice is funded by \charlie}
      \label{code:functionality:chan:skeleton:virtual:fund-you}
      \Indent
        \TODO{what if counterparty corrupted?}
        \State ensure $\mathit{State} = \textsc{init}$
        \State $\bob \gets \text{local peer}$
        \State send (\textsc{fund you}, $c$, \bob, \charlie, \alice) to
        \adversary and ensure reply is \textsc{(ok)}
        \label{code:functionality:chan:skeleton:virtual:inform}
        \State $c_A \gets c; c_B \gets 0$
        \State $\mathtt{opener} \gets \charlie$
        \State $(sk_{A, V}, pk_{A, V}) \gets \textsc{keyGen}()$; $(sk_{B, V},
        pk_{B, V}) \gets \textsc{keyGen}()$
        \State from now on, handle any (\textsc{relayed}, $m$) input by
        \{\texttt{opener}, \texttt{outer\_peer}\} as if it were input ($m$) by
        \{\alice, \bob\} respectively
        \State from now on, transform any output ($m$) to $\{\alice, \bob\}$ to
        output (\textsc{relay}, $m$) to $\{\mathtt{opener},
        \mathtt{outer\_peer}\}$ respectively
        \State $\mathit{State} \gets \textsc{open virtual}$
        \State output (\textsc{ok}, $pk_{A, V}$, $pk_{B, V}$) to \charlie
      \EndIndent
      \Statex

      \State On (\textsc{allow fund}, $c$, \texttt{sub\_parties},
      \texttt{next\_hop}, id, \texttt{is\_last}) to \dave by \charlie:
      \label{code:functionality:chan:skeleton:virtual:allow-fund}
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure $\dave \in \{\alice, \bob\}$ \Comment{defensive check, may
        be redundant due to UC rules}
        \State ensure $c_D - \mathrm{locked}_D \geq c$
        \State ensure \dave's counterparty belongs to the same group as
        \texttt{next\_hop}
        \State output received message to \dave and ensure reply is
        \textsc{(ok)}
        \State $\mathrm{locked}_D \gets \mathrm{locked}_D + c$
        \State add (id, \texttt{is\_last}, \texttt{sub\_parties}, $c$, \dave) to
        \texttt{pending}
        \State send (\textsc{ok}) to \charlie
      \EndIndent
      \Statex

      \State On (\textsc{fund done}, id) by \charlie:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure $(\mathrm{id}, \mathtt{is\_last}, \mathtt{sub\_parties},
        $c$, \dave) \in \mathtt{pending}$
        \State remove (id, \texttt{is\_last}, \texttt{sub\_parties}, $c$, \dave)
        from \texttt{pending}
        \If{\texttt{is\_last}}
          \State add ((0, $c$), $\bot$, \texttt{sub\_parties}.reverse(),
          (\dave, $\bot$), id) to \texttt{funded}
        \EndIf
        \State send (\textsc{ok}) to \charlie
      \EndIndent
      \Statex

      \State On (\textsc{relay}, $m$, \charlie) by \alice:
      \Indent
        \State ensure there is an entry in \texttt{funded} with \alice as funder
        outer party and \charlie as fundee sub-party
        \label{code:functionality:chan:skeleton:virtual:relay:input:start}
        \State input (\textsc{relayed}, $m$) to \charlie
        \label{code:functionality:chan:skeleton:virtual:relay:input:end}
      \EndIndent
      \Statex

      \State On output (\textsc{relay}, $m$) by \charlie to \alice:
      \Indent
        \State ensure there is an entry in \texttt{funded} with \alice as funder
        outer party and \charlie as fundee sub-party \Comment{defensive check,
        may be redundant due to being subroutine respecting}
        \label{code:functionality:chan:skeleton:virtual:relay:output:start}
        \State output (\textsc{relayed}, $m$, \charlie) to \environment
        \label{code:functionality:chan:skeleton:virtual:relay:output:end}
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:virtual}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- corruption}
    \begin{algorithmic}[1]
      \State On (\textsc{corrupt}) by $P$, addressed to \alice:
      \Indent
        \State ensure $P \in \{\mathtt{opener}, \adversary\}$
        \ForAll{$(\_, \_, (\mathrm{fundee}, \_), (\alice, \_)) \in
        \mathtt{funded}$}
          \State send (\textsc{corrupt}) to fundee and ensure reply is
          (\textsc{ok})
        \EndFor
        \If{$\mathit{State} \in \{\textsc{open base}, \textsc{open virtual}\}$}
          \State $C \gets$ TX \{input: $F$.output, outputs: $(c_A, pk_{A,
          \mathrm{out}}), (c_B, pk_{B, \mathrm{out}} \wedge t)$\}
          \State $\mathrm{sig}_{A, C} \gets \textsc{sign}(C, sk_{A, F})$
        \EndIf
        \State from now on, allow \adversary to handle all \alice's messages,
        i.e. act as a relay
        \If{\bob is not corrupted}
          \State from now on, override reactions to messages (\textsc{open}) and
          (\textsc{pay}) addressed to \bob with those defined in the current
          Figure
        \EndIf
        \State output (\textsc{ok}) to $P$
      \EndIndent
      \Statex

      \State On (\textsc{open}, $c_F$, $pk_{A, \mathrm{out}}$, $pk_{B,
      \mathrm{out}}$) by \bob:
      \Indent
        \State ensure $\mathit{State} = (\textsc{topped up}, \bob)$ \TODO{decide
        what happens when channel funded by corrupted party}
        \State ensure $c_F = c_{\mathrm{on}}$
        \State $(sk_{B, F}, pk_{B, F}) \gets \textsc{keyGen}()$
        \State send $(\textsc{open}, c_F, pk_{A, \mathrm{out}}, pk_{B,
        \mathrm{out}}, pk_{B, F}, \bob)$ to \adversary, assign reply to ($pk_{A,
        F}$, $C =$ TX \{input: $F$.output, outputs: ($c_F, pk_{B, \mathrm{out}}
        \wedge t$), ($0, pk_{A, \mathrm{out}}$)\}, $\mathrm{sig}_{A, C}$)
        \State ensure \textsc{verify}($C$, $\mathrm{sig}_{A, C}$, $pk_{A, F}$) =
        True
        \State $F \gets$ TX \{input: \texttt{base\_output}, output: $(c_F,
        2/\{pk_{A, F}, pk_{B, F}\})$\}
        \State $\mathrm{sig}_F \gets \textsc{sign}(F, sk)$
        \State $\mathit{State} \gets \textsc{waiting for ledger}$
        \State input $(\textsc{submit}, (F, \mathrm{sig}_F))$ to \ledger
      \EndIndent
      \Statex

      \State On (\textsc{pay}, $x$) by \bob:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure $c_B - \mathrm{locked}_B \geq x$
        \State send (\textsc{pay}, $x$, \bob) to \adversary and assign reply to
        ($C' =$ TX \{input: $F$.output, outputs: $(c_A + x, pk_{A, \mathrm{out}}),
        (c_B - \mathrm{locked}_B - x, pk_{B, \mathrm{out}} \wedge t)$\},
        $\mathrm{sig}_{A, C}'$) \TODO{think about locked coins again}
        \State ensure \textsc{verify}($C'$, $\mathrm{sig}_{A, C}'$, $pk_{A, F}$)
        = True
        \State $C \gets C'$; $\mathrm{sig}_{A, C} \gets \mathrm{sig}_{A, C}'$
        \State $c_B \gets c_B - x; c_A \gets c_A + x$
        \State output (\textsc{pay success}) to \bob
      \EndIndent
      \Statex

      \State \TODO{receive payment from corrupted counterparty}
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:corruption}
\end{figure}
