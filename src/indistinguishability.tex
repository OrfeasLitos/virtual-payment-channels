\begin{theorem}[Recursive Virtual Payment Channel Security]
  \label{theorem:security}
  The protocol $\pchan$ realises $\fchan$ given a global functionality
  $\ledger$ and assuming the security of the underlying digital signature.
  Specifically,
  \begin{gather*}
    \forall \text{ PPT } \adversary, \exists \text{ PPT } \simulator: \forall
    \text{ PPT } \environment \text{ it is }
    \textsc{exec}^{\ledger}_{\pchan, \adversary, \environment} \approx
    \textsc{exec}^{\fchan, \ledger}_{\simulator, \environment}
  \end{gather*}
\end{theorem}

\begin{proof}
  By inspection of Figs.~\ref{code:functionality:rules}
  and~\ref{code:simulator:flow} we can deduce that for a particular
  \environment, in the ideal world execution $\textsc{exec}^{\fchan,
  \ledger}_{\simulator_{\adversary}, \environment}$, $\simulator_{\adversary}$
  simulates internally the two \pchan parties exactly as they would execute
  in the real world execution, $\textsc{exec}^{\ledger}_{\pchan,
  \adversary, \environment}$ in case \fchan does not halt. Indeed, \fchan only
  halts with negligible probability according to Lemma~\ref{lemma:no-halt},
  therefore the two executions are computationally indistinguishable.
\end{proof}

We now generalise Theorem~\ref{theorem:security} to prove the
indistinguishability of multiple \fchan instances from multiple \pchan
instances, leveraging the definition of the multi-session extension of an ideal
functionality~\cite{DBLP:conf/crypto/CanettiR03}.

\begin{definition}[Multi-Session Extension of a Protocol]
  Let protocol $\pi$. Its \emph{multi-session extension} $\hat{\pi}$ has the
  same code as $\pi$ and has 2 session ids: the ``sub-session id''
  \emph{ssid} which replaces the session id of $\pi$ and the usual session id
  \emph{sid} which has no further function apart from what is prescribed by the
  UC framework.
\end{definition}

\begin{theorem}[Indistinguishability of multiple sessions]
  Let \fchanhat the multi-session extension of \fchan and \pchanhat the
  protocol-multi-session extension of \pchan.
  \begin{gather*}
    \forall \text{ PPT } \adversary, \exists \text{
    PPT } \simulator: \forall \text{ PPT } \environment \text{ it is }
    \textsc{exec}^{\ledger}_{\pchanhat, \adversary, \environment} \approx
    \textsc{exec}^{\fchanhat, \ledger}_{\simulator, \environment}
  \end{gather*}
\end{theorem}

\begin{proof}
  Let $N \in \mathbb{N}^*$ be the number of distinct \emph{ssid}s that
  \environment uses in its messages to \pchanhat or \fchanhat instances plus the
  number of distinct \emph{sid}s that \environment uses in its messages to
  \pchan or \fchan instances throughout the entire execution. We will prove the
  theorem by induction in the number of underlying sessions $n$ in \fchanhat.

  For the base case $n=1$, in the real world the instances of \pchanhat behave
  exactly like \pchan in the real world execution of
  Theorem~\ref{theorem:security} except for the change of \emph{sid} to
  \emph{ssid}. Likewise \fchanhat has the exact same interface as its underlying
  \fchan, except for the change of \emph{sid} to \emph{ssid}. Therefore
  according to Theorem~\ref{theorem:security}, in the base case the two worlds
  are indistinguishable.

  The induction hypothesis is that the theorem holds for $n = k$, where $N > k >
  1$. We will now show that it then also holds for the case $n = k + 1$, thus
  concluding the proof. Fix an environment $\textsc{exec}_1^{\Pi}$ and
  $\textsc{exec}_1^{\mathcal{F}}$ the real and ideal world execution
  respectively when $n = k$, likewise $\textsc{exec}_2^{\Pi}$ and
  $\textsc{exec}_2^{\mathcal{F}}$ when $n = k + 1$. \TODO{continue}
\end{proof}
