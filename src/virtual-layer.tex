\begin{figure}[H]
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State \textsc{fund}($c$, \texttt{hops}, (\texttt{funder},
      \texttt{fundee}), (\texttt{host\_funder}, \texttt{host\_fundee}),
      \textsc{pcn}, \textit{vid}):
      \Indent
        \State \TODO{do VChan() with hops -- $P_{i-1} P_i, P_i P_{i+1}$ and all
        $P_1 P_n$ held by BOTH $R_{i-1}$ and $L_i$. $P_{i-1} P_i$ held only by
        $R_{i-1}$, $P_i P_{i+1}$ held only by $L_i$. This (probably) ensures
        that only relevant parties can close their channels (with the exception
        of honest $R_{i-1}$ wanting to leave channels virtual but corrupted
        $L_i$ demoting them to base, which however doesn't cost funds to
        anyone), but that they have minimal impact to the decisions of ajdacent
        channels. All $P_{i-1} P_i$ inputs must be signed by $R_{i-1}$ and all
        $P_i P_{i+1}$ inputs by $L_i$.}
      \EndIndent
      \State ensure \texttt{host\_funder} = \alice \: \Comment{we are hosting
      the funder}
      \State $(pk_{A, V}, pk_{B, V}) \gets$ \textsc{pcn.virtualKeys}($c$,
      \texttt{fundee}, \texttt{host\_funder}, \texttt{host\_fundee})
      \State $C_{\mathrm{temp}} \gets C_i$ with $c$ coins moved
      from \alice's output to new 2/\{$pk_{A, V}$, $pk_{B, V}$\} output named
      \texttt{virtual\_output} \TODO{make more formal}
      \State ensure \textsc{pcn.openVirtual}(\texttt{fundee},
      \texttt{host\_funder}, \texttt{host\_fundee}, $c$,
      \texttt{virtual\_output}) returns (\textsc{ok})
      \TODO{continue}
        \State $(L_0, R_0) \gets (\alice, \bob)$
        \label{code:functionality:chan:skeleton:virtual:fund:init}
        \ForAll{$(P, pk) \in \mathtt{hops}$} \Comment{$i \in \{1, \dots,
        |\mathtt{hops}|\}$}
        \label{code:functionality:chan:skeleton:virtual:fund:for:allow:start}
          \State send (\textsc{allow fund}, $c$, \texttt{sub\_parties}, vid, $i
          \overset{?}{=} |\mathtt{hops}|$) to $P$ as \alice and ensure reply
          is (\textsc{ok})
          \label{code:functionality:chan:skeleton:virtual:fund:for:allow:send}
        \EndFor
        \label{code:functionality:chan:skeleton:virtual:fund:for:allow:end}
        \If{both channel parties are honest}
          \State send (\textsc{is open successful}, vid) to \adversary and ensure
          reply is (\textsc{ok})
        \ElsIf{only \alice is honest}
          \State $(sk_{A, V}, pk_{A, V}) \gets \textsc{keyGen}()$
          \State send (\textsc{update to virtual}, $pk_{A, V}$) to \adversary
          and assign reply to ($V =$ TX \{input: $F$.output, outputs: ($c_A +
          c_B - c$, $2/\{pk_{A, V}, pk_{B, V}\}$), ($c$, $2/\{pk_{G, V}, pk_{A,
          V}\}$), (0, $|\mathtt{hops}|$/$\{\mathtt{hops}_i.pk\}_i$)\},
          $\mathrm{sig}_{B, V}$, $C' =$ TX \{input: $V$.outputs.0, outputs:
          $(c_A - \mathrm{locked}_A - c, pk_{A, \mathrm{out}} \wedge t), (c_B -
          \mathrm{locked}_B, pk_{B, \mathrm{out}})$\}, $\mathrm{sig}_{B, C'}$)
          \TODO{think about locked coins}
          \State ensure \textsc{verify}($V$, $\mathrm{sig}_{B, V}$, $pk_{B,
          F}$) = \textsc{verify}($C'$, $\mathrm{sig}_{B, C'}$, $pk_{A, V}$) =
          True
        \EndIf
        \label{code:functionality:chan:skeleton:virtual:fund:simulate}
        \ForAll{$(P, pk) \in \mathtt{hops}$} \Comment{$i \in \{1, \dots,
        |\mathtt{hops}|\}$}
        \label{code:functionality:chan:skeleton:virtual:fund:confirm}
          \State send (\textsc{fund done}, vid) to $P$ as \alice and ensure reply
          is (\textsc{ok})
        \EndFor
        \State $c_A \gets c_A - c$
        \If{only \alice is honest}
          \State $C \gets C'$; $\mathrm{sig}_{B, C} \gets \mathrm{sig}_{B, C'}$
        \EndIf

      \State \Comment{notification to hop that locks coins}
      \State On (\textsc{allow fund}, $c$, \texttt{sub\_parties},
      \texttt{next\_hop}, id, \texttt{is\_last}) by \charlie:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure $c_A - \mathrm{locked}(A) \geq c$
        \State ensure \bob belongs to the same group as \texttt{next\_hop}
        \State output received message to \dave and ensure reply is
        \textsc{(ok)}
        \State send (\textsc{allow fund}, $c$, \texttt{sub\_parties},
        \texttt{next\_hop}, id, \texttt{is\_last}, \charlie) to \bob and ensure
        reply is (\textsc{ok})
        \State add (id, \texttt{is\_last}, \texttt{sub\_parties}, $c$,
        \textsc{we lock}) to \texttt{pending}
        \State send (\textsc{ok}) to \charlie
      \EndIndent
      \Statex

      \State \Comment{notification to hop that doesn't lock coins -- doesn't ask
      \environment}
      \State On (\textsc{allow fund}, $c$, \texttt{sub\_parties},
      \texttt{next\_hop}, id, \texttt{is\_last}, \charlie) by \bob:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure $c_A - \mathrm{locked}(A) \geq c$
        \State ensure we belong to the same group as \texttt{next\_hop}
        \State add (id, \texttt{is\_last}, \texttt{sub\_parties}, $c$,
        \textsc{we don't lock}) to \texttt{pending}
        \State send (\textsc{ok}) to \bob
      \EndIndent
      \Statex

      \State \textsc{close}($P$):
        \TODO{continue}
        \TODO{handle arbitrarily nested virtuals (now we only handle one level
        and it leads to nested ifs}
        \If{both channel parties are honest}
          \If{$\mathtt{funded} \neq \emptyset$}
            \State \TODO{prepare virtual layer TX $V$ and its signature --
            careful, may be unneded!}
            \State $C \gets$ TX \{input: $V$.output, outputs: $(c_A, pk_{A,
            \mathrm{out}} \wedge t), (c_B, pk_{B, \mathrm{out}})$\}
            \State $\mathrm{sig}_{B, C} \gets \textsc{sign}(C, sk_{B, V})$
            \State $\mathrm{sig}_{A, C} \gets \textsc{sign}(C, sk_{A, V})$
          \Else
            \State $C \gets$ TX \{input: $F$.output, outputs: $(c_A, pk_{A,
            \mathrm{out}} \wedge t), (c_B, pk_{B, \mathrm{out}})$\}
            \State $\mathrm{sig}_{B, C} \gets \textsc{sign}(C, sk_{B, F})$
            \State $\mathrm{sig}_{A, C} \gets \textsc{sign}(C, sk_{A, F})$
          \EndIf
        \EndIf \: \Comment{if \bob is corrupted, we already have $C$ and
        $\mathrm{sig}_{B, C}$}
        \State $\mathit{State} \gets \textsc{closed}$
        \If{$\mathit{State} = \textsc{open base}$}
          \State input (\textsc{submit}, $(V, \mathrm{sig}_{A, V},
          \mathrm{sig}_{B, V})$, $(C, \mathrm{sig}_{A, C}, \mathrm{sig}_{B,
          C})$) to \ledger
        \Else \: \Comment{$\mathit{State} = \textsc{open virtual}$}
          \If{\alice is the one that had received (\textsc{open virtual}, $\dots$)
          by \texttt{opener}}
            \State $\texttt{initiator} \gets \texttt{opener}$; $\texttt{other}
            \gets \texttt{outer\_peer}$
          \Else \: \Comment{\bob had received (\textsc{open virtual} $\dots$)}
            \State $\texttt{initiator} \gets \texttt{outer\_peer}$;
            $\texttt{other} \gets \texttt{opener}$
          \EndIf
          \If{both parties are honest}
            \If{$\texttt{funded} \neq \emptyset$}
              \State \TODO{prepare virtual layer TXs $V_A, V_B$ and their
              signatures}
              \State $C' \gets$ TX \{input: $V$.output, outputs: $(c_A, pk_{A,
              \mathrm{out}}), (c_B, pk_{B, \mathrm{out}} \wedge t)$\}
              \State $\mathrm{sig}_{A, C}' \gets \textsc{sign}(C', sk_{A, V})$;
              $\mathrm{sig}_{B, C}' \gets \textsc{sign}(C', sk_{B, V})$
            \Else \: \Comment{there are no virtual channels on top of us}
              \State $C' \gets$ TX \{input: $F$.output, outputs: $(c_A, pk_{A,
              \mathrm{out}}), (c_B, pk_{B, \mathrm{out}} \wedge t)$\}
              \State $\mathrm{sig}_{A, C}' \gets \textsc{sign}(C', sk_{A, F})$;
              $\mathrm{sig}_{B, C}' \gets \textsc{sign}(C', sk_{B, F})$
            \EndIf
            \State provide delayed output (\textsc{peer closed virtual}, $(V_B,
            \mathrm{sig}_{A, V_B}, \mathrm{sig}_{B, V_B})$, $(C',
            \mathrm{sig}_{A, C}', \mathrm{sig}_{B, C}')$) to \texttt{other} as
            \bob
          \EndIf
          \If{$\mathtt{funded} \neq \emptyset$}
            \State $\mathtt{output} \gets (\textsc{closed virtual}, (V,
            \mathrm{sig}_{A, V}, \mathrm{sig}_{B, V}), (C, \mathrm{sig}_{A, C},
            \mathrm{sig}_{B, C}))$
          \Else
            \State $\mathtt{output} \gets (\textsc{closed virtual}, (C,
            \mathrm{sig}_{A, C}, \mathrm{sig}_{B, C}))$
          \EndIf
          \State output \texttt{output} to \texttt{initiator} as \alice
        \EndIf
        \Statex

        \State \textsc{closed}($c_L$, $c_R$, $(\mathrm{tx}_i,
        (\sigma_{ij})_j)_i$):
        \Indent
          \ForAll{$i$ in $1 \dots |(\mathrm{tx}_i, (\sigma_{ij})_j)_i|$}
            \State ensure \textsc{verify}($\mathrm{tx}_i$, $(\sigma_{ij})_j$) =
            True
          \EndFor
          \State ensure ($\mathrm{tx}_1$, $(\sigma_{1j})_j$) has exactly $1$
          input, which spends an output of $V$ of value $c_L + c_R$
          \State return (\textsc{ok})
        \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer}
\end{figure}
