\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- init \& top up}
    \begin{algorithmic}[1]
      \State Initialisation: \Comment{runs on first activation}
      \Indent
        \State $\mathit{State} \gets \textsc{init}$
        \State $(\mathrm{locked}_A, \mathrm{locked}_B) \gets (0, 0)$
      \EndIndent
      \Statex

      \State On (\textsc{top up}, $c_{\mathrm{min}}$) by \alice:
      \label{code:functionality:chan:skeleton:init:top_up:start}
      \Indent
        \State ensure $\mathit{State} = \textsc{init}$
        \State $\mathit{State} \gets \textsc{sent key}$
        \State $(sk, pk) \gets \textsc{KeyGen}()$
        \State output (\textsc{public key}, $pk$) to \alice
        \label{code:functionality:chan:skeleton:init:top_up:end}
      \EndIndent
      \Statex

      \State On (\textsc{check top up}) by \alice:
      \label{code:functionality:chan:skeleton:init:check_top_up:start}
      \Indent
        \State ensure $\mathit{State} = \textsc{sent key}$
        \State send (\textsc{read}) to \ledger as \alice and assign reply to
        $\Sigma$
        \State ensure $\exists \mathrm{tx} \in \Sigma, c_{\mathrm{on}}:
        c_{\mathrm{on}} \geq c_{\mathrm{min}} \wedge (c_{\mathrm{on}}, pk) \in
        \mathrm{tx.outputs}$
        \State $\mathtt{base\_output} \gets (c_{\mathrm{on}}, pk) \text{ of tx}$
        \State $\mathit{State} \gets (\textsc{topped up}, \alice)$
        \State output (\textsc{topped up}) to \alice
        \label{code:functionality:chan:skeleton:init:check_top_up:end}
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:init}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- base}
    \begin{algorithmic}[1]
      \State On (\textsc{open}, $c_F$, $pk_{A, \mathrm{out}}$, $pk_{B,
      \mathrm{out}}$) by \alice:
      \Indent
        \State ensure $\mathit{State} = (\textsc{topped up}, \alice)$
        \State ensure $c_F = c_{\mathrm{on}}$
        \State $(sk_{A, F}, pk_{A, F}) \gets \textsc{KeyGen}()$; $(sk_{B, F},
        pk_{B, F}) \gets \textsc{KeyGen}()$
        \State $F \gets$ TX \{input: \texttt{base\_output}, output: $(c_F,
        2/\{pk_{A, F}, pk_{B, F}\})$\}
        \State $F \gets F\mathrm{.sign(}sk\mathrm{)}$
        \State $\mathit{State} \gets \textsc{waiting for ledger}$
        \State send $(\textsc{open}, c_F, pk_{A, \mathrm{out}}, pk_{B,
        \mathrm{out}}, F, \alice)$ to \adversary and ensure reply is
        (\textsc{ok})
        \State output (\textsc{ok}) to \alice
      \EndIndent
      \Statex

      \State On (\textsc{check funding}) by \alice:
      \Indent
        \State ensure $\mathit{State} = \textsc{waiting for ledger}$
        \State send (\textsc{read}) to \ledger as \alice and assign reply to
        $\Sigma$
        \State ensure $F \in \Sigma$
        \State $c_A \gets c$; $c_B \gets 0$
        \State $\mathit{State} \gets \textsc{open base}$
        \State output (\textsc{open success}) to \alice
      \EndIndent
      \Statex

      \State On (\textsc{pay}, $x$) by $\dave \in \{\alice, \bob\}$:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure $c_D - \mathrm{locked}_D \geq x$
        \State send (\textsc{pay}, $x$, \dave) to \adversary and expect reply
        (\textsc{ok})
        \State $c_D \gets c_D - x; c_{\bar{D}} \gets c_{\bar{D}} + x$
        \Comment{$\bar{D}$ is \alice if $D$ is \bob and vice-versa}
        \State output (\textsc{pay success}) to \dave
      \EndIndent
      \Statex

      \State On (\textsc{balance}) by $\dave \in \{\alice, \bob\}$:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State output (\textsc{balance}, $(c_A, c_B, \mathrm{locked}_A,
        \mathrm{locked}_B)$) to \dave % TODO: maybe remove locked_{A,B}
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:base}
\end{figure}

% TODO: think more about closing
\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- close}
    \begin{algorithmic}[1]
      \State On (\textsc{close}) by \alice:
      \Indent
        \If{$\mathit{State} = \textsc{open base}$}
          \State $C \gets$ TX \{input: $F$.out, outputs: $(c_A, pk_{A,
          \mathrm{out}}), (c_B, pk_{B, \mathrm{out}})$\}
          \State $C \gets C\mathrm{.sign(sk_{A, F}, sk_{B, F}}\mathrm{)}$
          \State $\mathit{State} \gets \textsc{closed}$
          \State input (\textsc{submit}, $C$) to \ledger
        \ElsIf{$\mathit{State} = \textsc{open virtual}$}
          \State $\mathit{State} \gets \textsc{closed}$
          \State output (\textsc{closing}, $c_A$, $c_B$) to \texttt{opener}
        \EndIf
      \EndIndent
      \Statex

      \State On (\textsc{closing}, $c_{\mathrm{left}}$, $c_{\mathrm{right}}$) by
      \fchan:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure $((c_L, c_R), \mathrm{hops}, (\charlie, \dave), (\frank,
        \george), \mathrm{id}) \in \mathtt{funded}$ with $\frank \in \{\alice,
        \bob\}$
        \State ensure $c_{\mathrm{left}} \leq c_L + c_R$
        \State remove entry from \texttt{funded}
        \State output (\textsc{closed virtual}, $c_{\mathrm{right}}$, id) to
        \frank
      \EndIndent
      \Statex

      \State On (\textsc{closed virtual}, $c_{\mathrm{right}}$, id) by \fchan:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure $(\mathrm{virtual}, c, \fchan, \dave, \mathrm{id}) \in
        \mathtt{funded}$
        \State ensure $c_{\mathrm{right}} \leq c$
        \State send (\textsc{closed}) to virtual and expect reply (\textsc{yes})
        \State $c_D \gets c_D + c_{\mathrm{right}}$
        \State remove entry from \texttt{funded}
      \EndIndent
      \Statex

      \State On (\textsc{closed}) by $P$:
      \Indent
        \If{$\mathit{State} = \textsc{closed}$}
          \State send (\textsc{yes}) to $P$
        \Else
          \State send (\textsc{no}) to $P$
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:close}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- virtual}
    \begin{algorithmic}[1]
      \State On (\textsc{fund you}, $c$, \dave) by $\charlie$ as input to
      \alice: \Comment{\alice is funded by \charlie}
      \label{code:functionality:chan:skeleton:virtual:fund-you}
      \Indent
        \State ensure $\mathit{State} = \textsc{init}$
        \State $\bob \gets \dave$
        \State send (\textsc{fund you}, $c$, \bob, \charlie, \alice) to
        \adversary and ensure reply is \textsc{(ok)}
        \label{code:functionality:chan:skeleton:virtual:inform}
        \State $c_A \gets c; c_B \gets 0$
        \State $\mathtt{opener} \gets \charlie$
        \State $\mathit{State} \gets \textsc{open virtual}$
        \State output (\textsc{ok}) to \charlie
      \EndIndent
      \Statex

      \State On (\textsc{fund}, $c$, hops, \texttt{sub\_parties} = (fundee,
      counterparty), \texttt{outer\_parties} = (\alice, \dave)) by \alice:
      \Comment{we fund another channel}
      % TODO: decide if \alice of outer_parties should be \charlie instead
      \label{code:functionality:chan:skeleton:virtual:fund}
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure $c_A - \mathrm{locked}_A \geq c$
        \State input (\textsc{fund you}, $c$, counterparty) to fundee as \alice,
        ensure output is (\textsc{ok})
        \label{code:functionality:chan:skeleton:virtual:subfunc}
        \State generate random id
        \label{code:functionality:chan:skeleton:virtual:id}
        \State send (\textsc{fund} $c$, hops, \texttt{sub\_parties} = (fundee,
        counterparty), \texttt{outer\_parties} = (\alice, \dave),
        \texttt{funder} = \alice, id) to \adversary and ensure reply is
        (\textsc{ok})
        \label{code:functionality:chan:skeleton:virtual:fund}
        \State $(L_0, R_0) \gets (\alice, \bob)$
        \label{code:functionality:chan:skeleton:virtual:fund:init}
        \ForAll{$(L_i, R_i) \in \mathrm{hops}$} \Comment{$i \in \{1, \dots,
        |\mathrm{hops}|\}$}
        \label{code:functionality:chan:skeleton:virtual:fund:for:allow:start}
          \State ensure $R_{i-1} = L_i$
          \State send (\textsc{allow fund}, $c$, \texttt{sub\_parties},
          $\mathtt{local\_funder} \gets L_i$, id, $i \overset{?}{=}
          |\mathrm{hops}|$) to $L_i$ as \alice and ensure reply is (\textsc{ok})
          \label{code:functionality:chan:skeleton:virtual:fund:for:allow:send}
        \EndFor
        \label{code:functionality:chan:skeleton:virtual:fund:for:allow:end}
        \State send (\textsc{is open successful}, id) to \adversary and ensure
        reply is (\textsc{ok})
        \label{code:functionality:chan:skeleton:virtual:fund:simulate}
        \ForAll{$(L_i, R_i) \in \mathrm{hops}$} \Comment{$i \in \{1, \dots,
        |\mathrm{hops}|\}$}
        \label{code:functionality:chan:skeleton:virtual:fund:confirm}
          \State send (\textsc{fund done}, id) to $L_i$ as \alice and ensure
          reply is (\textsc{ok})
        \EndFor
        \State $c_A \gets c_A - c$
        % TODO: decide if need to store hops here
        \State add (($c$, 0), hops, \texttt{sub\_parties},
        \texttt{outer\_parties}, id) to \texttt{funded}
        \label{code:functionality:chan:skeleton:virtual:fund:store}
        \State output (\textsc{ok}) to \alice
      \EndIndent
      \Statex

      \State On (\textsc{allow fund}, $c$, \texttt{sub\_parties}, \dave, id,
      \texttt{is\_last}) by \charlie:
      \label{code:functionality:chan:skeleton:virtual:allow-fund}
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure $\dave \in \{\alice, \bob\}$
        \State ensure $c_D - \mathrm{locked}_D \geq c$
        \State output received message to \dave and ensure reply is
        \textsc{(ok)}
        \State $\mathrm{locked}_D \gets \mathrm{locked}_D + c$
        \State add (id, \texttt{is\_last}, \texttt{sub\_parties}, $c$, \dave) to
        \texttt{pending}
        \State send (\textsc{ok}) to \charlie
      \EndIndent
      \Statex

      \State On (\textsc{fund done}, id) by \charlie:
      \Indent
        \State ensure $\mathit{State} \in \{\textsc{open base}, \textsc{open
        virtual}\}$
        \State ensure $(\mathrm{id}, \mathtt{is\_last}, \mathtt{sub\_parties},
        $c$, \dave) \in \mathtt{pending}$
        \State remove (id, \texttt{is\_last}, \texttt{sub\_parties}, $c$, \dave)
        from \texttt{pending}
        \If{\texttt{is\_last}}
          \State add ((0, $c$), $\bot$, \texttt{sub\_parties}.reverse(),
          (\dave, $\bot$), id) to \texttt{funded}
        \EndIf
        \State send (\textsc{ok}) to \charlie
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:virtual}
\end{figure}

\begin{figure}[H]
  \begin{systembox}{$\mathcal{F}_{\mathrm{Chan}}$ -- corruption}
    \begin{algorithmic}[1]
      \State On (\textsc{corrupt}) by $P$, addressed to \alice:
      \Indent
        \State ensure $P \in \{\mathtt{opener}, \adversary\}$
        \ForAll{$(\_, \_, (\mathrm{fundee}, \_), (\alice, \_)) \in
        \mathtt{funded}$}
          \State send (\textsc{corrupt}) to fundee and ensure reply is
          (\textsc{ok})
        \EndFor
        \State from now on, allow \adversary to handle all \alice's messages,
        i.e. act as a relay
        \If{\bob is not corrupted}
          \State from now on, override reactions to messages addressed to \bob
          with those defined in the following Figures: % TODO: add \ref{}s
        \EndIf
        \State output (\textsc{ok}) to $P$
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{code:functionality:chan:skeleton:corruption}
\end{figure}
