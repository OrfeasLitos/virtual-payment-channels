\section{Security}
  \label{section:security}
  The first step to formally arguing about the security of Elmo is to
  clearly delineate the exact security guarantees it provides. To that end, we
  first prove two similar claims regarding the conservation of funds in the real
  and ideal world, Lemmas~\ref{lemma:real-balance-security-informal}
  and~\ref{lemma:ideal-balance-informal} respectively. Informally, the first
  establishes that if an honest, non-negligent party was implicated in a channel
  on which a number of payments took place and has now been unilaterally closed,
  then the party will have at least the expected funds on-chain.

\begin{lemma}[Real world balance security (informal)]
\label{lemma:real-balance-security-informal}
  Consider a real world execution with $P \in \{\alice, \bob\}$ honest
  \textsc{ln} ITI. Assume that all of the following are true:
  \begin{itemize}
    \item $P$ is not negligent,
    \item $P$ successfully opened the channel, with initial balance $c$ ($c = 0$
    if $P$ is a fundee)
    \item $P$ is the host of $n$ channels, where the $i$-th channel is funded
    with $f_i$ coins,
    \item $P$ has cooperatively closed $k$ channels, where the $i$-th channel
    transferred $r_i$ coins from the hosted virtual channel to $P$,
    \item $P$ has successfully sent $m$ payments, where the $i$-th payment
    involved $d_i$ coins,
    \item $P$ has successfully received $l$ payments, where the $i$-th payment
    involved $c_i$ coins.
  \end{itemize}
  If $P$ unilaterally closes its channel, eventually its view of \ledger will contain $h$
  outputs spendable only by $P$ or another kindred party, each of value $c_i$,
  such that
  \begin{equation}
    \sum\limits_{i=1}^h c_i \geq c - \sum\limits_{i=1}^n f_i -
    \sum\limits_{i=1}^m d_i + \sum\limits_{i=1}^l e_i + \sum\limits_{i=1}^k r_i
    \enspace.
  \end{equation}
\end{lemma}
The formal statement, Lemma~\ref{lemma:real-balance-security}, is deferred to
the Appendix.

  The second lemma states that for an ideal party in a
  similar situation, the balance that \fchan has stored for it is at least equal
  to the expected funds.

\begin{lemma}[Ideal world balance (informal)]
\label{lemma:ideal-balance-informal}
  Consider an ideal world execution with functionality \fchan and simulator
  \simulator. Let $P \in \{\alice, \bob\}$ one of the two parties of \fchan.
  Assume that all of the following are true:
  \begin{itemize}
    \item $P$ is not corrupted or negligent, nor any member of the
    transitive closure of its hosts has published a revocation transaction,
    \item $P$ successfully opened the channel, with initial balance $c$ ($c = 0$
    if $P$ is a fundee)
    \item $P$ is the host of $n$ channels, where the $i$-th channel is funded
    with $f_i$ coins,
    \item $P$ has cooperatively closed $k$ channels, where the $i$-th channel
    transferred $r_i$ coins from the hosted virtual channel to $P$,
    \item $P$ has successfully sent $m$ payments, where the $i$-th payment
    involved $d_i$ coins,
    \item $P$ has successfully received $l$ payments, where the $i$-th payment
    involved $c_i$ coins.
  \end{itemize}
  Let $\texttt{balance}_P$ be the balance that \fchan stores internally for $P$.
  If the channel is closed (either unilaterally or cooperatively), then the
  following holds with overwhelming probability on the security parameter:
  \begin{equation}
    \texttt{balance}_P = c - \sum\limits_{i=1}^n f_i - \sum\limits_{i=1}^m d_i +
    \sum\limits_{i=1}^l e_i + \sum\limits_{i=1}^k r_i + \sum\limits_{i=1}^k r_i
    \enspace.
  \end{equation}
\end{lemma}
The formal statement, Lemma~\ref{lemma:ideal-balance}, is deferred to the
Appendix.

  In both cases the expected funds are [initial balance - funds for hosted
  virtuals + funds returned from hosted virtuals - outbound payments + inbound
  payments]. Note that the funds for hosted virtuals only refer to those funds
  used by the funder of the virtual channel, not the rest of the base parties.

  Both proofs follow all possible execution paths, keeping track of the
  resulting balance in each case and coming to the conclusion that balance is
  secure in all cases, except if signatures are forged.

  It is important to note that in fact \pchan provides a stronger guarantee,
  namely that an honest, non-negligent party with an open channel can
  unilaterally close it and obtain the expected funds on-chain within a known
  number of blocks, given that \environment sends the necessary ``daemon'' messages.
  This stronger guarantee is sufficient to make Elmo reliable
  enough for real-world applications. However a corresponding ideal world
  functionality with such guarantees would have to be aware of the specific
  transactions and signatures, therefore it would be essentially as complicated
  as the protocol, thus violating the spirit of the simulation-based security
  paradigm.

  Subsequently we prove Lemma~\ref{lemma:no-halt}, which informally states that
  if an ideal party and all its kindred parties are honest, then \fchan does not
  halt with overwhelming probability.

\begin{lemma}[No halt]
\label{lemma:no-halt}
  In an ideal execution with \fchan and \simulator, if the kindred parties of
  the honest parties of \fchan are themselves honest, then the functionality
  halts with negligible probability in the security parameter (i.e.\
  l.~\ref{code:functionality:close:halt} of Fig.~\ref{code:functionality:close}
  is executed negligibly often).
\end{lemma}

  This is proven by first arguing that if
  the conditions of Lemma~\ref{lemma:ideal-balance} for the ideal world hold,
  then the conditions of Lemma~\ref{lemma:real-balance-security} also hold for
  the equivalent real world execution, therefore in this case \fchan does not
  halt. We then argue that also in case the conditions of
  Lemma~\ref{lemma:ideal-balance} do not hold, \fchan may never halt as well,
  therefore concluding the proof.
  The formal proofs are deferred to Appendix~\ref{sec:proofs}.

  A salient observation regarding an instance $s$ of \pchan is that, in order to
  open a virtual channel, it passes inputs to another \pchan instance $s'$ that
  belongs to a different extended session. This means that $s$ (and therefore
  \pchan) is not \emph{subroutine respecting}, as defined in~\cite{uc}. To
  address this issue, we first annotate \pchan with a numeric superscript, i.e.\
  $\pchansup{n}$. $\pchansup{1}$ is always a simple (i.e.\ on-chain) channel. To
  achieve this, \pchan undergoes a modification under which it ignores all
  (\textsc{open}, $x$, $\texttt{hops} \neq$ ``\texttt{ledger}'', $\dots$)
  messages. Likewise we define $\fchansup{1}$ as a version of \fchan that
  ignores (\textsc{open}, $x$, $\texttt{hops} \neq$ ``\texttt{ledger}'',
  $\dots$) messages. As for the rest of the superscripts, $\forall n \in
  \mathbb{N}^*, \pchansup{n+1}$ is a virtual channel protocol \pchan of which
  the base channels have a maximum superscript $n$. It then holds that $\forall
  n \in \mathbb{N}^*, \pchansup{n}$ is $(\ledger, \pchansup{1}, \dots,
  \pchansup{n-1})$-subroutine respecting, as defined
  in~\cite{DBLP:conf/tcc/BadertscherCHTZ20}. Likewise, $\fchansup{n+1}$ is a
  virtual channel functionality \fchan of which the base channels have a maximum
  superscript $n$. It then holds that $\forall n \in \mathbb{N}^*, \fchansup{n}$
  is $(\ledger, \fchansup{1}, \dots, \fchansup{n-1})$-subroutine respecting. To
  the best of the authors' knowledge, this recursion-based proof technique for
  UC security is novel. It is of independent interest and can be reused to prove
  UC security in protocols that may use as subroutines copies of themselves.

  We now formulate and prove Theorem~\ref{theorem:security:simple}, which states
  that $\pchansup{1}$ UC-realises $\fchansup{1}$.

\begin{theorem}[Simple Payment Channel Security]
  \label{theorem:security:simple}
  The protocol $\pchansup{1}$ UC-realises $\fchansup{1}$ in the presence of a
  global functionality $\ledger$ and assuming the security of the underlying
  digital signature:
  \begin{gather*}
    \forall \text{ PPT } \adversary, \exists \text{ PPT } \simulator: \forall
    \text{ PPT } \environment \text{ it is }
    \textsc{exec}^{\ledger}_{\pchansup{1}, \adversary, \environment} \approx
    \textsc{exec}^{\fchansup{1}, \ledger}_{\simulator, \environment}
  \end{gather*}
\end{theorem}

  The corresponding proof stems from
  Lemma~\ref{lemma:no-halt}, the fact that \fchan is a simple relay and that
  \simulator faithfully simulates \pchan.

\begin{proof}[Proof of Theorem~\ref{theorem:security:simple}]
  By inspection of Figures~\ref{code:functionality:rules}
  and~\ref{code:simulator:flow} we can deduce that for a particular
  \environment, in the ideal world execution $\textsc{exec}^{\fchansup{1},
  \ledger}_{\simulator_{\adversary}, \environment}$, $\simulator_{\adversary}$
  simulates internally the two $\pchansup{1}$ parties exactly as they would execute in
  $\textsc{exec}^{\ledger}_{\pchansup{1}, \adversary, \environment}$, the real world
  execution, in case $\fchansup{1}$ does not halt. Indeed, $\fchansup{1}$ only halts with
  negligible probability according to Lemma~\ref{lemma:no-halt}, therefore the
  two executions are computationally indistinguishable.
\end{proof}

  Lastly we prove that $\forall$ integers $n \geq 2, \pchansup{n}$ UC-realises
  $\fchansup{n}$ in the presence of $\fchansup{1}, \dots, \fchansup{n-1}$
  (leveraging the relevant definition
  from~\cite{DBLP:conf/tcc/BadertscherCHTZ20}).

\begin{theorem}[Recursive Virtual Payment Channel Security]
  \label{theorem:security:virtual}
  $\forall n \in \mathbb{N}^* \setminus \{1\}$, the protocol $\pchansup{n}$
  UC-realises $\fchansup{n}$ in the presence of $\fchansup{1}, \dots,
  \fchansup{n-1}$ and \ledger, assuming the security of the underlying digital
  signature. Specifically,
  \begin{gather*}
    \forall n \in \mathbb{N}^* \setminus \{1\}, \forall \text{ PPT } \adversary,
    \exists \text{ PPT } \simulator: \forall \text{ PPT } \environment \text{ it
    is } \\
    \textsc{exec}^{\ledger, \fchansup{1}, \dots, \fchansup{n-1}}_{\pchansup{n},
    \adversary, \environment} \approx
    \textsc{exec}^{\fchansup{n}, \ledger}_{\simulator, \environment}
  \end{gather*}
\end{theorem}

\begin{proof}[Proof of Theorem~\ref{theorem:security:virtual}]
  The proof is exactly the same as that of
  Theorem~\ref{theorem:security:simple}, replacing superscripts $1$ for $n$.
\end{proof}
