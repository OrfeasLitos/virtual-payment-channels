\begin{figure}[H]
  \begin{processbox}{\textsc{virt}}
    \begin{algorithmic}[1]
      \State \textsc{fund}($c$, \texttt{hops}, (\texttt{funder},
      \texttt{fundee}), (\texttt{host\_funder}, \texttt{host\_fundee}),
      \textsc{pcn}, \textit{vid}):
      \Indent
        \State \TODO{do VChan() with hops -- $P_{i-1} P_i, P_i P_{i+1}$ and all
        $P_1 P_n$ held by BOTH $R_{i-1}$ and $L_i$. $P_{i-1} P_i$ held only by
        $R_{i-1}$, $P_i P_{i+1}$ held only by $L_i$. This (probably) ensures
        that only relevant parties can close their channels (with the exception
        of honest $R_{i-1}$ wanting to leave channels virtual but corrupted
        $L_i$ demoting them to base, which however doesn't cost funds to
        anyone), but that they have minimal impact to the decisions of ajdacent
        channels. All $P_{i-1} P_i$ inputs must be signed by $R_{i-1}$ and all
        $P_i P_{i+1}$ inputs by $L_i$.}
      \EndIndent
      \State ensure \texttt{host\_funder} = \alice \: \Comment{we are hosting
      the funder}
      \State $(pk_{A, V}, pk_{B, V}) \gets$ \textsc{pcn.virtualKeys}($c$,
      \texttt{fundee}, \texttt{host\_funder}, \texttt{host\_fundee})
      \State $(pk_{i, V})_{i \in [n]} \gets$ \textsc{virt.hostKeys}($c$,
      \texttt{hops})
      \State ensure \textsc{pcn.openVirtual}(\texttt{virtual\_output}) returns
      (\textsc{ok})
      \If{real world}
        \State \TODO{create necessary (local and remote) txs, sign them,
        aggregate signatures in \texttt{sigs}}
        \State $\mathrm{sig}_{A, C, i+1} \gets \textsc{sign}(C_{B, i+1}, sk_{A,
        F})$ \TODO{remove}
        \State \remotecode{$\texttt{old\_state} \gets \textit{State}$}
        \State $\mathit{State} \gets \textsc{updating}$
        \State send (\textsc{fund}, $c$, \texttt{hops}, \texttt{fundee},
        \texttt{virtual\_output}, \texttt{sigs}, \textit{vid}) to
        \texttt{hops}$[1]$ \Comment{\texttt{hops} is 0-indexed,
        \texttt{hops}$[0]$ = \alice}
        \While{\remotecode{we are not the last hop}}
          \State \remotecode{ensure there is a unique contiguous pair in
          \texttt{hops} such that the sender is its first and we are its second
          element}
          \State \remotecode{$(L, M, R) \gets$ (previous hop, current hop, next
          hop)}
          \State \TODO{\remotecode{create necessary local TXs}}
          \State \TODO{\remotecode{ensure all received signatures are valid on
          their relevant TXs}}
          \State \remotecode{ensure \textsc{verify}($C_{M, i+1}$,
          $\mathrm{sig}_{A, C, i+1}$, $pk_{L, F}$ = True}\TODO{remove}
          \State \remotecode{$\texttt{old\_state} \gets \textit{State}$}
          \State \remotecode{$\mathit{State} \gets \textsc{updating}$}
          \State \TODO{\remotecode{delegate to sibling channel (with $R$)}}
          \State \TODO{\remotecode{create necessary remote ($R$) TXs and
          signatures}}
          \State \remotecode{$\mathrm{sig}_{L, C, i+1} \gets \textsc{sign}(C_{R,
          i+1}, sk_{L, F})$}\TODO{remove}
          \State \remotecode{$\texttt{old\_state} \gets \textit{State}$}
          \State \remotecode{$\mathit{State} \gets \textsc{updating}$}
          \State \remotecode{send (\textsc{fund}, $c$, \texttt{hops},
          \texttt{fundee}, \texttt{virtual\_output}, \texttt{sigs},
          \textit{vid}) to $R$}\TODO{decide if \texttt{virtual\_output} makes
          sense or sth else is needed here}
        \EndWhile
        \State \remotecode{ensure we are the last hop in \texttt{hops} and that
        the previous hop is the sender}
        \State \remotecode{$(L, M) \gets$ (previous hop, current hop)}
        \State \TODO{\remotecode{create necessary local TXs}}
        \State \TODO{\remotecode{ensure all received signatures are valid on
        their relevant TXs}}
        \State \TODO{\remotecode{maybe delegate to \texttt{fundee} to do more
        checks and/or ask \environment}}
        \State \TODO{\remotecode{create signatures for remote TXs (and the TXs
        as needed) and sign revocation(s) of old channel version}}
        \State \remotecode{$\textit{State} \gets \texttt{old\_state}$}
        \State \TODO{\remotecode{send new version remote sigs and old version
        revocation sigs to sender}}
        \While{\remotecode{we are not the first hop}}
          \State \remotecode{ensure \textit{State} = \textsc{updating}}
          \State \TODO{\remotecode{generate relevant local TXs}}
          \State \TODO{\remotecode{verify received sigs on local TXs (both for
          new and for revoked versions)}}
          \State \TODO{\remotecode{update store of supported virtual channels as
          needed}}
          \State \remotecode{$\textit{State} \gets \texttt{old\_state}$}
          \State \TODO{\remotecode{delegate to sibling channel (with previous
          hop)}}
          \State \TODO{\remotecode{create signatures for remote TXs (and the TXs
          as needed) and sign revocation(s) of old channel version}}
          \State \remotecode{$\textit{State} \gets \texttt{old\_state}$}
          \State \TODO{\remotecode{send new version remote sigs and old version
          revocation sigs to $L$}}
        \EndWhile
        \State ensure \textit{State} = \textsc{updating}
        \State \TODO{verify received sigs on local TXs (both for new and for
        revoked versions)}
        \State \remotecode{$\textit{State} \gets \texttt{old\_state}$}
        \State \TODO{update store of supported virtual channels as needed}
        \State \Return (\textsc{ok})
      \Else \: \Comment{ideal world}
        \State \TODO{similar to real world, but do locally (and avoid
        verification) series of honest players interleaved with \simulator
        notifications, whereas require \simulator to just inform of the
        successful hopping of a series of malicious players in one message}
      \EndIf
      \TODO{expect reply from next hop with all signatures needed for next comm
      TX and the revocation sig of the previous comm TX. While waiting, ignore
      everything else apart from channel closing. Mark virtual channel as open.
      Send to next hop the revocation sig.}
      \State
      \TODO{Add logic for intermediaries and fundee}
      \Statex

      \State \textsc{close}($P$):
        \TODO{continue}
        \TODO{handle arbitrarily nested virtuals (now we only handle one level
        and it leads to nested ifs}
        \If{both channel parties are honest}
          \If{$\mathtt{funded} \neq \emptyset$}
            \State \TODO{prepare virtual layer TX $V$ and its signature --
            careful, may be unneded!}
            \State $C \gets$ TX \{input: $V$.output, outputs: $(c_A, pk_{A,
            \mathrm{out}} \wedge t), (c_B, pk_{B, \mathrm{out}})$\}
            \State $\mathrm{sig}_{B, C} \gets \textsc{sign}(C, sk_{B, V})$
            \State $\mathrm{sig}_{A, C} \gets \textsc{sign}(C, sk_{A, V})$
          \Else
            \State $C \gets$ TX \{input: $F$.output, outputs: $(c_A, pk_{A,
            \mathrm{out}} \wedge t), (c_B, pk_{B, \mathrm{out}})$\}
            \State $\mathrm{sig}_{B, C} \gets \textsc{sign}(C, sk_{B, F})$
            \State $\mathrm{sig}_{A, C} \gets \textsc{sign}(C, sk_{A, F})$
          \EndIf
        \EndIf \: \Comment{if \bob is corrupted, we already have $C$ and
        $\mathrm{sig}_{B, C}$}
        \State $\mathit{State} \gets \textsc{closed}$
        \If{$\mathit{State} = \textsc{open base}$}
          \State input (\textsc{submit}, $(V, \mathrm{sig}_{A, V},
          \mathrm{sig}_{B, V})$, $(C, \mathrm{sig}_{A, C}, \mathrm{sig}_{B,
          C})$) to \ledger
        \Else \: \Comment{$\mathit{State} = \textsc{open virtual}$}
          \If{\alice is the one that had received (\textsc{open virtual}, $\dots$)
          by \texttt{opener}}
            \State $\texttt{initiator} \gets \texttt{opener}$; $\texttt{other}
            \gets \texttt{outer\_peer}$
          \Else \: \Comment{\bob had received (\textsc{open virtual} $\dots$)}
            \State $\texttt{initiator} \gets \texttt{outer\_peer}$;
            $\texttt{other} \gets \texttt{opener}$
          \EndIf
          \If{both parties are honest}
            \If{$\texttt{funded} \neq \emptyset$}
              \State \TODO{prepare virtual layer TXs $V_A, V_B$ and their
              signatures}
              \State $C' \gets$ TX \{input: $V$.output, outputs: $(c_A, pk_{A,
              \mathrm{out}}), (c_B, pk_{B, \mathrm{out}} \wedge t)$\}
              \State $\mathrm{sig}_{A, C}' \gets \textsc{sign}(C', sk_{A, V})$;
              $\mathrm{sig}_{B, C}' \gets \textsc{sign}(C', sk_{B, V})$
            \Else \: \Comment{there are no virtual channels on top of us}
              \State $C' \gets$ TX \{input: $F$.output, outputs: $(c_A, pk_{A,
              \mathrm{out}}), (c_B, pk_{B, \mathrm{out}} \wedge t)$\}
              \State $\mathrm{sig}_{A, C}' \gets \textsc{sign}(C', sk_{A, F})$;
              $\mathrm{sig}_{B, C}' \gets \textsc{sign}(C', sk_{B, F})$
            \EndIf
            \State provide delayed output (\textsc{peer closed virtual}, $(V_B,
            \mathrm{sig}_{A, V_B}, \mathrm{sig}_{B, V_B})$, $(C',
            \mathrm{sig}_{A, C}', \mathrm{sig}_{B, C}')$) to \texttt{other} as
            \bob
          \EndIf
          \If{$\mathtt{funded} \neq \emptyset$}
            \State $\mathtt{output} \gets (\textsc{closed virtual}, (V,
            \mathrm{sig}_{A, V}, \mathrm{sig}_{B, V}), (C, \mathrm{sig}_{A, C},
            \mathrm{sig}_{B, C}))$
          \Else
            \State $\mathtt{output} \gets (\textsc{closed virtual}, (C,
            \mathrm{sig}_{A, C}, \mathrm{sig}_{B, C}))$
          \EndIf
          \State output \texttt{output} to \texttt{initiator} as \alice
        \EndIf
        \Statex

        \State \textsc{closed}($c_L$, $c_R$, $(\mathrm{tx}_i,
        (\sigma_{ij})_j)_i$):
        \Indent
          \ForAll{$i$ in $1 \dots |(\mathrm{tx}_i, (\sigma_{ij})_j)_i|$}
            \State ensure \textsc{verify}($\mathrm{tx}_i$, $(\sigma_{ij})_j$) =
            True
          \EndFor
          \State ensure ($\mathrm{tx}_1$, $(\sigma_{1j})_j$) has exactly $1$
          input, which spends an output of $V$ of value $c_L + c_R$
          \State return (\textsc{ok})
        \EndIndent
    \end{algorithmic}
  \end{processbox}
  \caption{}
  \label{code:virtual-layer}
\end{figure}
